<!doctype html>
<html data-n-head-ssr lang="zh" data-n-head="%7B%22lang%22:%7B%22ssr%22:%22zh%22%7D%7D">
  <head >
    <title>HashMap源码解析，扩容机制及其思考 - 掘金</title><meta data-n-head="ssr" charset="utf-8"><meta data-n-head="ssr" name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover"><meta data-n-head="ssr" name="apple-itunes-app" content="app-id=987739104"><meta data-n-head="ssr" name="theme-color" content="#ffffff"><meta data-n-head="ssr" name="msapplication-TileColor" content="#da532c"><meta data-n-head="ssr" vmid="description" name="description" content="位运算是对整数在内存中的二进制位进行操作。 在hashMap源码中有很多使用位运算的地方。例如: 我们都知道&amp;在java中表示与操作&amp;表示按位与，这里的位是指二进制位。都为1才为真(1),否则结果为0，举个简单的例子 在Java中，所有数据的表示方法都是以补码的形式表示，如果没…"><meta data-n-head="ssr" vmid="keywords" name="keywords" content="Java"><link data-n-head="ssr" rel="preconnect" href="//lf3-cdn-tos.bytescm.com" crossorigin="anonymous"><link data-n-head="ssr" rel="preconnect" href="//mcs.snssdk.com" crossorigin="anonymous"><link data-n-head="ssr" rel="preconnect" href="//i.snssdk.com" crossorigin="anonymous"><link data-n-head="ssr" rel="dns-prefetch" href="//lf3-cdn-tos.bytescm.com"><link data-n-head="ssr" rel="dns-prefetch" href="//api.juejin.cn"><link data-n-head="ssr" rel="dns-prefetch" href="//lf-cdn-tos.bytescm.com"><link data-n-head="ssr" rel="dns-prefetch" href="//unpkg.byted-static.com"><link data-n-head="ssr" rel="dns-prefetch" href="//p1-juejin.byteimg.com"><link data-n-head="ssr" rel="dns-prefetch" href="//p3-juejin.byteimg.com"><link data-n-head="ssr" rel="dns-prefetch" href="//p6-juejin.byteimg.com"><link data-n-head="ssr" rel="dns-prefetch" href="//p9-juejin.byteimg.com"><link data-n-head="ssr" rel="dns-prefetch" href="//p1-jj.byteimg.com"><link data-n-head="ssr" rel="dns-prefetch" href="//mcs.snssdk.com"><link data-n-head="ssr" rel="dns-prefetch" href="//i.snssdk.com"><link data-n-head="ssr" rel="apple-touch-icon" sizes="180x180" href="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/favicons/apple-touch-icon.png"><link data-n-head="ssr" rel="icon" type="image/png" sizes="32x32" href="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/favicons/favicon-32x32.png"><link data-n-head="ssr" rel="icon" type="image/png" sizes="16x16" href="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/favicons/favicon-16x16.png"><link data-n-head="ssr" rel="mask-icon" href="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/favicons/safari-pinned-tab.svg" color="#1E80FF"><link data-n-head="ssr" rel="manifest" href="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/favicons/site.webmanifest"><link data-n-head="ssr" rel="search" title="掘金" href="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/search.xml" type="application/opensearchdescription+xml"><link data-n-head="ssr" rel="stylesheet" href="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/ionicons/css/ionicons.min.css"><link data-n-head="ssr" rel="stylesheet" href="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/iconfont/index.css"><link data-n-head="ssr" rel="stylesheet" href="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/ionicons/iconfont.css"><link data-n-head="ssr" rel="stylesheet" href="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/bytedesign.min.css"><link data-n-head="ssr" rel="canonical" href="https://juejin.cn/post/6844903953566531597"><script data-n-head="ssr" type="text/javascript" src="https://lf3-cdn-tos.bytescm.com/obj/rc-web-sdk/acrawler.js"></script><script data-n-head="ssr" type="application/ld+json">[{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://juejin.cn/post/6844903953566531597"},"headline":"HashMap源码解析，扩容机制及其思考","description":"位运算是对整数在内存中的二进制位进行操作。 在hashMap源码中有很多使用位运算的地方。例如: 我们都知道&amp;在java中表示与操作&amp;表示按位与，这里的位是指二进制位。都为1才为真(1),否则结果为0，举个简单的例子 在Java中，所有数据的表示方法都是以补码的形式表示，如果没…","image":[],"author":{"@type":"Organization","name":"Forgotten在掘金"},"publisher":{"@type":"Organization","name":"掘金","logo":{"@type":"ImageObject","url":"//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/e08da34488b114bd4c665ba2fa520a31.svg"}},"datePublished":"2019年09月26日","dateModified":"2020年09月15日"},{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","name":"稀土掘金","position":1,"item":"https://juejin.cn"},{"@type":"ListItem","name":"后端","position":2,"item":"https://juejin.cn/backend"},{"@type":"ListItem","name":"文章","position":3}]}]</script><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/64b4d43.js" as="script"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/e66b202.js" as="script"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/9fca362.js" as="script"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/app.ab9b18a.css" as="style"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/9332c9f.js" as="script"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/layouts/default.2050f18.css" as="style"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/d6e38f1.js" as="script"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/51.269c955.css" as="style"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/85733d1.js" as="script"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/197.3d69a3b.css" as="style"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/8ecf414.js" as="script"><link rel="stylesheet" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/app.ab9b18a.css"><link rel="stylesheet" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/layouts/default.2050f18.css"><link rel="stylesheet" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/51.269c955.css"><link rel="stylesheet" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/197.3d69a3b.css">
  </head>
  <body >
    <div data-server-rendered="true" id="__nuxt"><div id="__layout"><div id="juejin"><!----> <div class="view-container" data-v-4b9f9746 data-v-020666e8><div class="main-header-box" data-v-4b9f9746><header visible="visible" data-fetch-key="0" class="main-header main-header unauthorized visible" data-v-611bc442 data-v-4b9f9746><div class="container" data-v-611bc442><a href="/" class="logo" data-v-611bc442><img src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/e08da34488b114bd4c665ba2fa520a31.svg" alt="稀土掘金" class="logo-img" data-v-611bc442> <img src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/6c61ae65d1c41ae8221a670fa32d05aa.svg" alt="稀土掘金" class="mobile" data-v-611bc442></a> <!----> <!----> <nav role="navigation" class="main-nav" data-v-611bc442><ul class="nav-list" data-v-611bc442><!----> <li class="main-nav-list" data-v-611bc442><div class="phone-show-menu isResourceVisible" data-v-611bc442><span data-v-611bc442>首页</span> <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg" class="unfold16-icon" data-v-611bc442 data-v-611bc442><path d="M2.45025 4.82431C2.17422 4.49957 2.40501 4.00049 2.83122 4.00049H9.16878C9.59498 4.00049 9.82578 4.49957 9.54975 4.82431L6.38097 8.55229C6.1813 8.78719 5.8187 8.78719 5.61903 8.55229L2.45025 4.82431Z" data-v-611bc442 data-v-611bc442></path></svg></div> <ul class="phone-hide isResourceVisible" data-v-611bc442><li class="nav-item link-item route-active" data-v-611bc442><a href="/" data-v-611bc442>首页</a></li> <li class="nav-item link-item activities" data-v-611bc442><a href="/pins" data-v-611bc442><span class="text" data-v-611bc442>
                  沸点
                  <!----></span></a></li> <li class="nav-item link-item book" data-v-611bc442><a href="/course" data-v-611bc442>
                课程
                <!----></a></li> <li class="nav-item link-item" data-v-611bc442><a href="/live" data-v-611bc442>直播</a></li> <li class="nav-item link-item" data-v-611bc442><a href="/events/all" data-v-611bc442>活动</a></li> <nav class="nav-item link-item" data-v-611bc442><a href="https://detail.youzan.com/show/goods/newest?kdt_id=104340304" target="_blank" rel="nofollow noopener noreferrer" class="nav-item link-item no-border" data-v-611bc442><span data-v-611bc442>商城</span></a> <!----></nav> <nav class="nav-item link-item download-icon isResourceVisible" data-v-611bc442><a href="/app?utm_source=jj_nav" target="_blank" class="download-app no-border" data-v-611bc442>
                APP
              </a> <!----></nav> <nav class="nav-item link-item extension-icon" data-v-611bc442><a href="https://juejin.cn/extension?utm_source=jj_nav" target="_blank" rel="nofollow noopener noreferrer" class="broswer-extension no-border isResourceVisible" data-v-611bc442><span data-v-611bc442>插件</span></a></nav> <li tag="li" class="nav-item link-item" data-v-611bc442><a target="_blank" href="https://juejin.cn/challenge/1?utm_source=web_nav" class="activity no-hover special-activity" data-v-611bc442><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/759e2aa805c0461b840e0f0f09ed05fa~tplv-k3u1fbpfcp-zoom-1.image?" style="max-width: 115px; vertical-align: middle" data-v-611bc442></a></li></ul></li> <ul class="right-side-nav" data-v-611bc442><li class="search-add" data-v-611bc442><ul class="search-add-ul isResourceVisible" data-v-611bc442><li class="nav-item search" data-v-611bc442><form role="search" class="search-form isResourceVisible" data-v-611bc442><input type="search" maxlength="32" placeholder="" value="" class="search-input isResourceVisible" data-v-611bc442> <div class="seach-icon-container" data-v-611bc442><img src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/1e8ab9a22f0ddc36349f60b38900d0bd.svg" alt="搜索" class="search-icon" data-v-611bc442></div> <div class="typehead" style="display:none;" data-v-611bc442><!----> <div class="title" data-v-611bc442><span data-v-611bc442>搜索历史</span> <span class="clear" data-v-611bc442>
                        清空
                      </span></div> <div class="list" data-v-611bc442></div></div></form></li> <li class="nav-item add creator-item" data-v-611bc442><div class="add-group" data-v-3a3133c9 data-v-611bc442><!----> <button class="add-btn" data-v-3a3133c9>
    创作者中心
  </button> <div class="more" data-v-3a3133c9><svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg" class="unfold12-icon" data-v-3a3133c9 data-v-3a3133c9><path d="M2.45025 4.82383C2.17422 4.49908 2.40501 4 2.83122 4H9.16878C9.59499 4 9.82578 4.49908 9.54975 4.82382L6.38097 8.5518C6.1813 8.7867 5.8187 8.7867 5.61903 8.5518L2.45025 4.82383Z" fill="white" data-v-3a3133c9 data-v-3a3133c9></path></svg></div> <ul class="more-list" data-v-3a3133c9><li class="item" data-v-3a3133c9><span class="icon write-article" data-v-3a3133c9>写文章</span></li><li class="item" data-v-3a3133c9><span class="icon issue-points" data-v-3a3133c9>发沸点</span></li><li class="item" data-v-3a3133c9><span class="icon write-note" data-v-3a3133c9>写笔记</span></li><li class="item" data-v-3a3133c9><span class="icon create-jcode" data-v-3a3133c9>写代码</span></li><li class="item" data-v-3a3133c9><span class="icon drafts" data-v-3a3133c9>草稿箱</span></li></ul> <!----> <!----></div></li></ul></li> <!----> <li class="nav-item vip-entry" data-v-611bc442><div class="vip-title" data-v-611bc442><img src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/24127194d5b158d7eaf8f09a256c5d01.svg" alt="vip" class="vip-img" data-v-611bc442> <div class="vip-words" data-v-611bc442>会员</div></div> <div class="vip-content" style="display:none;" data-v-611bc442><img src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/a0ef799e93fdbfcffe8553ecf2beb5ba.svg" alt="doll" class="icon" data-v-611bc442> <div class="content" data-v-611bc442><span data-v-611bc442>掘金会员，新权益到账啦~!</span> <span data-v-611bc442>字节内部课程，VIP免费学习</span></div> <svg width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg" class="close" data-v-611bc442 data-v-611bc442><path d="M14.3029 3.69629L8.99959 8.99957L3.69629 14.3029" stroke="#8A919F" stroke-width="1.5" stroke-linecap="round" data-v-611bc442 data-v-611bc442></path><path d="M3.69629 3.69629L8.99959 8.99957L14.3029 14.3029" stroke="#8A919F" stroke-width="1.5" stroke-linecap="round" data-v-611bc442 data-v-611bc442></path></svg> <img src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/fef2eb8d28949cc43248bad54cb1579a.svg" class="mask" data-v-611bc442></div></li> <!----> <!----> <li class="nav-item auth" data-v-611bc442><div class="login-button-wrap" data-v-611bc442><button class="login-button" data-v-611bc442>
                登录
                <!----></button> <!----></div></li></ul></ul></nav></div> <!----></header></div>  <main class="container main-container" style="max-width:1140px;" data-v-4b9f9746><div class="view column-view" data-v-4b9f9746 data-v-020666e8><div class="main-area article-area" data-v-4b9f9746 data-v-020666e8><article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="6844903953566531597" data-draft-id="6845076477000548365" data-original-type="0" class="article" data-v-020666e8><meta itemprop="url" content="https://juejin.im/post/6844903953566531597"> <meta itemprop="headline" content="HashMap源码解析，扩容机制及其思考"> <meta itemprop="keywords" content="Java"> <meta itemprop="datePublished" content="2019-09-26T08:57:38.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Forgotten在掘金"> <meta itemprop="url" content="https://juejin.cn/user/3227821871208174"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-020666e8>
            HashMap源码解析，扩容机制及其思考
            <!----></h1> <div class="author-info-block" data-v-020666e8><a href="/user/3227821871208174" target="_blank" rel="" class="avatar-link" data-v-020666e8><img loading="eager" src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/mirror-assets/16d667c91bd62c35136~tplv-t2oaga2asx-no-mark:100:100:100:100.awebp" alt="" class="lazy avatar avatar" data-v-248050e4 data-v-47508ed8 data-v-020666e8></a> <div class="author-info-box" data-v-020666e8><div class="author-name" data-v-020666e8><a href="/user/3227821871208174" target="_blank" rel="" class="username username ellipsis" data-v-0ef8bafa data-v-020666e8><span class="name" style="max-width:128px;" data-v-0ef8bafa>
    Forgotten在掘金
  </span> <span blank="true" class="rank" data-v-3de16c56 data-v-0ef8bafa><img src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/lv-2.99ba5b2.png" alt="lv-2" title="创作等级" data-v-3de16c56></span> <!----> <!----> </a> <!----></div> <div class="meta-box" data-v-020666e8><time datetime="2019-09-26T08:57:38.000Z" title="Thu Sep 26 2019 16:57:38 GMT+0800 (China Standard Time)" class="time" data-v-020666e8>
                    2019年09月26日 16:57
                  </time> <span class="views-count" data-v-020666e8>
                    ·  阅读 2349
                  </span> <!----></div> <!----></div> <button class="follow-button follow" data-v-565dd611 data-v-020666e8><span class="icon icon-follow" data-v-565dd611></span> <span data-text="取消关注" class="text" data-v-565dd611>关注</span></button></div> <!----> <!----> <!----> <div itemprop="articleBody" class="article-content" data-v-020666e8><div class="markdown-body cache html"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#333}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;margin-bottom:5px}.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{font-size:20px}.markdown-body h2{padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><h1 data-id="heading-0">1.概述</h1><blockquote><p>HashMap是日常java开发中常用的类之一，是java设计中非常经典的一个类，它巧妙的设计思想与实现，还有涉及到的数据结构和算法，，值得我们去深入的学习。</p></blockquote><blockquote><p>简单来说，HashMap就是一个散列表，是基于哈希表的Map接口实现，它存储的内容是键值对 (key-value) 映射，并且键值允许为null(键的话只允许一个为null)。</p></blockquote><h3 data-id="heading-1">1.1 注意事项</h3><blockquote><p>①根据键的hashCode存储数据。(String，和Integer、Long、Double这样的包装类都重写了hashCode方法，String比较特殊根据ascil码还有自己的算法计算，Double做位移运算【具体看源码的hashcode实现】，Integer，Long包装类则是自身大小int值)，<br>HashMap中的结构不能有基本类型，一方面是基本类型没有hashCode方法，还有HashMap是泛型结构，泛型要求包容对象类型，而基本类型在java中不属于对象。<br>②HashMap的存储单位是Node&#x3C;k,v>,可以认作为节点。<br>③Hashmap中的扩容的个数是针对size(内部元素(节点)总个数)，而不是数组的个数。比如说初始容量为16，第十三个节点put进来，不管前面十二个占的数组位置如何，就开始扩容。</p></blockquote><h3 data-id="heading-2">1.2 hashmap几个特征</h3><table><thead><tr><th>特征</th><th>说明</th></tr></thead><tbody><tr><td>是否允许重复数据</td><td>key如果重复会覆盖，value允许重复</td></tr><tr><td>hashMap是否有序</td><td>无序，这里的无序指的是遍历HashMap的时候，得到的顺序大都跟put进去的顺序不一致</td></tr><tr><td>hashMap是否线程安全</td><td>非线程安全，因为里面的实现不是同步的，如果想要线程安全，推荐使用</td></tr><tr><td>键值是否允许为空</td><td>key和value都允许为空，但只允许一个为空</td></tr></tbody></table><h1 data-id="heading-3">2.一些概念</h1><h3 data-id="heading-4">2.1.位运算</h3><p>位运算是对整数在内存中的二进制位进行操作。</p><p>在java中 >> 表示右移 若该数为正，则高位补0，若为负数，高位补1</p><p>&#x3C;&#x3C;表示左移 跟右移相反 如果是正数在低位补0</p><p>例如20的二进制为0001 0100 20>>2为 0101 0000 结果为5(左高右低)</p><p>20&#x3C;&#x3C;2 为 0101 0000 则为80</p><p><b>java中>>>和>>的区别</b></p><pre><code lang="shell" class="hljs language-shell copyable"><span class="hljs-meta prompt_">></span><span class="bash">>>表示无符号右移，也叫逻辑右移。不管数字是正数还是负数，高位都是补0</span>
<span class="copy-code-btn">复制代码</span></code></pre><p>在hashMap源码中有很多使用位运算的地方。例如:</p><pre><code lang="arduino" class="hljs language-arduino copyable"><span class="hljs-comment">//之所以用1 &#x3C;&#x3C; 4不直接用16，0000 0001 -> 0001 0000 则为16，如果用16的话最后其实也是要转换成0和1这样的二进制，位运算的计算在计算机中是非常快的，直接用位运算表示大小以二进制形式去运行，在jvm中效率更高。</span>
<span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &#x3C;&#x3C; <span class="hljs-number">4</span>;  <span class="hljs-comment">//初始化容量</span>
<span class="copy-code-btn">复制代码</span></code></pre><p><b>注意:左移没有&#x3C;&#x3C;&#x3C;运算符</b></p><div></div><h3 data-id="heading-5">2.2 位运算符-(与(&#x26;)、非(~)、,或(|)、异或(^))</h3><h5 data-id="heading-6">①与运算(&#x26;)</h5><p>我们都知道&#x26;在java中表示与操作&#x26;表示按位与，这里的位是指二进制位。都为1才为真(1),否则结果为0，举个简单的例子</p><pre><code lang="csharp" class="hljs language-csharp copyable">System.<span class="hljs-keyword">out</span>.println(<span class="hljs-number">9</span> &#x26; <span class="hljs-number">8</span>); <span class="hljs-comment">//1&#x26;1=1，1&#x26;0 0&#x26;1 0&#x26;0都=0，因此1001 1000 -> 1000 输出为8</span>
<span class="copy-code-btn">复制代码</span></code></pre><h5 data-id="heading-7">②非运算(~)</h5><p><b>源码 -> 取反 -> 反码 -> 加1 -> 补码 -> 取反 -> 按位非值</b></p><p>在Java中，所有数据的表示方法都是以补码的形式表示，如果没有特殊说明，Java中的数据类型默认是int,int数据类型的长度是8位，一位是四个字节，就是32字节，32bit.</p><p>例如5的二进制为0101</p><p>补码后为 00000000 00000000 00000000 00000101</p><p>取反后为 11111111 11111111 11111111 11111010</p><p>【因为高位为1 所以源码为负数，负数的补码是其绝对值源码取反，末尾再加1】</p><p>所以反着来末尾减1得到反码然后再取负数</p><p>末位减1：11111111 11111111 11111111 11111001</p><p>【后八位前面4位不动 后面 减1 1010减1 相当于 10-1为9 后四位就是 1001 】</p><p>取反后再负数： 00000000 00000000 00000000 00000110 为-6</p><pre><code lang="csharp" class="hljs language-csharp copyable">System.<span class="hljs-keyword">out</span>.println(~ <span class="hljs-number">5</span>); <span class="hljs-comment">//输出-6</span>
<span class="copy-code-btn">复制代码</span></code></pre><h5 data-id="heading-8">③或运算(|)</h5><p><b>只要有一个为1，结果为1，否则都为0</b></p><pre><code lang="csharp" class="hljs language-csharp copyable">System.<span class="hljs-keyword">out</span>.println(<span class="hljs-number">5</span> | <span class="hljs-number">15</span>); <span class="hljs-comment">//输出为15，0101或上1111,结果为1111</span>
<span class="copy-code-btn">复制代码</span></code></pre><h5 data-id="heading-9">④异或运算(^)</h5><p><b>相同为0(假)，不同为真(1)</b></p><pre><code lang="csharp" class="hljs language-csharp copyable">System.<span class="hljs-keyword">out</span>.println(<span class="hljs-number">5</span> ^ <span class="hljs-number">15</span>); <span class="hljs-comment">//输出10 0101异或1111结果为1010</span>
<span class="copy-code-btn">复制代码</span></code></pre><div></div><h3 data-id="heading-10">2.3 hashcode</h3><p>hash意为散列，hashcode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值，顶级父类Object类中含hashCode方法(native本地方法，是根据地址来计算值)，有一些类会重写该方法，比如String类。</p><p>重写的原因。为了保证一致性，如果对象的equals方法被重写，那么对象的hashcode()也尽量重写。</p><p>简单来说 就是hashcode()和equals()需保持一致性，如果equals方法返回true，那么两个对象的hashCode 返回也必须一样。</p><p>否则可能会出现这种情况。</p><p>假设一个类重写了equals方法，其相等条件为属性相等就返回true，如果不重写hashcode方法，那么依据就是Object的依据比较两个对象内存地址，则必然不相等，这就出现了equals方法相等但是hashcode不等的情况，这不符合hashcode的规则，这种情况可能会导致一系列的问题。</p><p><b>因此，在hashMap中，key如果使用了自定义的类，最好要合理的重写Object类的equals和hashcode方法。</b></p><div></div><h3 data-id="heading-11">2.4 哈希桶</h3><p>哈希桶的概念比较模糊，个人理解是数组表中一块区域结果下面的单向链表组成的，在hashmap中，这个单向链表的头部是所在数组上第一个元素，单向链表如果过长超过8，那么这个"桶"就可能变成了红黑树(前提是数组长度达到64）。</p><div></div><h3 data-id="heading-12">2.5 hash函数</h3><p>在程序设定中，把一个对象通过某种算法或者说转换机制对应到一个整形。</p><p>主要用于解决冲突的。</p><div></div><h3 data-id="heading-13">2.6 哈希表</h3><p>也称为散列表，这也是一种数据结构，可以根据对象产生一个为整数的散列码(hashCode)。</p><h4 data-id="heading-14"></h4><h3 data-id="heading-15">hash冲突</h3><p>HashMap之所以有那么快的查询速度，是因为他的底层是由数组实现，通过key计算散列码(hashCode)决定存储的位置，HashMap中通过key的hashCode来计算hash值，只要hashCode相同，hash值也一样，但是可能存在存的对象多了，不同对象计算出的hash值相同，这就是hash冲突。</p><p><b>举个例子</b></p><pre><code lang="arduino" class="hljs language-arduino copyable">HashMap&#x3C;<span class="hljs-type">String</span>,<span class="hljs-type">String</span>> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HashMap</span>&#x3C;<span class="hljs-type">String</span>,<span class="hljs-type">String</span>>();
map.<span class="hljs-built_in">put</span>(<span class="hljs-string">"Aa"</span>, <span class="hljs-string">"haha"</span>);
map.<span class="hljs-built_in">put</span>(<span class="hljs-string">"BB"</span>,<span class="hljs-string">"heihei"</span>);
System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"Aa"</span>.<span class="hljs-built_in">hashCode</span>()); <span class="hljs-comment">//2112</span>
System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"BB"</span>.<span class="hljs-built_in">hashCode</span>()); <span class="hljs-comment">//2112</span>
<span class="hljs-comment">//这里的Aa和BB为String型，String类重写了hashCode方法(根据ascil码和特定的算法来计算，虽然很巧妙但也难以避免不对对象hashCode相同的情况)，Aa和BB的hashCode值相同，相同的HashCode的hash值相同 </span>
<span class="hljs-comment">//根据源码就算key不相同 但key.hashCode()相同 则会返回相同的hash，导致hash冲突</span>
<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>{<span class="hljs-comment">//取关键key的hash值</span>
    <span class="hljs-type">int</span> h;
    <span class="hljs-keyword">return</span> (key == null) ? <span class="hljs-number">0</span> : (h = key.<span class="hljs-built_in">hashCode</span>()) ^ (h >>> <span class="hljs-number">16</span>);<span class="hljs-comment">//任何小于2的16次方的数 右移16位都为0 2的16次方>>>16刚好为1 任何一个数和0按位异或都为这个数本身(1和0为1 0和0为0)，所以这个hash()函数对于null的hash值 仅在hashcode大于2的16次方才会调整值,这边16设计的很巧妙，因为int刚好是32位的取中间位数</span>
}
<span class="copy-code-btn">复制代码</span></code></pre><h3 data-id="heading-16">2.7 二叉查找树和红黑树</h3><p>红黑树是一种自平衡二叉查找树。是一种数据结构，又称二叉b树，（→_→ 2b树？），红黑树本质上也是二叉查找树。所以先理解下二叉查找树。</p><h4 data-id="heading-17">2.7.1二叉查找树</h4><pre><code lang="bash" class="hljs copyable">二叉查找树，又称有序二叉树，已排序二叉树
它的三大特点如下
1.左子树上所有结点的值均小于或等于它的根结点的值。
2.右子树上所有结点的值均大于或等于它的根结点的值。
3.左、右子树也分别为二叉排序树。
<span class="copy-code-btn">复制代码</span></code></pre><div><div><div></div><div><img alt="img_15bc610b523331178a92ad63dcfac5f8.png" src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/26/16d6cc9bf1be2e12~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" loading="lazy"></div></div><div>二叉树.png</div></div><h4 data-id="heading-18">2.7.2 红黑树(RBTree)</h4><pre><code lang="scss" class="hljs language-scss copyable">由于二叉查找树可能存在难以平衡呈线性的缺陷，所以出现的红黑树的概念。顾名思义，红黑树是只有红色和黑色节点的二叉树。
它的<span class="hljs-number">5</span>大性质如下。
<span class="hljs-number">1</span>.节点是红色或黑色。
<span class="hljs-number">2</span>.根节点是黑色。
<span class="hljs-number">3</span>.每个叶子节点都是黑色的空节点（NIL节点）。
<span class="hljs-number">4</span> 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
<span class="hljs-number">5</span>.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
<span class="copy-code-btn">复制代码</span></code></pre><p>简单来说红黑树是一种自平衡二叉查找树，相比于普通的二叉查找树，它的数据结构更为复杂，但是在复杂的情况也能通过自平衡(变色，左右旋转)保持良好的性能。</p><p>关于红黑树，很形象的一组漫画，查看<a href="https://link.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Fgo%2FarticleRenderRedirect%3Furl%3Dhttps%253A%252F%252Fmp.weixin.qq.com%252Fs%253F__biz%253DMzIxMjE5MTE1Nw%253D%253D%2526amp%253Bmid%253D2653191832%2526amp%253Bidx%253D1%2526amp%253Bsn%253D12017161025495c6914b5ab9397baa59%2526amp%253Bchksm%253D8c990c42bbee8554ba02eb83d839123bd3bead6ffc736111456ea77367a3df75750cf88016e0%2526amp%253Bscene%253D21%2523wechat_redirect" target="_blank" title="https://yq.aliyun.com/go/articleRenderRedirect?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzIxMjE5MTE1Nw%3D%3D%26amp%3Bmid%3D2653191832%26amp%3Bidx%3D1%26amp%3Bsn%3D12017161025495c6914b5ab9397baa59%26amp%3Bchksm%3D8c990c42bbee8554ba02eb83d839123bd3bead6ffc736111456ea77367a3df75750cf88016e0%26amp%3Bscene%3D21%23wechat_redirect" ref="nofollow noopener noreferrer">这里</a></p><p>在线模拟红黑树增删的地址<a href="https://link.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Fgo%2FarticleRenderRedirect%3Furl%3Dhttps%253A%252F%252Fwww.cs.usfca.edu%252F%257Egalles%252Fvisualization%252FRedBlack.html" target="_blank" title="https://yq.aliyun.com/go/articleRenderRedirect?url=https%3A%2F%2Fwww.cs.usfca.edu%2F%7Egalles%2Fvisualization%2FRedBlack.html" ref="nofollow noopener noreferrer">地址1</a>、 <a href="https://link.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Fgo%2FarticleRenderRedirect%3Furl%3Dhttps%253A%252F%252Fsandbox.runjs.cn%252Fshow%252F2nngvn8w" target="_blank" title="https://yq.aliyun.com/go/articleRenderRedirect?url=https%3A%2F%2Fsandbox.runjs.cn%2Fshow%2F2nngvn8w" ref="nofollow noopener noreferrer">地址2</a></p><p><b>红黑树的时间复杂度为【吐槽下简书这边如果用数学公式太蛋疼了】：</b></p><blockquote><p>O(logn)</p></blockquote><p></p><div><div>它的高度为:[logN,logN+1]（理论上，极端的情况下可以出现RBTree的高度达到2</div>logN，但实际上很难遇到）。</div>*<p></p><p>此外，由于它的设计任何不平衡将在三次旋转内解决。</p><pre><code lang="scss" class="hljs language-scss copyable">红黑树和avl树(最早的自平衡二叉树)的比较：
avl更加平衡，查询速率稍强于红黑树，但是插入和删除红黑树完爆avl树，可能由于hashMap的增删也挺频繁的，所以综合考虑而选择红黑树。
<span class="copy-code-btn">复制代码</span></code></pre><p><b>总结：红黑树是种可以通过变色旋转的自平衡二叉查找树，对于hashMap来说，使用红黑树的好处在于，当有多个元素hash相同在同一数组下标的时候，使用红黑树在查找这些hash冲突的元素更快，它的时间复杂度从遍历链表O(n)降到O(logN)。</b></p><h3 data-id="heading-19">2.8 复杂度</h3><p>算法复杂度分时间复杂度和空间复杂度。</p><pre><code lang="bash" class="hljs copyable">时间复杂度：执行算法所需要的计算工作量
空间复杂度：执行算法所需要内存空间大小
时间和空间都是计算机资源的体现，算法的复杂性体现在运行该算法时计算机所需资源的大小。
<span class="copy-code-btn">复制代码</span></code></pre><p><b>这里重点讲下时间复杂度</b></p><pre><code lang="scss" class="hljs language-scss copyable">(<span class="hljs-number">1</span>)时间频度
用<span class="hljs-built_in">T</span>(n)表示
一个算法执行所消耗的时间，理论上不能算出来而是通过运行测试得知，但不可能也没必要对每个算法都做上机测试，只需知道哪个算法花费时间多哪个花费少即可。在算法中一个算法花费的时间和这个算法执行的次数成正比。
在一个算法中，语句执行次数称为时间频度(或称为语句频度)，记做为<span class="hljs-built_in">T</span>(n)，这里的n代表问题的规模。暂且不考虑这个T是啥，把它理解为一个函数。
(<span class="hljs-number">2</span>)时间复杂度 
用Ｏ(f(n))表示
当n变化时，时间频度<span class="hljs-built_in">T</span>(n)也会不断变化，但是它是个不确定的函数，我们想知道它呈现的规律是什么样的。这个时候引入了时间复杂度的概念。
前面说<span class="hljs-built_in">T</span>(n)是个不确定的函数，它代表算法中基本操作重复执行的次数是问题规模n的某个函数。
假设有某个辅助函数<span class="hljs-built_in">f</span>(n),当n趋近∞，<span class="hljs-built_in">T</span>(n)/<span class="hljs-built_in">f</span>(n)的极限值不为<span class="hljs-number">0</span>切位常数，那么可以认为<span class="hljs-built_in">f</span>(n)和<span class="hljs-built_in">T</span>(n)为同一数量级的函数，记做为<span class="hljs-built_in">T</span>(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。

<span class="hljs-built_in">f</span>(n)虽然没有规定但一般都尽可能取简单的函数
例如 <span class="hljs-built_in">O</span>(<span class="hljs-number">2</span>n²+n +<span class="hljs-number">1</span>) = O (<span class="hljs-number">3</span>n²+n+<span class="hljs-number">3</span>) = O (<span class="hljs-number">7</span>n² + n) = O ( n² ) 省去了系数,只保留最高阶项。
时间频度不同时，时间复杂度有可能相同，例如<span class="hljs-built_in">T</span>(n)=n²+<span class="hljs-number">3</span>n+<span class="hljs-number">4</span>与<span class="hljs-built_in">T</span>(n)=<span class="hljs-number">4</span>n²+<span class="hljs-number">2</span>n+<span class="hljs-number">1</span>它们的频度不同，但时间复杂度相同，都为<span class="hljs-built_in">O</span>(n²)。

总结两者关系:时间复杂度就是对时间频度函数的一层包装，它的特点(大O表示法)为
①省去系数为<span class="hljs-number">1</span>处理②保留最高项
如果把T(n)当做为一棵树，那么O(f(n))只关心其主干部分。
<span class="copy-code-btn">复制代码</span></code></pre><p><b>常见算法的时间复杂度从小到大依次为</b><br></p><div><div><div></div><div><img alt="img_8f75b001aae9edc9b86bb1e9fc7c7f6d.png" src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/26/16d6cc9bed0cf8cc~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" loading="lazy"></div></div><div>复杂度比较</div></div><p></p><pre><code lang="bash" class="hljs copyable">求解算法的时间复杂度具体步骤为：
①找出算法中执行次数最多的基本语句，一般是最内层的循环体。
②计算基本语句的数量级
③将基本语句执行次数的数量级放入大O记号中
<span class="copy-code-btn">复制代码</span></code></pre><p><b>举几个例子</b></p><p><b>O(1),又称常数阶，一般来说算法中没有循环体，执行次数为常数那么时间复杂度就为O(1)，例如</b></p><pre><code lang="ini" class="hljs language-ini copyable">int <span class="hljs-attr">sum</span> = <span class="hljs-number">0</span>,n = <span class="hljs-number">100</span><span class="hljs-comment">; //执行一次  </span>
<span class="hljs-attr">sum</span> = (<span class="hljs-number">1</span>+n)*n/<span class="hljs-number">2</span><span class="hljs-comment">; //执行一次  </span>
System.out.println (sum)<span class="hljs-comment">; //执行一次 </span>
//上面的算法运行次数为f(n)=3,那么根据大O表示法，该算法的时间复杂度为O(1)
<span class="copy-code-btn">复制代码</span></code></pre><h5 data-id="heading-20"></h5><p><b>为什么O(logN)，对数阶不用底数</b></p><p><b>如红黑树的查找复杂为O(logN)</b></p><p><b>这里面有个可能存在的疑问，有时候时间复杂度都用包含O(logN)这样的描述 但是没有明确说明n的底数是多少，通常底数为2来计算</b></p><p>这种描述其实也是合理的，算法中log级别的时间复杂度都是由于使用了分治思想,这个底数直接由分治的复杂度决定。当n趋近于无穷大，两个大小比较也只是一个常数，所以这种时候O(logN)统一代表对数复杂度。<br>\lim_{n\rightarrow+\infty} Ο(\log_x{n})/Ο(\log_y{n}) = C</p><p><b>其它简单举例</b></p><table><thead><tr><th>描述</th><th>增长数量级</th><th>典型代码</th><th>说明</th></tr></thead><tbody><tr><td>常数阶</td><td>1</td><td>a = b + c</td><td>普通简单算法操作</td></tr><tr><td>对数阶</td><td>logN</td><td>二叉树中的二分法</td><td>二分策略</td></tr><tr><td>线性级别</td><td>N</td><td>for(int i = 0;i &#x3C; 10; i++) {...}</td><td>普通单层循环算法</td></tr><tr><td>平方级别</td><td>N²</td><td>for(int i = 0;i &#x3C; 10; i++) {for(int j = 0; j &#x3C; 10) {...}}</td><td>双层循环，例如冒泡排序</td></tr><tr><td>指数级别</td><td>2的n次方</td><td>一个背包大小一定时，找出不大于背包所有物品组合，假设有3个物品，a，b，c，可能的组合有8种。(a,b,c,ab,ac,bc,abc+空(背包太小一个都容纳不下))</td><td>穷举查找(背包问题<a href="https://link.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Fgo%2FarticleRenderRedirect%3Furl%3Dhttps%253A%252F%252Fwww.cnblogs.com%252Ftinaluo%252Fp%252F5264190.html" target="_blank" title="https://yq.aliyun.com/go/articleRenderRedirect?url=https%3A%2F%2Fwww.cnblogs.com%2Ftinaluo%2Fp%2F5264190.html" ref="nofollow noopener noreferrer">www.cnblogs.com/tinaluo/p/5…</a>)</td></tr></tbody></table><div></div><h1 data-id="heading-21">3. HashMap的内部实现(基于jdk1.8)</h1><blockquote><p>刚开始看hashMap源码的时候，感觉思路很乱不知道写的啥东西，所以还是得从它的【数据结构】开始入手。</p></blockquote><div><div><div></div><div><img alt="img_550edf98975a3d557599d6792129fba5.jpe" src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/26/16d6cc9bef779b0b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" loading="lazy"></div></div><div></div></div><pre><code lang="ini" class="hljs language-ini copyable">不同于一般类的数据结构，从结构来讲 <span class="hljs-attr">HashMap</span> = 数组 + 链表 + 红黑树(<span class="hljs-number">1.8</span>开始加入，大程度的优化了HashMap的性能)
arrayList  数组
linkedList 双向链表 查询效率慢，需通过遍历，新增或删除快，比如说删除一个元素 知道那个元素的上下引用 并改变关联上下元素的引用指向即可。
<span class="copy-code-btn">复制代码</span></code></pre><h3 data-id="heading-22">3.1 数组和链表</h3><div><div><div></div><div><img alt="img_fdee83a22ddec90d5d4b5779804d0cd8.png" src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/26/16d6cc9beec7d8de~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" loading="lazy"></div></div><div>数组和链表.png</div></div><h3 data-id="heading-23">3.2 HashMap数据结构(数组+链表+红黑树)</h3><blockquote><p>在jdk8以前，如果发生频繁碰撞的话，查找时间复杂度是O(1) + O(n) (先找在数组的位置再找链表)，n如果比较大则严重影响了查找性能，而到了jdk8引入红黑树,O(1) + O(logN)。</p></blockquote><div><div><div></div><div><img alt="img_97ec833243a8d841f179b1fd3d54c982.png" src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/26/16d6cc9bf47291f9~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" loading="lazy"></div></div><div>hashmap.png</div></div><h2 data-id="heading-24">大致思路</h2><pre><code lang="arduino" class="hljs language-arduino copyable">①数组的优点是查询快，链表的优点是增删快，红黑树查询性能较好，hashMap的存储方式结合了它们的优点，那么hashMap的存储单元又可以在数组里，又可以在某个数组下的链表里。还有可能在红黑树当中。
②我们已经知道HashMap是键值对的存在，且可以为各种类型，那么它又是以键值对的方式存在，它的最小存储单位是以Node节点为存储单位。
这个Node结构大概有Key，Value，记录所在数组索引，以及记录链表指针的东西。
大概结构如下
<span class="hljs-type">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#x3C;K,V> implements Map.Entry&#x3C;K,V> {
  <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;
  <span class="hljs-keyword">final</span> K key;
  V value;
  Node&#x3C;K,V> next;
  ...
}

③新来的Node节点怎么放?
HashMap利用hashcode来确定存放的位置，但是又有个疑问，假设map对象key为<span class="hljs-type">String</span>型
HashMap&#x3C;<span class="hljs-type">String</span>, <span class="hljs-type">String</span>> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HashMap</span>&#x3C;<span class="hljs-type">String</span>, <span class="hljs-type">String</span>>();
map.<span class="hljs-built_in">put</span>(<span class="hljs-string">"1"</span>, <span class="hljs-string">"first"</span>);

<span class="hljs-comment">//这个时候看put方法 </span>
put方法的大致思路为
①对key做hash运算，通过hash值计算index下标位置
②如果没冲突直接放在桶上
③如果冲突了，以链表的形式存在桶里面，达到一定条件链表变为红黑树
④如果节点已经存在，则替换旧的<span class="hljs-built_in">value</span>(保证唯一性)
⑤如果桶的个数超过了 加载因子乘当前容量，则做resize操作

<span class="hljs-comment">//可以注意到有个hash函数</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>{
   <span class="hljs-keyword">return</span> <span class="hljs-built_in">putVal</span>(<span class="hljs-built_in">hash</span>(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);
}

<span class="hljs-comment">//hash函数 </span>
<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>{
   <span class="hljs-type">int</span> h;
   <span class="hljs-keyword">return</span> (key == null) ? <span class="hljs-number">0</span> : (h = key.<span class="hljs-built_in">hashCode</span>()) ^ (h >>> <span class="hljs-number">16</span>);
}

<span class="hljs-comment">//上述代码String类型的1的Hashcode为49超过了HashMap的初始长度16，这个时候"1"这个key放在哪。这里</span>
<span class="hljs-comment">//通过巧妙的设计存放在合适的位置 4.3.3做分析</span>
p = tab[i = (n - <span class="hljs-number">1</span>) &#x26; hash]，


<span class="hljs-comment">//这里的p为Node&#x3C;K,V>对象，n为当前哈希桶数组长度，进行与运算后，因为这是第一个插入的元素，无需扩容长度为16,那么49 &#x26; 15 = 1，说明在的第二个位置。</span>

④新节点插入后什么时候开始扩容
接下来不断的插入的元素 经过hash函数和计算索引位置后，都可以根据它的散列性插入到不同的<span class="hljs-number">16</span>个位置，
当元素个数达到<span class="hljs-number">16</span> * <span class="hljs-number">0.75</span> 即<span class="hljs-number">12</span>时，继续插入新的时候，开始扩容。
【这里注意一下并不是说占满<span class="hljs-number">12</span>个位置才开始扩容，而是<span class="hljs-number">12</span>个节点，根据散列性分布<span class="hljs-number">12</span>个节点，占..<span class="hljs-number">.5</span>，<span class="hljs-number">6</span>，<span class="hljs-number">7</span>，<span class="hljs-number">8.</span>..个位置都有可能,比如说key为Integer类型，假如key为Integer类型，有五个节点key分别为<span class="hljs-number">3</span>，<span class="hljs-number">19</span>，<span class="hljs-number">12</span>，<span class="hljs-number">28</span>，<span class="hljs-number">44</span>这个时候<span class="hljs-number">3</span>，<span class="hljs-number">19</span>在同一个位置，<span class="hljs-number">12</span>，<span class="hljs-number">28</span>，<span class="hljs-number">44</span>在同一个位置，这个时候<span class="hljs-number">5</span>个节点就占了两个位置】


⑤<span class="hljs-built_in">resize</span>()方法进行扩容操作。
<span class="hljs-number">1.</span>先判断节点数组是否为空，并取它的容量(节点个数)，创建新数组，大小时新的capacity
如果不为空：
如果容量超过最大值不做扩容，否则位运算一位做容量乘<span class="hljs-number">2</span>处理，
如果为空：
桶数组容量为默认容量<span class="hljs-number">16</span>，即有默认放<span class="hljs-number">16</span>个桶，阈值默认为默认容量乘默认加载因子 <span class="hljs-number">12</span>
<span class="hljs-number">2.</span>将旧数组的元素放到新数组中，重新做映射
如果旧的数组不为空，则遍历桶数组，并将键值对映射到新的桶数组中[树节点和链表节点做不同操作]
<span class="copy-code-btn">复制代码</span></code></pre><h1 data-id="heading-25">4.源码分析</h1><h3 data-id="heading-26">4.1 基本存储单位Node节点</h3><pre><code lang="typescript" class="hljs language-typescript copyable"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#x3C;K,V> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.<span class="hljs-property">Entry</span>&#x3C;K,V> { <span class="hljs-comment">//实现Entry接口 存储的是键值对的映射</span>
    final int hash; <span class="hljs-comment">//hash值，用于记录数组所在位置</span>
    final K key; <span class="hljs-comment">//用于匹配</span>
    V value; <span class="hljs-comment">//值</span>
    <span class="hljs-title class_">Node</span>&#x3C;K,V> next; <span class="hljs-comment">//用于记录单链表下一节点 用于解决hash冲突(即hash值一样该存在哪里的问题)</span>
    <span class="hljs-title class_">Node</span>(int hash, K key, V value, <span class="hljs-title class_">Node</span>&#x3C;K,V> next) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">hash</span> = hash;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next;
    }
    <span class="hljs-keyword">public</span> final K <span class="hljs-title function_">getKey</span>(<span class="hljs-params"></span>)        { <span class="hljs-keyword">return</span> key; }
    <span class="hljs-keyword">public</span> final V <span class="hljs-title function_">getValue</span>(<span class="hljs-params"></span>)      { <span class="hljs-keyword">return</span> value; }
    <span class="hljs-keyword">public</span> final <span class="hljs-title class_">String</span> <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> key + <span class="hljs-string">"="</span> + value; }
    <span class="hljs-keyword">public</span> final int <span class="hljs-title function_">hashCode</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Objects</span>.<span class="hljs-title function_">hashCode</span>(key) ^ <span class="hljs-title class_">Objects</span>.<span class="hljs-title function_">hashCode</span>(value);
    }
    <span class="hljs-keyword">public</span> final V <span class="hljs-title function_">setValue</span>(<span class="hljs-params">V newValue</span>) {<span class="hljs-comment">//赋值</span>
        V oldValue = value;
        value = newValue;
        <span class="hljs-keyword">return</span> oldValue;
    }
    <span class="hljs-keyword">public</span> final <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">equals</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> o</span>) {
        <span class="hljs-keyword">if</span> (o == <span class="hljs-variable language_">this</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Map</span>.<span class="hljs-property">Entry</span>) {
            <span class="hljs-title class_">Map</span>.<span class="hljs-property">Entry</span>&#x3C;?,?> e = (<span class="hljs-title class_">Map</span>.<span class="hljs-property">Entry</span>&#x3C;?,?>)o;
            <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Objects</span>.<span class="hljs-title function_">equals</span>(key, e.<span class="hljs-title function_">getKey</span>()) &#x26;&#x26;
                <span class="hljs-title class_">Objects</span>.<span class="hljs-title function_">equals</span>(value, e.<span class="hljs-title function_">getValue</span>()))
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
}
<span class="copy-code-btn">复制代码</span></code></pre><h3 data-id="heading-27">4.2 HashMap中的几个重要实现：hash函数，put、get、resize</h3><pre><code lang="typescript" class="hljs language-typescript copyable"><span class="hljs-comment">//put</span>
<span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span>(<span class="hljs-params">K key, V value</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">putVal</span>(<span class="hljs-title function_">hash</span>(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);
}
<span class="copy-code-btn">复制代码</span></code></pre><pre><code lang="ini" class="hljs language-ini copyable">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    //哈希表数组节点 
    Node&#x3C;K,V><span class="hljs-section">[]</span> tab<span class="hljs-comment">; Node&#x3C;K,V> p; int n, i;</span>
    //如果为空 调用resize以默认大小16扩容 
    if ((<span class="hljs-attr">tab</span> = table) == null || (n = tab.length) == <span class="hljs-number">0</span>)
        <span class="hljs-attr">n</span> = (tab = resize()).length<span class="hljs-comment">;</span>
    //通过(n - 1) &#x26; hash计算存放索引位置 此处设计很巧妙
    if ((<span class="hljs-attr">p</span> = tab[i = (n - <span class="hljs-number">1</span>) &#x26; hash]) == null)
      //如果tab<span class="hljs-section">[i]</span>为空 该下标下没有节点 则直接新建一个Node放在该位置 
        tab<span class="hljs-section">[i]</span> = newNode(hash, key, value, null)<span class="hljs-comment">;</span>
    else {
        //下标上有节点 说明有hash冲突
        Node&#x3C;K,V> e<span class="hljs-comment">; K k;</span>
        //如果插入的新节点key已经存在，那么直接覆盖整个节点
        if (<span class="hljs-attr">p.hash</span> == hash &#x26;&#x26;
            ((<span class="hljs-attr">k</span> = p.key) == key || (key != null &#x26;&#x26; key.equals(k))))
            <span class="hljs-attr">e</span> = p<span class="hljs-comment">;</span>
        //如果为红黑树节点
        else if (p instanceof TreeNode)
            //调用红黑树插入键值对的putTreeVal方法
            <span class="hljs-attr">e</span> = ((TreeNode&#x3C;K,V>)p).putTreeVal(this, tab, hash, key, value)<span class="hljs-comment">;</span>
        else {
            //不管tab<span class="hljs-section">[index]</span>是否为空，p节点已经为 tab<span class="hljs-section">[index]</span>上
            //如果有冲突 且不为红黑树节点 那么此时遍历链表节点 binCount计算链表长度
            for (int <span class="hljs-attr">binCount</span> = <span class="hljs-number">0</span><span class="hljs-comment">; ; ++binCount) {</span>
                if ((<span class="hljs-attr">e</span> = p.next) == null) {
                    <span class="hljs-attr">p.next</span> = newNode(hash, key, value, null)<span class="hljs-comment">;</span>
                   //链表长度大于等于7，调用treeifyBin对链表进行树化
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash)<span class="hljs-comment">;</span>
                    break<span class="hljs-comment">;</span>
                }
                //遍历链表时发现重复 覆盖并跳出循环
                if (<span class="hljs-attr">e.hash</span> == hash &#x26;&#x26;
                    ((<span class="hljs-attr">k</span> = e.key) == key || (key != null &#x26;&#x26; key.equals(k))))
                    break<span class="hljs-comment">;</span>
                <span class="hljs-attr">p</span> = e<span class="hljs-comment">;</span>
            }
        }
        if (e != null) { // existing mapping for key
            V <span class="hljs-attr">oldValue</span> = e.value<span class="hljs-comment">;</span>
            if (!onlyIfAbsent || <span class="hljs-attr">oldValue</span> == null)
                <span class="hljs-attr">e.value</span> = value<span class="hljs-comment">;</span>
            afterNodeAccess(e)<span class="hljs-comment">;</span>
            return oldValue<span class="hljs-comment">;</span>
        }
    }
    ++modCount<span class="hljs-comment">;</span>
    //插入成功后 再根据实际判断是否到到阈值 比如说现在容量16(桶的个数16) 正在插第13个元素时 到达则扩容 
    if (++size > threshold)
        resize()<span class="hljs-comment">;</span>
    afterNodeInsertion(evict)<span class="hljs-comment">;</span>
    return null<span class="hljs-comment">;</span>
}
<span class="copy-code-btn">复制代码</span></code></pre><h3 data-id="heading-28">get方法</h3><pre><code lang="ini" class="hljs language-ini copyable">public V get(Object key) {
    Node&#x3C;K,V> e<span class="hljs-comment">;</span>
    return (<span class="hljs-attr">e</span> = getNode(hash(key), key)) == null ? null : e.value<span class="hljs-comment">;</span>
}

final Node&#x3C;K,V> getNode(int hash, Object key) {
    Node&#x3C;K,V><span class="hljs-section">[]</span> tab<span class="hljs-comment">; Node&#x3C;K,V> first, e; int n; K k;</span>
    //先定位键值对在所在桶的位置
    if ((<span class="hljs-attr">tab</span> = table) != null &#x26;&#x26; (n = tab.length) > <span class="hljs-number">0</span> &#x26;&#x26;
        (<span class="hljs-attr">first</span> = tab[(n - <span class="hljs-number">1</span>) &#x26; hash]) != null) {
        if (<span class="hljs-attr">first.hash</span> == hash &#x26;&#x26; // always check first node 
            ((<span class="hljs-attr">k</span> = first.key) == key || (key != null &#x26;&#x26; key.equals(k))))
            return first<span class="hljs-comment">;</span>
        if ((<span class="hljs-attr">e</span> = first.next) != null) {
            if (first instanceof TreeNode)
                //如果是红黑树节点 通过红黑树查找方法查找
                return ((TreeNode&#x3C;K,V>)first).getTreeNode(hash, key)<span class="hljs-comment">;</span>
            do {
                //对链表查找
                if (<span class="hljs-attr">e.hash</span> == hash &#x26;&#x26;
                    ((<span class="hljs-attr">k</span> = e.key) == key || (key != null &#x26;&#x26; key.equals(k))))
                    return e<span class="hljs-comment">;</span>
            } while ((<span class="hljs-attr">e</span> = e.next) != null)<span class="hljs-comment">;</span>
        }
    }
    return null<span class="hljs-comment">;</span>
}
<span class="copy-code-btn">复制代码</span></code></pre><h3 data-id="heading-29">4.4.5 resize()</h3><p>扩容就是重新定义容量，在hashmap中，如果不断的put元素，而hashMap对象中的数组无法装得下更多对象时，对象就需要进行扩容，扩大数组长度。这边注意的是：</p><p></p><div><div>①假如初始大小为默认值16，什么时候扩容，我们可以知道阈值是16</div>0.75即12，这个12是指hashMap的size(全局变量，每次put+1.remove-1)，put后为大于12即13时开始执行resize方法扩容。</div>*<p></p><p>②<b>在java中数组是不能够自动扩容的，是采用一个新的大容量数组代替原有的小数组，就好比用一个小桶装水，如果想用一个桶装更多的水，就换一个大桶再把原来小桶的水装过去。</b></p><p><b>③扩容后，普通链表上的节点包括红黑树都得重新映射。</b></p><blockquote><p>对于hashmap来说<br>什么时候换大桶：达到阈值的时候<br>换多大的桶：原有小桶的两倍大小<br>但桶的大小也是有限的，对于hashMap，最大的桶能容纳包含2^30个数，大于的话就不再扩容，就随里面碰撞了。(实际上也很难用到这么大的容量)</p></blockquote><pre><code lang="ini" class="hljs language-ini copyable">final Node&#x3C;K,V><span class="hljs-section">[]</span> resize() {
    //table为全局变量transient Node&#x3C;K,V><span class="hljs-section">[]</span> table<span class="hljs-comment">; 赋值给oldTab</span>
    Node&#x3C;K,V><span class="hljs-section">[]</span> <span class="hljs-attr">oldTab</span> = table<span class="hljs-comment">;</span>
    int <span class="hljs-attr">oldCap</span> = (oldTab == null) ? <span class="hljs-number">0</span> : oldTab.length<span class="hljs-comment">;//旧表数组个数</span>
    int <span class="hljs-attr">oldThr</span> = threshold<span class="hljs-comment">;</span>
    int newCap, <span class="hljs-attr">newThr</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    if (oldCap > 0) { //如果旧容量大于0    
        //超过最大值就不扩容了，随它碰撞去吧 -。-
        if (oldCap >= MAXIMUM_CAPACITY) {
            <span class="hljs-attr">threshold</span> = Integer.MAX_VALUE<span class="hljs-comment">;</span>
            return oldTab<span class="hljs-comment">;</span>
        }
        //×2还没超过最大值，新数组就扩容为原来两倍 阈值也做×2处理
        else if ((<span class="hljs-attr">newCap</span> = oldCap &#x3C;&#x3C; <span class="hljs-number">1</span>) &#x3C; MAXIMUM_CAPACITY &#x26;&#x26;
                 oldCap >= DEFAULT_INITIAL_CAPACITY)
            <span class="hljs-attr">newThr</span> = oldThr &#x3C;&#x3C; <span class="hljs-number">1</span><span class="hljs-comment">; // double threshold </span>
    }
    //如果原来的阈值 > 0且旧容量为0，则将新容量设为原来的阈值，初始化有参给threshold赋值会有此情况
    else if (oldThr > 0) 
        <span class="hljs-attr">newCap</span> = oldThr<span class="hljs-comment">;</span>
    else { // zero initial threshold signifies using defaults
        //默认初始化无参构造的情况 
        <span class="hljs-attr">newCap</span> = DEFAULT_INITIAL_CAPACITY<span class="hljs-comment">;</span>
        <span class="hljs-attr">newThr</span> = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY)<span class="hljs-comment">;</span>
    }
    //如果
    if (<span class="hljs-attr">newThr</span> == <span class="hljs-number">0</span>) {
        float <span class="hljs-attr">ft</span> = (float)newCap * loadFactor<span class="hljs-comment">;</span>
        <span class="hljs-attr">newThr</span> = (newCap &#x3C; MAXIMUM_CAPACITY &#x26;&#x26; ft &#x3C; (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE)<span class="hljs-comment">;</span>
    }
    <span class="hljs-attr">threshold</span> = newThr<span class="hljs-comment">;</span>
    @SuppressWarnings({"rawtypes","unchecked"}) //屏蔽无关紧要的警告
        Node&#x3C;K,V><span class="hljs-section">[]</span> <span class="hljs-attr">newTab</span> = (Node&#x3C;K,V>[])new Node[newCap]<span class="hljs-comment">;</span>
    <span class="hljs-attr">table</span> = newTab<span class="hljs-comment">;</span>
    //如果旧数组不为空 
    if (oldTab != null) {
        //遍历数组
        for (int <span class="hljs-attr">j</span> = <span class="hljs-number">0</span><span class="hljs-comment">; j &#x3C; oldCap; ++j) {</span>
            Node&#x3C;K,V> e<span class="hljs-comment">;</span>
            //数组中的节点不为空
            if ((<span class="hljs-attr">e</span> = oldTab[j]) != null) {
                oldTab<span class="hljs-section">[j]</span> = null<span class="hljs-comment">;</span>
                //如果该桶只有一个节点(说明下面没有链表，或者说只有一个链表节点)
                if (<span class="hljs-attr">e.next</span> == null)
                    //e.hash &#x26; (newCap - 1)确定元素存放位置
                    newTab<span class="hljs-section">[e.hash &#x26; (newCap - 1)]</span> = e<span class="hljs-comment">;</span>
                else if (e instanceof TreeNode)
                    //红黑树节点
                    ((TreeNode&#x3C;K,V>)e).split(this, newTab, j, oldCap)<span class="hljs-comment">;</span>
                else { 
                    //链表节点且当前链表节点不止1个
                    Node&#x3C;K,V> <span class="hljs-attr">loHead</span> = null, loTail = null<span class="hljs-comment">;</span>
                    Node&#x3C;K,V> <span class="hljs-attr">hiHead</span> = null, hiTail = null<span class="hljs-comment">;</span>
                    Node&#x3C;K,V> next<span class="hljs-comment">;</span>
                    do {
                        <span class="hljs-attr">next</span> = e.next<span class="hljs-comment">;</span>
                        //根据e.hash &#x26; oldCap 判断节点存放位置
                        //如果为0 扩容还在原来位置 如果为1 新的位置为 旧的index + oldCap 下面如何扩容有做介绍
                        if ((e.hash &#x26; oldCap) == 0) {
                            if (<span class="hljs-attr">loTail</span> == null)
                                <span class="hljs-attr">loHead</span> = e<span class="hljs-comment">;</span>
                            else
                                <span class="hljs-attr">loTail.next</span> = e<span class="hljs-comment">;</span>
                            <span class="hljs-attr">loTail</span> = e<span class="hljs-comment">;</span>
                        }
                        else {
                            if (<span class="hljs-attr">hiTail</span> == null)
                                <span class="hljs-attr">hiHead</span> = e<span class="hljs-comment">;</span>
                            else
                                <span class="hljs-attr">hiTail.next</span> = e<span class="hljs-comment">;</span>
                            <span class="hljs-attr">hiTail</span> = e<span class="hljs-comment">;</span>
                        }
                    } while ((<span class="hljs-attr">e</span> = next) != null)<span class="hljs-comment">;//旧链表迁移到新链表</span>
                    if (loTail != null) {
                        <span class="hljs-attr">loTail.next</span> = null<span class="hljs-comment">;//将链表的尾节点的next设置为空</span>
                        newTab<span class="hljs-section">[j]</span> = loHead<span class="hljs-comment">;</span>
                    }
                    if (hiTail != null) {
                        <span class="hljs-attr">hiTail.next</span> = null<span class="hljs-comment">;// 将链表的尾节点 的next 设置为空</span>
                        newTab<span class="hljs-section">[j + oldCap]</span> = hiHead<span class="hljs-comment">;</span>
                    }
                }
            }
        }
    }
    return newTab<span class="hljs-comment">;</span>
}
<span class="copy-code-btn">复制代码</span></code></pre><h3 data-id="heading-30">4.3 HashMap经典代码 p = tab[i = (n - 1) &#x26; hash])</h3><pre><code lang="css" class="hljs language-css copyable"><span class="hljs-selector-tag">p</span> = tab<span class="hljs-selector-attr">[i = (n - 1) &#x26; hash]</span>)
<span class="copy-code-btn">复制代码</span></code></pre><p>当hashCode小于65536，散列是很规律的，基本上索引的位置就是</p><p>因为小于这个数右移16为都为0，且和占位符都为0的值异或后的hashcode就是自身的值。</p><p>这个值比较特殊</p><p>转换为二进制：00000000000000010000000000000000，右移16的话00000000000000000000000000000001并不全为0</p><pre><code lang="java" class="hljs language-java copyable"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> {
    <span class="hljs-type">int</span> h;
    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h >>> <span class="hljs-number">16</span>);
}
<span class="copy-code-btn">复制代码</span></code></pre><p>key的hashcode为65536</p><p>转为二进制：h=key.hashCode() 00000000000000010000000000000000</p><p>跟右移16位的再做异或操作 00000000000000000000000000000001</p><p>hash = h ^(h>>>16) 00000000000000010000000000000001</p><p>​</p><p>计算hash 00000000000000010000000000000001</p><p>​ 00000000000000000000000000001111</p><p>结果 1</p><p>但是65536 % 16 = 0</p><p>key的hashcode为17 异或相同为0 不同为假</p><p>转为二进制：h=key.hashCode() 00000000000000000000000000010001</p><p>跟右移16位的再做异或操作 00000000000000000000000000000000</p><p>hash = h ^(h>>16) 00000000000000000000000000010001</p><p>计算hash 00000000000000000000000000010001</p><p>​ 00000000000000000000000000001111</p><p>​ 00000000000000000000000000000001</p><p>做个小测试，假设这个时候桶的个数为16，代码如下</p><pre><code lang="less" class="hljs language-less copyable"><span class="hljs-selector-tag">for</span> (int key = <span class="hljs-number">65533</span>; key &#x3C; <span class="hljs-number">65543</span>; key++) { <span class="hljs-comment">//从65536开始变得有点"特别"</span>
    <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">"key为："</span> + key +  <span class="hljs-string">"，索引位置："</span> + ((key ^ (key >>> <span class="hljs-number">16</span>)) &#x26; <span class="hljs-number">15</span>));<span class="hljs-comment">//假设初始容量为16 测试没扩容时这些数的索引位置</span>
}
<span class="hljs-comment">//输出结果为，可以发现从65536开始不为0而是1，有点特殊，然后相邻两个索引位置呈1,3的增长，具体可画图尝试</span>
<span class="hljs-selector-tag">i</span>为：<span class="hljs-number">65533</span>，输出<span class="hljs-number">13</span>
<span class="hljs-selector-tag">i</span>为：<span class="hljs-number">65534</span>，输出<span class="hljs-number">14</span>
<span class="hljs-selector-tag">i</span>为：<span class="hljs-number">65535</span>，输出<span class="hljs-number">15</span>
<span class="hljs-selector-tag">i</span>为：<span class="hljs-number">65536</span>，输出<span class="hljs-number">1</span>
<span class="hljs-selector-tag">i</span>为：<span class="hljs-number">65537</span>，输出<span class="hljs-number">0</span>
<span class="hljs-selector-tag">i</span>为：<span class="hljs-number">65538</span>，输出<span class="hljs-number">3</span>
<span class="hljs-selector-tag">i</span>为：<span class="hljs-number">65539</span>，输出<span class="hljs-number">2</span>
<span class="hljs-selector-tag">i</span>为：<span class="hljs-number">65540</span>，输出<span class="hljs-number">5</span>
<span class="hljs-selector-tag">i</span>为：<span class="hljs-number">65541</span>，输出<span class="hljs-number">4</span>
<span class="hljs-selector-tag">i</span>为：<span class="hljs-number">65542</span>，输出<span class="hljs-number">7</span>
<span class="copy-code-btn">复制代码</span></code></pre><p>这段代码主要是计算索引位置的，HashMap 底层数组的长度总是 2 的 n 次方</p><p>当 length 总是 2 的倍数时，h&#x26; (length-1)，将是一个非常巧妙的设计：</p><table><thead><tr><th>hash值</th><th>length(假设长度为16)</th><th>h &#x26; length - 1</th></tr></thead><tbody><tr><td>5</td><td>16</td><td>5</td></tr><tr><td>6</td><td>16</td><td>6</td></tr><tr><td>15</td><td>16</td><td>15</td></tr><tr><td>16</td><td>16</td><td>0</td></tr><tr><td>17</td><td>16</td><td>1</td></tr></tbody></table><p><b>可以看到计算得到的索引值总是位于 table 数组的索引之内。并且通常分布的比较均匀</b></p><h3 data-id="heading-31">4.4 树形化treeifyBin()</h3><p>在jdk8以前，如果发生频繁碰撞的话，查找时间复杂度是O(1) + O(n) (先找在数组的位置再找链表)，n如果比较大则严重影响了查找性能，而到了jdk8引入红黑树,O(1) + O(logN)。</p><p>jdk1.8中，如果一个桶中元素个数超过TREEIFY_THRESHOLD(8)时，就用红黑树替换链表以提升速度(主要是查找)</p><pre><code lang="ini" class="hljs language-ini copyable">//将桶内所有链表节点换成红黑树节点
final void treeifyBin(Node&#x3C;K,V><span class="hljs-section">[]</span> tab, int hash) {
    int n, index<span class="hljs-comment">; Node&#x3C;K,V> e;</span>
    //如果当前哈希表为空 或者哈希表中元素 MIN_TREEIFY_CAPACITY默认为64，对于这个值可以认为，如果节点数组长度小于64，就没必要去进行结构转换，而是通过resize()操作，这样原先一个链表的元素可能会进行重新分配。
    if (<span class="hljs-attr">tab</span> == null || (n = tab.length) &#x3C; MIN_TREEIFY_CAPACITY)
        resize()<span class="hljs-comment">; //扩容</span>
    //大于等于64 就树化 链表上的普通节点变成树节点
    else if ((<span class="hljs-attr">e</span> = tab[index = (n - <span class="hljs-number">1</span>) &#x26; hash]) != null) {      
        TreeNode&#x3C;K,V> <span class="hljs-attr">hd</span> = null, tl = null<span class="hljs-comment">; //定义首、尾节点</span>
        do {
            TreeNode&#x3C;K,V> <span class="hljs-attr">p</span> = replacementTreeNode(e, null)<span class="hljs-comment">; //普通节点 -> 树节点</span>
            if (<span class="hljs-attr">tl</span> == null) //如果尾节点为空 说明还没有根节点
                <span class="hljs-attr">hd</span> = p<span class="hljs-comment">; //首节点(根节点) 指向当前节点</span>
            else { //尾节点不为空 
                <span class="hljs-attr">p.prev</span> = tl<span class="hljs-comment">; //当前树节点前一个节点指向尾节点</span>
                <span class="hljs-attr">tl.next</span> = p<span class="hljs-comment">; //尾节点后一个节点 指向当前节点</span>
            }
            <span class="hljs-attr">tl</span> = p<span class="hljs-comment">; </span>
        } while ((<span class="hljs-attr">e</span> = e.next) != null)<span class="hljs-comment">; //继续遍历链表</span>
      
        //这个时候只是把Node对象变成TreeNode对象，把单向链表变成双向链表
        if ((tab<span class="hljs-section">[index]</span> = hd) != null)
            hd.treeify(tab)<span class="hljs-comment">;</span>
    }
}
<span class="copy-code-btn">复制代码</span></code></pre><h1 data-id="heading-32">5.思考</h1><h3 data-id="heading-33">1.HashMap和HashTable的区别是什么</h3><p>HashMap和Hashtable都实现了Map接口</p><blockquote><p>HashMap功能上几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。<br>HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的<br>由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。<br>HashMap不能保证随着时间的推移Map中的元素次序是不变的。</p></blockquote><p>由于性能问题，以及HashTable处理Hash冲突比HashMap逊色很多，现在HashTable已经很少使用了。但由于线程安全以及以前的项目还在使用，SUN依然还保留着它并没有加Deprecated过时注解。</p><p>摘自hashtable源码</p><blockquote><p>If a thread-safe implementation is not needed, it is recommended to use HashMap in place of Hashtable. If a thread-safe highly-concurrent implementation is desired, then it is recommended to use java.util.concurrent.ConcurrentHashMap in place of Hashtable.</p></blockquote><p>简单来说就是不需要线程安全，那么使用HashMap，如果需要线程安全，那么使用ConcurrentHashMap。</p><h3 data-id="heading-34">2.HashMap为什么线程不安全，如果想要线程安全怎么做</h3><p>因为hashmap为了性能，它的put，resize等操作都不是同步的，假设两个线程同一时间做put操作,可能最后计算的size并不正确，值得一提的是jdk1.8以前多线程put甚至会导致闭环死循环，1.8开始不会有这个问题但依然存在线程安全问题。</p><p>jdk8前的闭环死循环。</p><p>这种问题在单线程下不存在，但在多线程下可能引起死循环导致cpu占用过高。</p><p>如果hash冲突大，同一链表下下有多个节点容易出现这种问题。具体参考<a href="https://link.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Fgo%2FarticleRenderRedirect%3Furl%3Dhttps%253A%252F%252Fwww.jianshu.com%252Fp%252F1e9cf0ac07f4" target="_blank" title="https://yq.aliyun.com/go/articleRenderRedirect?url=https%3A%2F%2Fwww.jianshu.com%2Fp%2F1e9cf0ac07f4" ref="nofollow noopener noreferrer">老生常谈，HashMap的死循环</a></p><pre><code lang="scss" class="hljs language-scss copyable">若想要线程安全
<span class="hljs-number">1</span>、使用ConcurrentHashMap。(线程安全的hashMap)
<span class="hljs-number">2</span>、使用Collections<span class="hljs-selector-class">.synchronizedMap</span>(Mao&#x3C;K,V> m)方法把HashMap变成一个线程安全的Map。
<span class="copy-code-btn">复制代码</span></code></pre><h3 data-id="heading-35">3.HashMap是怎么解决Hash冲突的</h3><pre><code lang="scss" class="hljs language-scss copyable">在实际应用中，无论怎么构造哈希函数，冲突也难以完全避免。
HashMap根据链地址法(拉链法)来解决冲突,jdk8中如果链表长度大于<span class="hljs-number">8</span>且节点数组长度大于<span class="hljs-number">64</span>的时候，就把链表下所有节点转为红黑树，位于数组上的节点为根节点，来维护hash冲突的元素，链表中冲突的元素可以通过key的<span class="hljs-built_in">equals</span>()方法来确定。
<span class="copy-code-btn">复制代码</span></code></pre><h3 data-id="heading-36">4.HashMap是怎么扩容的</h3><p>先写个例子测试hashMap有没有在扩容。</p><pre><code lang="arduino" class="hljs language-arduino copyable"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> throws NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>{
    HashMap&#x3C;Integer,<span class="hljs-type">String</span>> o = <span class="hljs-keyword">new</span> HashMap&#x3C;>(<span class="hljs-number">1</span>);
    System.out.<span class="hljs-built_in">println</span>(o.<span class="hljs-built_in">size</span>()); <span class="hljs-comment">//0 size为元素个数</span>
    <span class="hljs-comment">//扩容条件是 如果没有定义初始容量 默认扩容至16 如果没有 根据put的情况扩容</span>
    <span class="hljs-comment">//put的过程中 如果插入一个元素过后的size > 阈值(加载因子 * 最近容量)</span>
    <span class="hljs-comment">/**
     * 代码体现 put后执行
     *   if (++size > threshold)
     *         resize();
     */</span>
    <span class="hljs-comment">//有定义容量的话会采用大于这个数的最小二次幂 第一次初始化为1 则输出为2 4 5 11  111 11</span>
    HashMap&#x3C;Integer,<span class="hljs-type">String</span>> map = <span class="hljs-keyword">new</span> HashMap&#x3C;>(<span class="hljs-number">1</span>);
    map.<span class="hljs-built_in">put</span>(<span class="hljs-number">1</span>, <span class="hljs-string">"一"</span>);
    <span class="hljs-comment">//由于方法由final修饰 利用反射机制获取容量值</span>
    Class&#x3C;?> mapType = map.<span class="hljs-built_in">getClass</span>();
    Method capacity = mapType.<span class="hljs-built_in">getDeclaredMethod</span>(<span class="hljs-string">"capacity"</span>);
    capacity.<span class="hljs-built_in">setAccessible</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">//由于capacity方法由final修饰 暴力获取</span>
    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"capacity : "</span> + capacity.<span class="hljs-built_in">invoke</span>(map)); <span class="hljs-comment">//capacity : 2</span>
 
    map.<span class="hljs-built_in">put</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"二"</span>);
    capacity = mapType.<span class="hljs-built_in">getDeclaredMethod</span>(<span class="hljs-string">"capacity"</span>);
    capacity.<span class="hljs-built_in">setAccessible</span>(<span class="hljs-literal">true</span>);
    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"capacity : "</span> + capacity.<span class="hljs-built_in">invoke</span>(map)); <span class="hljs-comment">//capacity : 4 当前容量为2 插入该元素后size为 2 > 2 * 3/4 开始扩容</span>

    <span class="hljs-comment">//当前容量为4 此时已有2个 3 = 4 * 3/4 不进行扩容</span>
    map.<span class="hljs-built_in">put</span>(<span class="hljs-number">3</span>, <span class="hljs-string">"三"</span>);
    capacity = mapType.<span class="hljs-built_in">getDeclaredMethod</span>(<span class="hljs-string">"capacity"</span>);
    capacity.<span class="hljs-built_in">setAccessible</span>(<span class="hljs-literal">true</span>);
    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"capacity : "</span> + capacity.<span class="hljs-built_in">invoke</span>(map)); <span class="hljs-comment">//capacity : 4 当前容量为2 插入该元素后size为 3 = 4 * 3/4 不扩容</span>

    map.<span class="hljs-built_in">put</span>(<span class="hljs-number">4</span>, <span class="hljs-string">"四"</span>);
    capacity = mapType.<span class="hljs-built_in">getDeclaredMethod</span>(<span class="hljs-string">"capacity"</span>);
    capacity.<span class="hljs-built_in">setAccessible</span>(<span class="hljs-literal">true</span>);
    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"capacity : "</span> + capacity.<span class="hljs-built_in">invoke</span>(map));<span class="hljs-comment">//capacity : 8  当前容量为4 此时已有4个 4 > 4 * 3/4 开始扩容</span>
}
<span class="copy-code-btn">复制代码</span></code></pre><p>上面的例子可以看出put后，hashmap确实有进行扩容，hashMap的扩容机制与其它的集合边长不太一样，它是通过当前hash桶个数乘2进行扩容</p><p>hashMap主要是通过resize()方法扩容</p><p>假设oldTable的key的hash为15，7，4，5，8，1，hashMap为初始容量为8的数组桶，存储位置如下</p><table><thead><tr><th>index</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>hash</td><td>8</td><td>1</td><td></td><td></td><td>4</td><td>5</td><td></td><td>7，15</td></tr></tbody></table><p>当put一个新元素 假设为9，且加载因子使用默认的0.75，在内存空间中新的存储位置如下</p><table><thead><tr><th>index</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>hash</td><td></td><td>1</td><td></td><td></td><td>4</td><td>5</td><td></td><td>7</td><td>8</td><td>9</td><td></td><td></td><td></td><td></td><td></td><td>15</td></tr></tbody></table><p>可以看到扩容之后8跑到了第9个位置，15跑到了第16个位置，旧的8，1，4，5在各自的链表上只有一个节点</p><p>根据 <b>e.hash &#x26; (newCap - 1)</b> 相当于 与上15后，都为自己本身所以位置保持不变</p><p>但是链表上不止有一个节点的情况，比如说上面的7，15存放的位置</p><p>这个时候是先根据 <b>e.hash &#x26; oldCap</b>判断元素在数组的位置是否需要移动</p><p>比如说 7 &#x26; 8 = 0111 &#x26; 1000 = 0 ; 15 &#x26; 8 = 1111 &#x26; 1000 = 1，规律是比较高位的第一个 比如说15为高位，第一个为1，如果高位为1那么与后结果也为1</p><p><b>当e.hash &#x26; oldCap == 0时</b></p><p>链表上节点位置保持不变</p><p><b>当e.hash &#x26; oldCap == 1时</b></p><p>链表上节点的位置为原位置的index + oldCap 比如说15，新的索引位置为7+8为15</p><blockquote><p>值得一提的是，jdk1.8的resize()方法相比与之前做了点优化，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但JDK1.8不会倒置，jdk8通过e.hash &#x26; oldCap，通过0和1的值均匀把之前的冲突的节点分散到新的bucket了，这样做更为高效。</p></blockquote><p>代码见【4.4.5 resize()方法】</p><h3 data-id="heading-37">5.loadFactor加载因子为何为0.75f</h3><blockquote><p>加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之越小。<br>简单来说就是如果加载因子太小，空间利用率低，且太容易扩容对性能不太友好，设置太高，不及时扩容容易导致冲突几率大，将提高了查询成本。所以0.75是很合适的值，经过试验，在理想情况下,使用随机哈希码,节点出现的频率在hash桶中遵循泊松分布【在频率附近发生概率高，向两边对称下降。】<br>详细见 <a href="https://link.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Fgo%2FarticleRenderRedirect%3Furl%3Dhttps%253A%252F%252Fwww.cnblogs.com%252FDarrenChan%252Fp%252F8854859.html" target="_blank" title="https://yq.aliyun.com/go/articleRenderRedirect?url=https%3A%2F%2Fwww.cnblogs.com%2FDarrenChan%2Fp%2F8854859.html" ref="nofollow noopener noreferrer">为什么HashMap中默认加载因子为0.75</a></p></blockquote><h3 data-id="heading-38">6.hashMap中一般使用什么类型的元素作为key，为什么？</h3><blockquote><p>常用String，Integer这样的key<br>主要原因为<br>这些类是Immutable(不可变的)，String和基本类型的包装类规范的重写了hashCode()和equals()方法。作为不可变类天生是线程安全的，而且可以很好的优化比如可以缓存hash值，避免重复计算等等，如果采用可变的对象类型，可能出现put进去就无法查询到的情况。<br>如果想用自定义的类型作为键，那么需要遵守equals()和hashCode()方法的定义规则且不可变，对象插入到map后就不会再改变。</p></blockquote><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Fgo%2FarticleRenderRedirect%3Furl%3Dhttp%253A%252F%252Fwww.cnblogs.com%252F0201zcr%252Fp%252F4810813.html" target="_blank" title="https://yq.aliyun.com/go/articleRenderRedirect?url=http%3A%2F%2Fwww.cnblogs.com%2F0201zcr%2Fp%2F4810813.html" ref="nofollow noopener noreferrer">HashMap的key可以是可变对象吗？</a></p><h3 data-id="heading-39">7.源码中为什么要用transient修饰桶数组table</h3><pre><code lang="css" class="hljs language-css copyable">transient Node&#x3C;K,V><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-tag">table</span>;
<span class="copy-code-btn">复制代码</span></code></pre><p>在java中，被transient关键字修饰的变量不会被默认的序列化机制序列化。</p><p>hashMap实现了Serializable接口，通过实现<code>readObject/writeObject</code>两个方法自定义了序列化的内容，size不用多说了，一般涉及到大小可以直接计算的就没必要再序列化。</p><p>为什么不序列化table？原因有下</p><blockquote><p>1.table大多数情况是无法存满的。比如说桶数组容量是16，只put了一个元素，这会造成序列化未使用的部分。造成浪费。</p><p>2.同一个键值对在不同jvm下，所处桶的位置可能是不同的，在不同的jvm下反序列化可能发生错误。(hashmap的get/put/remove等方法刚开始都是通过hash找到键所在的桶位置，就是数组下标，但如果键没有重写hashCode方法，就会调用Object的hashCode方法，而Object的hashcode方法是navtive(本地方法)的，这里的hashcode是对对象内存地址的映射得出的int结果，具体怎么计算不得而知，但是在不同jvm下，可能有不同的hashcode实现，这样产生的hash也不一样)。</p></blockquote><h3 data-id="heading-40">8.HashMap的key如果为null，怎么查找值</h3><p>我们知道hashMap只允许一个为null的key，如果key为null，因为key为null，那么hash为0，那么p = tab[i = (n - 1) &#x26; hash 也一定为0，所以是从数组上第一个位置的链表下查找。</p><pre><code lang="java" class="hljs language-java copyable"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> {
    <span class="hljs-type">int</span> h;
    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h >>> <span class="hljs-number">16</span>);
}
<span class="copy-code-btn">复制代码</span></code></pre><h1 data-id="heading-41">6.使用建议</h1><p>1.默认情况下HashMap的容量是16，但是，如果用户通过构造函数指定了一个数字作为容量，那么Hash会选择大于该数字的第一个2的幂作为容量。(1->2、7->8、9->16)</p><blockquote><p>在初始化HashMap的时候，应该尽量指定其大小。尤其是当你已知map中存放的元素个数时。（《阿里巴巴Java开发规约》）</p></blockquote><p>这边可以看下hashMap的4个构造方法，一般采用3，但如果已经知道个数，建议用2(加载因子0.75很合适不建议改动)</p><pre><code lang="csharp" class="hljs language-csharp copyable"><span class="hljs-comment">//1 自定义传初始容量和加载因子</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> initialCapacity, <span class="hljs-built_in">float</span> loadFactor</span>)</span> {
    <span class="hljs-keyword">if</span> (initialCapacity &#x3C; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal initial capacity: "</span> +
                                           initialCapacity);
    <span class="hljs-keyword">if</span> (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    <span class="hljs-keyword">if</span> (loadFactor &#x3C;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal load factor: "</span> +
                                           loadFactor);
    <span class="hljs-keyword">this</span>.loadFactor = loadFactor;
    <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);
}

<span class="hljs-comment">//2 自定义初始大小 调1构造方法，加载因子使用默认大小</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> initialCapacity</span>)</span> {
        <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);
}

<span class="hljs-comment">//3 最常用的无参构造方法</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span>()</span> {
    <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted</span>
}

<span class="hljs-comment">//4 将别的map对象映射到自身存储，很少用</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span>(<span class="hljs-params">Map&#x3C;? extends K, ? extends V> m</span>)</span> {
    <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;
    putMapEntries(m, <span class="hljs-literal">false</span>);
}
<span class="copy-code-btn">复制代码</span></code></pre><p>这边讲解一下tableSizeFor方法。简述一下该方法的作用：</p><p>如果自定义容量大小时(调1或2的构造方法)，传入一个初始容量大小，<b>大于输入参数且最近的2的整数次幂的数</b>。比如10，则返回16，75返回128</p><blockquote><p>不这么做的缺点</p><p>假设HashMap需要放置1024个元素，由于没有设置初始容量大小，随着元素不断增加，容量7次被迫扩大。而resize过程需要重建hash表，这会严重影响性能。</p></blockquote><pre><code lang="arduino" class="hljs language-arduino copyable"><span class="hljs-comment">/**
 * Returns a power of two size for the given target capacity.
 */</span>
<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-type">int</span> cap)</span> </span>{
    <span class="hljs-comment">//cap-1的目的是因为如果cap是2的幂数不做-1操作的话 那么最后执行完右移操作的话，返回的值将会是原有值得两倍。如果n为0的话，即cap=1，经过后面几次操作返回的为0，最后返回的capacity仍然为1(最后有加1的操作)</span>
    <span class="hljs-type">int</span> n = cap - <span class="hljs-number">1</span>;
    n |= n >>> <span class="hljs-number">1</span>;
    n |= n >>> <span class="hljs-number">2</span>;
    n |= n >>> <span class="hljs-number">4</span>;
    n |= n >>> <span class="hljs-number">8</span>;
    n |= n >>> <span class="hljs-number">16</span>;
    <span class="hljs-keyword">return</span> (n &#x3C; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;
}
<span class="copy-code-btn">复制代码</span></code></pre><p><b>解释一下这段代码</b></p><p>在java中，|=的作用是比较两个对象是否相等</p><p>a|=b的意思就是把a和b按位或然后赋值给a</p><p>以10为例整体流程大致如下</p><div><div><div></div><div><img alt="img_eadde165ab656c39debed0afc9a20492.png" src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/26/16d6cc9bf3b23a1b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" loading="lazy"></div></div><div>算法流程</div></div><p>简单来说，这种运算最后会导致1占满了它自己所占位，比如说250，它的二进制为</p><p>11111010，经过上面的或运算之后，最终将变为11111111，这种情况在加上1，就是大于这个数的最小二次幂。</p><h1 data-id="heading-42">7.总结</h1><p>HashMap的设计与实现十分的巧妙。jdk8更是有很多提升，还没写这篇博客对于HashMap的理解仅仅只在表面。阅读源码后才发现里面还有不少的学问，由于本人水平有限，虽然花了很多时间写了很多但还有很多细节并不了解，比如说红黑树的代码实现细节，也有可能有几个地方描述错误或者不到位，如果文章有误请指正，以便于我及时修改和学习。</p><h1 data-id="heading-43">8.参考链接</h1><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Fgo%2FarticleRenderRedirect%3Furl%3Dhttp%253A%252F%252Fwww.coolblog.xyz%252F2018%252F01%252F18%252FHashMap-%2525E6%2525BA%252590%2525E7%2525A0%252581%2525E8%2525AF%2525A6%2525E7%2525BB%252586%2525E5%252588%252586%2525E6%25259E%252590-JDK1-8%252F" target="_blank" title="https://yq.aliyun.com/go/articleRenderRedirect?url=http%3A%2F%2Fwww.coolblog.xyz%2F2018%2F01%2F18%2FHashMap-%25E6%25BA%2590%25E7%25A0%2581%25E8%25AF%25A6%25E7%25BB%2586%25E5%2588%2586%25E6%259E%2590-JDK1-8%2F" ref="nofollow noopener noreferrer">HashMap 源码详细分析(JDK1.8)</a></p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Fgo%2FarticleRenderRedirect%3Furl%3Dhttps%253A%252F%252Fwww.cnblogs.com%252Fwoniu4%252Fp%252F8301099.html" target="_blank" title="https://yq.aliyun.com/go/articleRenderRedirect?url=https%3A%2F%2Fwww.cnblogs.com%2Fwoniu4%2Fp%2F8301099.html" ref="nofollow noopener noreferrer">HashMap resize方法的理解（一)</a></p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Fgo%2FarticleRenderRedirect%3Fspm%3Da2c4e.11153940.0.0.5bf05442WOllqe%26url%3Dhttps%253A%252F%252Fwww.zhihu.com%252Fquestion%252F20733617" target="_blank" title="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.5bf05442WOllqe&#x26;url=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F20733617" ref="nofollow noopener noreferrer">JDK 源码中 HashMap 的 hash 方法原理是什么</a></p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Fgo%2FarticleRenderRedirect%3Furl%3Dhttps%253A%252F%252Fwww.cnblogs.com%252Fdongguacai%252Fp%252F5599100.html" target="_blank" title="https://yq.aliyun.com/go/articleRenderRedirect?url=https%3A%2F%2Fwww.cnblogs.com%2Fdongguacai%2Fp%2F5599100.html" ref="nofollow noopener noreferrer">hashMap死循环问题</a></p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Fgo%2FarticleRenderRedirect%3Furl%3Dhttps%253A%252F%252Fblog.csdn.net%252FLovePluto%252Farticle%252Fdetails%252F79712473" target="_blank" title="https://yq.aliyun.com/go/articleRenderRedirect?url=https%3A%2F%2Fblog.csdn.net%2FLovePluto%2Farticle%2Fdetails%2F79712473" ref="nofollow noopener noreferrer">浅谈jdk8为何线程不安全</a></p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Farticles%2F651050" target="_blank" title="https://yq.aliyun.com/articles/651050" ref="nofollow noopener noreferrer">yq.aliyun.com/articles/65…</a><br></p><p><br></p></div></div></article> <div class="article-end" data-v-4b9f9746 data-v-020666e8><div class="tag-list-box" data-v-4b9f9746 data-v-020666e8><div class="tag-list" data-v-4b9f9746 data-v-020666e8><div class="tag-list-title" data-v-4b9f9746 data-v-020666e8>分类：</div> <a href="/backend" target="_blank" rel="" class="item category-item" data-v-020666e8><span class="tag-title" data-v-020666e8>后端</span></a></div> <div class="tag-list" data-v-4b9f9746 data-v-020666e8><div class="tag-list-title" data-v-4b9f9746 data-v-020666e8>标签：</div> <div class="tag-list-container" data-v-4b9f9746 data-v-020666e8><a href="/tag/Java" target="_blank" rel="" class="item tag-item" data-v-020666e8><span class="tag-title" data-v-020666e8>Java</span></a></div></div></div> <!----> <div data-fetch-key="1" class="extension-banner" data-v-bf9647a6 data-v-020666e8><span class="banner-icon" data-v-bf9647a6></span> <div class="banner-wrapper" data-v-bf9647a6><a class="banner-title" data-v-bf9647a6>
      安装掘金浏览器插件
    </a> <div class="banner-content" data-v-bf9647a6>多内容聚合浏览、多引擎快捷搜索、多工具便捷提效、多模式随心畅享，你想要的，这里都有！</div></div> <a class="banner-action" data-v-bf9647a6>前往安装</a></div></div> <!----> <!----><!----><!----><!----><!----></div> <!----> <!----> <div st:block="sidebar" class="sidebar sidebar" style="display:none;" data-v-3f76886a data-v-020666e8><div class="sidebar-block author-block pure" data-v-71f2d09e data-v-2d7c39c6 data-v-3f76886a><a href="/user/3227821871208174" target="_blank" rel="" class="user-item item" data-v-2d7c39c6><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC" alt="" class="lazy avatar avatar" data-v-248050e4 data-v-47508ed8 data-v-2d7c39c6> <div class="info-box" data-v-2d7c39c6><!----> <!----></div></a> <div class="operate-btn" data-v-71f2d09e data-v-2d7c39c6><button st:name="followBtn" class="ui-btn follow-btn primary large default attention" data-v-05e27314 data-v-2d7c39c6><!----> 
    关注
  </button> <a href="/notification/im?participantId=3227821871208174" class="im-button im-btn" data-v-11443840 data-v-2d7c39c6><!----> <div data-v-11443840>私信</div></a></div> <div class="cut-off" data-v-71f2d09e data-v-2d7c39c6></div>  <div class="stat-item item" data-v-71f2d09e data-v-2d7c39c6><svg xmlns="http://www.w3.org/2000/svg" width="25" height="26" viewBox="0 0 25 26" class="zan" data-v-71f2d09e data-v-2d7c39c6><g fill="none" fill-rule="evenodd" transform="translate(0 .57)" data-v-71f2d09e data-v-2d7c39c6><ellipse cx="12.5" cy="12.57" fill="#E1EFFF" rx="12.5" ry="12.57" data-v-71f2d09e data-v-2d7c39c6></ellipse><path fill="#7BB9FF" d="M8.596 11.238V19H7.033C6.463 19 6 18.465 6 17.807v-5.282c0-.685.483-1.287 1.033-1.287h1.563zm4.275-4.156A1.284 1.284 0 0 1 14.156 6c.885.016 1.412.722 1.595 1.07.334.638.343 1.687.114 2.361-.207.61-.687 1.412-.687 1.412h3.596c.38 0 .733.178.969.488.239.317.318.728.21 1.102l-1.628 5.645a1.245 1.245 0 0 1-1.192.922h-7.068v-7.889c1.624-.336 2.623-2.866 2.806-4.029z" data-v-71f2d09e data-v-2d7c39c6></path></g></svg> <span class="content" data-v-71f2d09e data-v-2d7c39c6>
      获得点赞
      <span class="count" data-v-71f2d09e data-v-2d7c39c6> 8</span></span></div> <div class="stat-item item" data-v-71f2d09e data-v-2d7c39c6><svg width="25" height="25" viewBox="0 0 25 25" class="icon stat-view-icon" data-v-71f2d09e data-v-2d7c39c6><g fill="none" fill-rule="evenodd" data-v-71f2d09e data-v-2d7c39c6><circle cx="12.5" cy="12.5" r="12.5" fill="#E1EFFF" data-v-71f2d09e data-v-2d7c39c6></circle><path fill="#7BB9FF" d="M4 12.5S6.917 7 12.75 7s8.75 5.5 8.75 5.5-2.917 5.5-8.75 5.5S4 12.5 4 12.5zm8.75 2.292c1.208 0 2.188-1.026 2.188-2.292 0-1.266-.98-2.292-2.188-2.292-1.208 0-2.188 1.026-2.188 2.292 0 1.266.98 2.292 2.188 2.292z" data-v-71f2d09e data-v-2d7c39c6></path></g></svg> <span class="content" data-v-71f2d09e data-v-2d7c39c6>
      文章被阅读
      <span class="count" data-v-71f2d09e data-v-2d7c39c6> 2,500</span></span></div> <!----></div> <!----> <div class="sidebar-block app-download-sidebar-block shadow" data-v-71f2d09e data-v-11c44dd5 data-v-3f76886a><!----> <div class="block-body" data-v-71f2d09e><a href="/app" target="_blank" data-v-11c44dd5><div class="app-link" data-v-11c44dd5><img src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/article.9d13ff7.png" class="qr-img" data-v-11c44dd5> <div class="content-box" data-v-11c44dd5><div class="headline" data-v-11c44dd5>下载稀土掘金APP</div> <div class="desc" data-v-11c44dd5>一个帮助开发者成长的社区</div></div> <!----></div></a></div></div> <!----> <!----> <div class="sticky-block-box" data-v-3f76886a><div class="sidebar-block catalog-block catalog-block pure isExpand" style="display:none;" data-v-71f2d09e data-v-3f76886a><nav class="article-catalog" style="display:none;" data-v-cb93f23a><div class="catalog-title" data-v-cb93f23a>目录</div> <div class="catalog-body" data-v-cb93f23a><ul class="catalog-list" style="margin-top:0px;" data-v-cb93f23a></ul></div></nav></div> <!----></div></div> <div class="article-suspended-panel article-suspended-panel" data-v-b7c4e7d2 data-v-020666e8><svg xmlns="http://www.w3.org/2000/svg" style="display:none;" data-v-b7c4e7d2 data-v-b7c4e7d2><symbol id="icon-collect" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" data-v-b7c4e7d2 data-v-b7c4e7d2><path fill-rule="evenodd" clip-rule="evenodd" d="M5.24287 18.3845C4.89724 18.5507 4.48229 18.4053 4.31605 18.0596C4.26029 17.9437 4.23783 17.8146 4.25117 17.6866L4.75725 12.8332C4.77762 12.6379 4.71431 12.443 4.583 12.297L1.29207 8.63594C1.03567 8.35071 1.05905 7.91164 1.34428 7.65524C1.43464 7.574 1.54475 7.5179 1.66358 7.49254L6.47789 6.46509C6.66998 6.42409 6.83572 6.30367 6.93407 6.13365L9.39894 1.87248C9.59098 1.54049 10.0158 1.42704 10.3478 1.61907C10.453 1.67992 10.5403 1.76729 10.6012 1.87248L13.0661 6.13365C13.1644 6.30367 13.3301 6.42409 13.5222 6.46509L18.3365 7.49254C18.7116 7.57259 18.9508 7.94155 18.8707 8.31664C18.8454 8.43547 18.7893 8.54557 18.708 8.63594L15.4171 12.297C15.2858 12.443 15.2225 12.6379 15.2429 12.8332L15.7489 17.6866C15.7887 18.0681 15.5117 18.4096 15.1303 18.4493C15.0023 18.4627 14.8732 18.4402 14.7572 18.3845L10.3011 16.2412C10.1108 16.1497 9.8893 16.1497 9.69906 16.2412L5.24287 18.3845Z" data-v-b7c4e7d2 data-v-b7c4e7d2></path></symbol><symbol id="icon-comment" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" data-v-b7c4e7d2 data-v-b7c4e7d2><path fill-rule="evenodd" clip-rule="evenodd" d="M4.62739 1.25C2.9347 1.25 1.5625 2.6222 1.5625 4.31489L1.56396 12.643C1.56403 14.3356 2.9362 15.7078 4.62885 15.7078H6.48326L6.93691 17.6869L6.93884 17.6948C7.16894 18.6441 8.28598 19.0599 9.08073 18.4921L12.7965 15.7078H15.5001C17.1928 15.7078 18.565 14.3355 18.565 12.6428L18.5635 4.31477C18.5635 2.62213 17.1913 1.25 15.4986 1.25H4.62739ZM5.98265 9.89255C6.68783 9.89255 7.2595 9.32089 7.2595 8.61571C7.2595 7.91053 6.68783 7.33887 5.98265 7.33887C5.27747 7.33887 4.70581 7.91053 4.70581 8.61571C4.70581 9.32089 5.27747 9.89255 5.98265 9.89255ZM9.95604 9.89255C10.6612 9.89255 11.2329 9.32089 11.2329 8.61571C11.2329 7.91053 10.6612 7.33887 9.95604 7.33887C9.25086 7.33887 8.6792 7.91053 8.6792 8.61571C8.6792 9.32089 9.25086 9.89255 9.95604 9.89255ZM15.2124 8.61571C15.2124 9.32089 14.6407 9.89255 13.9355 9.89255C13.2304 9.89255 12.6587 9.32089 12.6587 8.61571C12.6587 7.91053 13.2304 7.33887 13.9355 7.33887C14.6407 7.33887 15.2124 7.91053 15.2124 8.61571Z" data-v-b7c4e7d2 data-v-b7c4e7d2></path></symbol><symbol id="icon-zan" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" data-v-b7c4e7d2 data-v-b7c4e7d2><path fill-rule="evenodd" clip-rule="evenodd" d="M13.0651 3.25923C12.6654 2.21523 12.1276 1.60359 11.4633 1.40559C10.8071 1.21 10.2539 1.48626 9.97848 1.67918C9.43962 2.05668 9.17297 2.64897 9.0009 3.12662C8.93522 3.30893 8.87504 3.50032 8.82077 3.67291L8.82077 3.67292C8.80276 3.73019 8.78541 3.78539 8.76872 3.8375C8.6974 4.06017 8.63455 4.23905 8.56561 4.38315C8.07104 5.41687 7.64014 6.034 7.2617 6.43277C6.89154 6.8228 6.5498 7.0275 6.18413 7.21038C5.8887 7.35813 5.69369 7.66144 5.69365 8.00211L5.69237 17.3908C5.6923 17.8783 6.08754 18.2736 6.57511 18.2736H14.8382C15.2621 18.2736 15.5829 18.1393 15.8149 17.9421C15.9234 17.8497 15.9985 17.7554 16.0484 17.6856C16.0695 17.6561 16.088 17.6282 16.0983 17.6126L16.1017 17.6075L16.1033 17.6051L16.1194 17.5857L16.1428 17.5478C16.913 16.3019 17.4472 15.3088 17.8659 14.1183C18.3431 12.7613 18.5849 11.5853 18.6874 10.6685C18.7871 9.77617 18.7612 9.07318 18.6558 8.68779C18.5062 8.14118 18.138 7.82653 17.7668 7.66617C17.4231 7.51771 17.0763 7.49836 16.8785 7.49807L13.1134 7.44551C13.662 5.19751 13.31 3.89889 13.0651 3.25923ZM1.251 8.0848C1.22726 7.5815 1.62891 7.16046 2.13277 7.16046H3.4408C3.92832 7.16046 4.32354 7.55568 4.32354 8.04321V17.4303C4.32354 17.9178 3.92832 18.313 3.4408 18.313H2.57554C2.10419 18.313 1.71599 17.9427 1.69378 17.4718L1.251 8.0848Z" data-v-b7c4e7d2 data-v-b7c4e7d2></path></symbol><symbol id="icon-share" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" data-v-b7c4e7d2 data-v-b7c4e7d2><path fill-rule="evenodd" clip-rule="evenodd" d="M10.4167 6.40399C5.35406 6.40399 1.25 10.5675 1.25 15.7035C1.25 16.0225 1.28448 16.4512 1.35344 16.9898C1.36807 17.1039 1.47243 17.1846 1.58655 17.17C1.6483 17.1621 1.70328 17.127 1.73643 17.0743L1.86865 16.8676C1.99553 16.6731 2.10644 16.5147 2.20137 16.3925C3.69554 14.4692 6.13777 13.3823 9.35515 13.3378L10.4167 13.3364V17.0757C10.4167 17.3101 10.6086 17.5 10.8453 17.5C10.959 17.5 11.068 17.4553 11.1483 17.3757L18.145 10.45C18.3961 10.2015 18.3961 9.79853 18.145 9.55L11.1483 2.62426C10.981 2.45858 10.7096 2.45858 10.5422 2.62426C10.4618 2.70383 10.4167 2.81174 10.4167 2.92426V6.40399Z" data-v-b7c4e7d2 data-v-b7c4e7d2></path></symbol><symbol id="icon-report" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" data-v-b7c4e7d2 data-v-b7c4e7d2><path fill-rule="evenodd" clip-rule="evenodd" d="M10.8389 1.89381C11.0873 2.03868 11.2939 2.24532 11.4388 2.49366L18.9369 15.0065C19.4007 15.8015 19.1322 16.8221 18.3371 17.2859C18.0822 17.4346 17.7924 17.5129 17.4973 17.5129H2.50041C1.57993 17.5129 0.83374 16.7667 0.83374 15.8462C0.83374 15.5512 0.912088 15.2614 1.06078 15.0065L8.5595 2.49366C9.0233 1.69857 10.0438 1.43001 10.8389 1.89381ZM10.3118 13.3459C10.6283 13.3459 10.8848 13.6025 10.8848 13.9189V14.4918C10.8848 14.8082 10.6283 15.0647 10.3118 15.0647H9.73893C9.42252 15.0647 9.16602 14.8082 9.16602 14.4918V13.9189C9.16602 13.6025 9.42252 13.3459 9.73893 13.3459H10.3118ZM10.8356 7.09513C10.8356 6.86502 10.6491 6.67847 10.419 6.67847H9.58512C9.35501 6.67847 9.16846 6.86502 9.16846 7.09513V12.0956C9.16846 12.3257 9.35501 12.5123 9.58512 12.5123H10.419C10.6491 12.5123 10.8356 12.3257 10.8356 12.0956V7.09513Z" data-v-b7c4e7d2 data-v-b7c4e7d2></path></symbol><symbol id="icon-immerse" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" data-v-b7c4e7d2 data-v-b7c4e7d2><path fill-rule="evenodd" clip-rule="evenodd" d="M0.25 1C0.25 0.585786 0.585786 0.25 1 0.25H4C4.41421 0.25 4.75 0.585786 4.75 1C4.75 1.41421 4.41421 1.75 4 1.75H1.75V4C1.75 4.41421 1.41421 4.75 1 4.75C0.585786 4.75 0.25 4.41421 0.25 4V1ZM0.25 19C0.25 19.4142 0.585786 19.75 1 19.75H4C4.41421 19.75 4.75 19.4142 4.75 19C4.75 18.5858 4.41421 18.25 4 18.25H1.75V16C1.75 15.5858 1.41421 15.25 1 15.25C0.585786 15.25 0.25 15.5858 0.25 16V19ZM19 0.25C19.4142 0.25 19.75 0.585786 19.75 1V4C19.75 4.41421 19.4142 4.75 19 4.75C18.5858 4.75 18.25 4.41421 18.25 4V1.75H16C15.5858 1.75 15.25 1.41421 15.25 1C15.25 0.585786 15.5858 0.25 16 0.25H19ZM19.75 19C19.75 19.4142 19.4142 19.75 19 19.75H16C15.5858 19.75 15.25 19.4142 15.25 19C15.25 18.5858 15.5858 18.25 16 18.25H18.25V16C18.25 15.5858 18.5858 15.25 19 15.25C19.4142 15.25 19.75 15.5858 19.75 16V19ZM7 5C5.89543 5 5 5.89543 5 7V13C5 14.1046 5.89543 15 7 15H13C14.1046 15 15 14.1046 15 13V7C15 5.89543 14.1046 5 13 5H7Z" data-v-b7c4e7d2 data-v-b7c4e7d2></path></symbol><symbol id="icon-wechat" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" data-v-b7c4e7d2 data-v-b7c4e7d2><path fill-rule="evenodd" clip-rule="evenodd" d="M13.5578 5.34061C12.0476 2.85722 8.90911 1.73257 6.11813 2.05358C4.56413 2.23231 3.0449 2.85861 1.88463 3.92471C1.00689 4.72863 0.354462 5.78486 0.109889 6.95889C-0.187864 8.37395 0.125815 9.85314 0.957723 11.0298C1.28982 11.4994 1.68479 11.9193 2.11951 12.2941C2.25136 12.4079 2.38694 12.5172 2.52543 12.6228C2.59301 12.6742 2.66115 12.7249 2.73011 12.7745C2.74195 12.7831 2.75392 12.7902 2.76512 12.7969C2.80389 12.8201 2.83351 12.8378 2.81653 12.8887L2.67458 13.3177C2.53986 13.7252 2.40492 14.1325 2.26998 14.5399C2.22084 14.6883 2.17169 14.8366 2.12256 14.985L2.61572 14.7368C2.85714 14.6151 3.09863 14.4935 3.34012 14.3719C3.58099 14.2507 3.82186 14.1294 4.06266 14.0081L4.40902 13.8337C4.42474 13.8257 4.44104 13.8164 4.45775 13.8069C4.51759 13.7728 4.58265 13.7356 4.64501 13.7481C4.76613 13.7723 4.88708 13.7972 5.00801 13.8221C5.08094 13.8372 5.15386 13.8522 5.22681 13.867C6.06287 14.0373 6.88508 14.1348 7.73859 14.0675C7.4486 13.0669 7.44915 12.0016 7.7559 11.0045C8.09853 9.88624 8.81438 8.89831 9.74448 8.19773C11.0171 7.23915 12.6431 6.81493 14.2212 6.99199C14.0895 6.4081 13.8688 5.85148 13.5578 5.34061ZM4.77922 5.02147C4.28094 5.02147 3.71299 5.35514 3.71299 5.90829C3.71299 6.46088 4.28066 6.79844 4.77922 6.79844C5.29233 6.79844 5.66293 6.42291 5.66293 5.90829C5.66293 5.39311 5.29205 5.02147 4.77922 5.02147ZM10.6158 5.90829C10.6158 6.42444 10.2434 6.79844 9.7296 6.79844C9.23076 6.79844 8.66641 6.46032 8.66641 5.90829C8.66641 5.3557 9.23104 5.02147 9.7296 5.02147C10.2431 5.02147 10.6158 5.39158 10.6158 5.90829ZM17.7911 8.53846C15.3552 6.80489 11.734 6.93368 9.53048 9.01108C8.77779 9.72181 8.22909 10.6485 8.04061 11.6744C7.78288 13.0799 8.22536 14.5441 9.17304 15.605C10.0674 16.6063 11.2889 17.2564 12.5986 17.5166C13.4216 17.6806 14.2559 17.6931 15.0799 17.5344C15.2863 17.4948 15.4911 17.4481 15.6954 17.3986C15.7826 17.3774 15.8697 17.3559 15.9568 17.334C15.9655 17.3319 15.9784 17.3272 15.9934 17.3219C16.0359 17.3068 16.0949 17.2858 16.118 17.2984C16.2476 17.3695 16.3771 17.4408 16.5066 17.5122L17.0557 17.8142L17.0577 17.8153L17.0598 17.8164C17.3912 17.9986 17.7227 18.1809 18.054 18.3634C17.9748 18.0977 17.895 17.832 17.8153 17.5664L17.8146 17.5641L17.6749 17.0981L17.5814 16.7863L17.5332 16.6257C17.5159 16.5675 17.5927 16.5183 17.6556 16.4779C17.6753 16.4653 17.6937 16.4535 17.7073 16.4426C18.0608 16.1622 18.3952 15.8558 18.6963 15.5191C19.1832 14.9747 19.5895 14.3498 19.8161 13.6505C20.0122 13.039 20.0488 12.392 19.9377 11.7604C19.7098 10.438 18.8643 9.30511 17.7911 8.53846ZM15.2396 11.0049C15.1595 10.6088 15.5334 10.1787 15.931 10.1787C16.3063 10.1787 16.7409 10.3931 16.8096 10.7989C16.8724 11.1695 16.556 11.4696 16.227 11.5617C15.8032 11.6802 15.3326 11.4649 15.2396 11.0049ZM12.0348 10.1787C11.6369 10.1787 11.2573 10.6064 11.3385 11.0049C11.4325 11.4667 11.9081 11.68 12.3327 11.5617C12.6626 11.4696 12.9753 11.1695 12.9134 10.7989C12.8453 10.3914 12.4112 10.1787 12.0348 10.1787Z" data-v-b7c4e7d2 data-v-b7c4e7d2></path></symbol><symbol id="icon-weibo" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" data-v-b7c4e7d2 data-v-b7c4e7d2><path fill-rule="evenodd" clip-rule="evenodd" d="M-0.000244141 13.0984C-0.000244141 8.70757 6.6145 3.5004 9.18008 4.57052C10.1717 4.98415 9.97381 6.1693 9.85415 6.88576C9.8069 7.16863 9.77186 7.37844 9.82705 7.43887C9.92921 7.55074 10.2955 7.42054 10.7994 7.2414C11.8362 6.87286 13.4557 6.2972 14.5566 7.19617C15.2665 7.77576 14.9657 8.72382 14.7905 9.27603C14.7289 9.4701 14.6829 9.61528 14.7017 9.6784C14.741 9.81053 14.9858 9.91133 15.317 10.0477C15.926 10.2984 16.8269 10.6692 17.2784 11.5759C18.3716 13.7713 15.2036 18.2504 8.62234 18.2504C3.25024 18.2504 -0.000244141 15.6688 -0.000244141 13.0984ZM8.45309 17.057C11.7733 16.7393 14.2944 14.7397 14.0842 12.5908C13.874 10.4418 11.012 8.95732 7.69179 9.27503C4.37159 9.59274 1.85045 11.5924 2.06068 13.7413C2.2709 15.8902 5.13288 17.3747 8.45309 17.057Z" data-v-b7c4e7d2 data-v-b7c4e7d2></path><path fill-rule="evenodd" clip-rule="evenodd" d="M10.7098 12.7012C11.1162 14.1374 10.0604 15.6852 8.35157 16.1581C6.64275 16.6311 4.92801 15.8502 4.5216 14.4139C4.11518 12.9777 5.171 11.4299 6.87982 10.957C8.58865 10.484 10.3034 11.2649 10.7098 12.7012ZM7.67026 13.6265C7.89619 14.1072 7.61751 14.7092 7.04779 14.9711C6.47808 15.2331 5.83308 15.0558 5.60715 14.5751C5.38122 14.0945 5.6599 13.4925 6.22962 13.2306C6.79933 12.9686 7.44433 13.1459 7.67026 13.6265ZM8.41746 13.3766C8.63945 13.2745 8.74804 13.0399 8.66001 12.8526C8.57197 12.6654 8.32065 12.5963 8.09866 12.6984C7.87667 12.8004 7.76808 13.035 7.85612 13.2223C7.94415 13.4095 8.19547 13.4786 8.41746 13.3766Z" data-v-b7c4e7d2 data-v-b7c4e7d2></path><path d="M13.648 3.54836C13.9523 3.47388 14.2712 3.43418 14.6004 3.43418C16.7813 3.43418 18.5492 5.18267 18.5492 7.33955C18.5492 7.81593 18.4633 8.27085 18.3066 8.69104C18.168 9.06261 18.3602 9.47493 18.7359 9.61199C19.1116 9.74904 19.5285 9.55894 19.6671 9.18737C19.8822 8.61063 19.9993 7.98781 19.9993 7.33955C19.9993 4.3906 17.5822 2 14.6004 2C14.1528 2 13.717 2.05403 13.2996 2.15619C12.9109 2.25133 12.6738 2.64011 12.77 3.02455C12.8662 3.40899 13.2593 3.6435 13.648 3.54836Z" data-v-b7c4e7d2 data-v-b7c4e7d2></path><path d="M14.2887 6.05162C14.388 6.02824 14.4923 6.01569 14.6004 6.01569C15.3397 6.01569 15.939 6.6084 15.939 7.33955C15.939 7.49914 15.9108 7.65062 15.8596 7.7904C15.7232 8.16277 15.9179 8.57396 16.2944 8.70881C16.6709 8.84366 17.0867 8.65112 17.2231 8.27875C17.3307 7.98466 17.3891 7.66805 17.3891 7.33955C17.3891 5.81633 16.1406 4.58152 14.6004 4.58152C14.3784 4.58152 14.1614 4.60734 13.9529 4.65643C13.5633 4.74813 13.3227 5.1348 13.4154 5.52008C13.5082 5.90535 13.8991 6.14333 14.2887 6.05162Z" data-v-b7c4e7d2 data-v-b7c4e7d2></path></symbol><symbol id="icon-qq" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" data-v-b7c4e7d2 data-v-b7c4e7d2><path d="M11.8841 17.1943C11.1815 17.1943 10.5625 17.2136 10.0541 17.26C9.44625 17.2112 8.8365 17.1898 8.22671 17.1956C6.20498 17.1956 4.40588 17.9613 4.40588 18.5263C4.40588 19.0681 5.89998 19.0076 7.91657 18.987C8.64426 18.985 9.3699 18.9096 10.0824 18.7618C10.6796 18.8879 11.4079 18.9677 12.193 18.9741C14.2095 18.9947 15.7024 19.0552 15.7024 18.5173C15.7024 17.9549 13.9045 17.1943 11.8841 17.1943V17.1943Z" data-v-b7c4e7d2 data-v-b7c4e7d2></path><path d="M16.9138 11.6311C16.5346 10.6112 16.1212 9.60428 15.6745 8.61206C15.6951 8.37141 15.7054 8.12818 15.7054 7.8811C15.7054 4.08086 13.7622 1 10.0649 1C6.36759 1 4.42307 4.08086 4.42307 7.8811C4.42307 8.11274 4.43208 8.34052 4.45138 8.56573C3.99804 9.5756 3.57913 10.6006 3.19536 11.6389C2.41678 13.7494 2.38203 15.6566 2.65357 15.7982C2.84661 15.8985 3.54797 15.1611 4.21845 13.9669C4.66115 16.7801 6.53102 18.8842 10.0649 18.8842C13.5871 18.8842 15.457 16.7916 15.9074 13.99C16.5728 15.1611 17.2664 15.8818 17.4569 15.7814C17.7284 15.6399 17.6937 13.7365 16.9138 11.6311V11.6311Z" data-v-b7c4e7d2 data-v-b7c4e7d2></path><path d="M8.5542 3.2522C8.00598 3.26507 7.57358 3.90981 7.58902 4.69739C7.60447 5.48369 8.06132 6.11299 8.60954 6.1027C9.15776 6.0924 9.59016 5.44637 9.57472 4.65879C9.56056 3.87249 9.10243 3.24319 8.5542 3.25348V3.2522ZM11.5862 3.26764C11.0315 3.25734 10.5695 3.88278 10.5541 4.66651C10.5386 5.44895 10.9749 6.0924 11.5308 6.1027C12.0842 6.11299 12.5475 5.48755 12.5629 4.70512C12.5784 3.92139 12.1408 3.27794 11.5862 3.26764V3.26764Z" data-v-b7c4e7d2 data-v-b7c4e7d2></path><path d="M13.6704 9.57861C12.5971 9.76521 11.354 9.87074 10.0285 9.87074C8.7287 9.87074 7.50742 9.76779 6.44959 9.58762C5.71605 10.4962 5.65942 11.8307 5.65942 13.3184C5.65942 16.0505 7.20371 18.2665 10.0645 18.2665C12.924 18.2665 14.4696 16.0505 14.4696 13.3184C14.4696 11.8243 14.4104 10.4859 13.6704 9.57861V9.57861Z" data-v-b7c4e7d2 data-v-b7c4e7d2></path><path d="M10.0628 6.56616C8.14273 6.56616 6.58557 6.95223 6.58557 7.26238C6.58557 7.57124 8.62146 8.42188 10.0641 8.42188C11.5054 8.42188 13.5413 7.55065 13.5413 7.26238C13.5413 6.97411 11.9842 6.56745 10.0641 6.56745L10.0628 6.56616Z" data-v-b7c4e7d2 data-v-b7c4e7d2></path><path d="M15.6744 8.6121L15.6757 8.59151C14.264 9.05866 12.2718 9.35078 10.0648 9.35078C7.8513 9.35078 5.85402 9.05737 4.441 8.58765C4.14115 9.25684 3.85546 9.93375 3.58521 10.6171C4.45644 10.9054 5.43192 11.1357 6.48332 11.2992V13.8858C6.48332 13.8858 7.22715 14.0235 7.92981 14.0531C8.42784 14.0737 8.95676 13.9888 8.95676 13.9888V11.5398C9.32095 11.5565 9.6903 11.5656 10.0635 11.5656C12.4919 11.5656 14.7311 11.2142 16.5251 10.6222C16.2566 9.94593 15.9729 9.27571 15.6744 8.6121V8.6121Z" data-v-b7c4e7d2 data-v-b7c4e7d2></path><path d="M8.87981 4.24829C8.63787 4.24829 8.44226 4.53656 8.44226 4.89174C8.44226 5.24693 8.63787 5.5352 8.87981 5.5352C9.12046 5.5352 9.31736 5.24693 9.31736 4.89174C9.31736 4.53656 9.12046 4.24829 8.87981 4.24829V4.24829ZM12.0997 4.65624C12.0997 4.65624 11.9246 4.41816 11.4819 4.48122C11.0444 4.54428 10.8745 4.83126 10.8423 4.86215C10.8423 4.86215 10.7381 5.0243 10.8115 5.12467C10.8848 5.22505 11.0174 5.06676 11.0174 5.06676C11.0174 5.06676 11.2194 4.78364 11.4806 4.77335C11.6273 4.76349 11.7729 4.80489 11.8925 4.89046C11.8925 4.89046 12.0211 4.99856 12.0984 4.89046C12.1769 4.78364 12.0997 4.65624 12.0997 4.65624V4.65624Z" data-v-b7c4e7d2 data-v-b7c4e7d2></path></symbol></svg> <div badge="8" class="panel-btn with-badge" data-v-b7c4e7d2><svg class="sprite-icon icon-zan" data-v-0f838daa data-v-b7c4e7d2><use xlink:href="#icon-zan" data-v-0f838daa></use></svg></div> <div badge="1" class="panel-btn with-badge" data-v-b7c4e7d2><svg class="sprite-icon icon-comment" data-v-0f838daa data-v-b7c4e7d2><use xlink:href="#icon-comment" data-v-0f838daa></use></svg></div> <div class="panel-btn" data-v-b7c4e7d2><svg class="sprite-icon icon-collect" data-v-0f838daa data-v-b7c4e7d2><use xlink:href="#icon-collect" data-v-0f838daa></use></svg> <div class="collect-popover" data-v-d0b73df6 data-v-b7c4e7d2><div class="title" data-v-d0b73df6>收藏成功！</div> <div class="sub-title" data-v-d0b73df6>
    已添加到「」，
    <span class="modify-btn" data-v-d0b73df6>点击更改</span></div></div> <div data-transfer="true" class="collection-list-modal byte-modal" data-v-190ec4f0 data-v-b7c4e7d2><div class="byte-modal__mask" style="z-index:15598;display:none;"></div><div class="byte-modal__wrapper" style="z-index:15598;display:none;"><div class="byte-modal__content" style="width:520px;"><!----><div class="byte-modal__body"></div><!----></div></div></div> <!----></div> <div class="share-btn panel-btn" data-v-b7c4e7d2><svg class="sprite-icon icon-share" data-v-0f838daa data-v-b7c4e7d2><use xlink:href="#icon-share" data-v-0f838daa></use></svg> <div class="share-popup" data-v-b7c4e7d2><ul data-v-b7c4e7d2><li class="share-item wechat" data-v-b7c4e7d2><svg class="sprite-icon share-icon icon-wechat" data-v-0f838daa data-v-b7c4e7d2><use xlink:href="#icon-wechat" data-v-0f838daa></use></svg> <span class="share-item-title" data-v-b7c4e7d2>微信</span> <div class="wechat-qrcode" data-v-b7c4e7d2><img src="" class="wechat-qrcode-img" style="display:none;" data-v-b7c4e7d2> <span class="wechat-qrcode-title" data-v-b7c4e7d2>微信扫码分享</span></div></li> <li class="share-item weibo" data-v-b7c4e7d2><svg class="sprite-icon share-icon icon-weibo" data-v-0f838daa data-v-b7c4e7d2><use xlink:href="#icon-weibo" data-v-0f838daa></use></svg> <span class="share-item-title" data-v-b7c4e7d2>新浪微博</span></li> <li class="share-item qq" data-v-b7c4e7d2><svg class="sprite-icon share-icon icon-qq" data-v-0f838daa data-v-b7c4e7d2><use xlink:href="#icon-qq" data-v-0f838daa></use></svg> <span class="share-item-title" data-v-b7c4e7d2>QQ</span></li></ul></div></div> <div class="divider" data-v-b7c4e7d2></div> <div class="panel-btn" data-v-b7c4e7d2><svg class="sprite-icon icon-report" data-v-0f838daa data-v-b7c4e7d2><use xlink:href="#icon-report" data-v-0f838daa></use></svg></div> <span class="tooltip" data-v-b7c4e7d2><div class="byte-tooltip byte-tooltip--dark" style="display:none;">
        沉浸阅读
      </div><span class="byte-tooltip__wrapper"><div class="panel-btn" data-v-b7c4e7d2><svg class="sprite-icon icon-immerse" data-v-0f838daa data-v-b7c4e7d2><use xlink:href="#icon-immerse" data-v-0f838daa></use></svg></div></span></span></div></div> <!----></main> <!----></div> <!----> <div class="global-component-box"><!----> <!----> <!----> <!----> <!----> <!----> <!----></div> <!----><!----><!----><!----><!----><!----><!----> <!----> <!----> <!----><!----><!----></div></div></div><script>window.__NUXT__=(function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C){u.loading=a;u.skeleton=b;u.cursor=f;u.data=[];u.total=d;u.hasMore=b;return {layout:"default",data:[{skipSSR:a,additionalDataUseCSR:b}],fetch:[{bdPageUrlForNav:"https:\u002F\u002Fbd.juejin.cn?utm_campaign=bd&utm_source=web&utm_medium=nav",queryString:e,isShowUserDropdownList:a,isShowAddMoreList:a,isFocus:a,isPhoneMenuShow:a,visibleBadge:a,placeholder:e,hiddenProperty:"hidden",searchHistoryVisible:a,searchHistoryItems:[],tabBadge:c,isChangePlaceholder:b,showMallBridge:a,isGuideLoginHeaderVisible:a,loginGuideTimer:c,loginGuideStartTime:d,loginGuideNextTime:d,needLoginGuide:a},{articleBanner:{url:"https:\u002F\u002Fjuejin.cn\u002Fextension\u002F?utm_source=standalone&utm_medium=post&utm_campaign=extension_promotion",title:"安装掘金浏览器插件",content:"多内容聚合浏览、多引擎快捷搜索、多工具便捷提效、多模式随心畅享，你想要的，这里都有！"},showExtension:b}],error:c,state:{view:{activityIndex:{activityList:[],pageInfo:{hasNextPage:a,endCursor:e},afterPosition:e,activityListIsLoading:b,activityListIsError:a,userActivityList:[],placeholder:e,actionType:{FETCH:"@\u002Fview\u002Factivity-index\u002FFETCH",FETCH_RECOMMEND_LIST:"@\u002Fview\u002Factivity-index\u002FFETCH_RECOMMEND_LIST",RESET_ACTIVITY_LIST:"@\u002Fview\u002Factivity-index\u002FRESET_ACTIVITY_LIST",FETCH_USER_ACTIVITY_LIST:"@\u002Fview\u002Factivity-index\u002FFETCH_USER_ACTIVITY_LIST",FETCH_NEW_COUNT:"@\u002Fview\u002Factivity-index\u002FFETCH_NEW_COUNT",DELETE_ACTIVITY:"@\u002Fview\u002Factivity-index\u002FDELETE_ACTIVITY",TOGGLE_FOLLOW_USER:"@\u002Fview\u002Factivity-index\u002FTOGGLE_FOLLOW_USER",FETCH_ENTRY_COMMENT_LIST:"@\u002Fview\u002Factivity-index\u002FFETCH_ENTRY_COMMENT_LIST",UPDATE_LIST_LOADING:"@\u002Fview\u002Factivity-index\u002FUPDATE_LIST_LOADING",RESET:"@\u002Fview\u002Factivity-index\u002FRESET"},hotList:{list:[],after:e,loading:a,hasNextPage:a,actionType:{UPDATE_STATE:"@\u002Fview\u002Factivity-index\u002Fhot-list\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Factivity-index\u002Fhot-list\u002FFETCH_MORE",FETCH:"@\u002Fview\u002Factivity-index\u002Fhot-list\u002FFETCH",RESET:"@\u002Fview\u002Factivity-index\u002Fhot-list\u002FRESET"}},sidebar:{bannerList:[],actionType:{RESET:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002FRESET",UPDATE_STATE:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002FUPDATE_STATE",FETCH_BANNER:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002FFETCH_BANNER"},recommend:{pageSize:h,page:d,total:d,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:b,canNext:b,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Frecommend-topic-list\u002FUPDATE",FETCH:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Frecommend-topic-list\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Frecommend-topic-list\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Frecommend-topic-list\u002FFETCH_MORE",RESET:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Frecommend-topic-list\u002FRESET"},after:d},followed:{pageSize:h,page:d,total:d,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:b,canNext:b,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Ffollowed-topic-list\u002FUPDATE",FETCH:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Ffollowed-topic-list\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Ffollowed-topic-list\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Ffollowed-topic-list\u002FFETCH_MORE",RESET:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Ffollowed-topic-list\u002FRESET"},after:d},recommendPin:{list:[],after:e,loading:a,hasNextPage:b,actionType:{UPDATE_STATE:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Frecommend-pin-list\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Frecommend-pin-list\u002FFETCH_MORE",FETCH:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Frecommend-pin-list\u002FFETCH",RESET:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Frecommend-pin-list\u002FRESET"}}},topicPinList:{pageSize:h,page:g,total:d,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:b,canNext:b,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002Factivity-index\u002Ftopic-pin-list\u002FUPDATE",FETCH:"@\u002Fview\u002Factivity-index\u002Ftopic-pin-list\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002Factivity-index\u002Ftopic-pin-list\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002Factivity-index\u002Ftopic-pin-list\u002FFETCH_MORE",RESET:"@\u002Fview\u002Factivity-index\u002Ftopic-pin-list\u002FRESET"},topicId:e,navList:[{type:k,name:k,title:"推荐 ",id:k},{type:l,name:l,title:"热门 ",id:l},{type:s,name:s,title:"关注 ",id:s},{type:i,name:"opensource",title:"开源推荐 ",id:"5c09ea2b092dcb42c740fe73"},{type:i,name:"recruitment",title:"内推招聘",id:"5abb61e1092dcb4620ca3322"},{type:i,name:"dating",title:"掘金相亲",id:"5abcaa67092dcb4620ca335c"},{type:i,name:"slacking",title:"上班摸鱼",id:"5c106be9092dcb2cc5de7257"},{type:i,name:"app",title:"应用安利",id:"5b514af1092dcb61bd72800d"},{type:i,name:"tool",title:"开发工具",id:"5abb67d2092dcb4620ca3324"},{type:i,name:"news",title:"New资讯",id:"5c46a17f092dcb4737217152"}],sortType:t}},search:{search_result_from:d,query:e,list:[],linkList:[],loading:a,skeleton:b,actionType:{FETCH:"@\u002Fview\u002Fsearch\u002FFETCH",FETCH_MORE:"@\u002Fview\u002Fsearch\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fsearch\u002FRESET"}},columnIndex:{list:{pageSize:h,page:g,total:d,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:b,canNext:b,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002FcolumnIndex\u002Flist\u002FUPDATE",FETCH:"@\u002Fview\u002FcolumnIndex\u002Flist\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002FcolumnIndex\u002Flist\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002FcolumnIndex\u002Flist\u002FFETCH_MORE",RESET:"@\u002Fview\u002FcolumnIndex\u002Flist\u002FRESET"},sort:m,category:"all"},hotList:{pageSize:h,page:g,total:d,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:b,canNext:b,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002FcolumnIndex\u002FhotList\u002FUPDATE",FETCH:"@\u002Fview\u002FcolumnIndex\u002FhotList\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002FcolumnIndex\u002FhotList\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002FcolumnIndex\u002FhotList\u002FFETCH_MORE",RESET:"@\u002Fview\u002FcolumnIndex\u002FhotList\u002FRESET"}}},timelineIndex:{tdkTemplates:[],categoryNavList:[],tagNavList:[],splitTagList:[],timelineAdList:[],list:[],sort:t,category:k,categoryId:e,tagId:e,tag:"全部",actionType:{FETCH_TIMELINE_LIST:"@\u002Fview\u002FtimelineIndex\u002FFETCH_TIMELINE_LIST",FETCH_CATEGORY_LIST:"@\u002Fview\u002FtimelineIndex\u002FFETCH_CATEGORY_LIST",FETCH_TAG_LIST:"@\u002Fview\u002FtimelineIndex\u002FFETCH_TAG_LIST",DELETE_ENTRY:"@\u002Fview\u002FtimelineIndex\u002FDELETE_ENTRY",DELETE_USER_ENTRIES:"@\u002Fview\u002FtimelineIndex\u002FDELETE_USER_ENTRIES",DELETE_TAG_ENTRIES:"@\u002Fview\u002FtimelineIndex\u002FDELETE_TAG_ENTRIES",FETCH_MORE:"@\u002Fview\u002FtimelineIndex\u002FFETCH_MORE",FETCH:"@\u002Fview\u002FtimelineIndex\u002FFETCH",RESET:"@\u002Fview\u002FtimelineIndex\u002FRESET"},serverRenderTimelineList:a,timelineList:{list:[],cursor:f,skeleton:b,loading:a,hasMore:b,categoryId:e,tagId:e,sort:e,actionType:{UPDATE_STATE:"timeline-list\u002FUPDATE_STATE",FETCH_MORE:"timeline-list\u002FFETCH_MORE",FETCH:"timeline-list\u002FFETCH",RESET:"timeline-list\u002FRESET"}},recommendList:{list:[],cursor:f,loading:a,skeleton:b,hasMore:b,actionType:{UPDATE_STATE:"recommend-list\u002FUPDATE_STATE",FETCH_MORE:"recommend-list\u002FFETCH_MORE",FETCH:"recommend-list\u002FFETCH",RESET:"recommend-list\u002FRESET"}},followingList:{list:[],cursor:f,skeleton:b,loading:a,hasMore:b,actionType:{UPDATE_STATE:"following-list\u002FUPDATE_STATE",FETCH_MORE:"following-list\u002FFETCH_MORE",FETCH:"following-list\u002FFETCH",RESET:"following-list\u002FRESET"}}},subscribe:{subscribed:{list:[],cursor:f,skeleton:b,loading:a,hasMore:a,actionType:{UPDATE_STATE:"view\u002Fsubscribe\u002Fsubscribed\u002Flist\u002FUPDATE_STATE",FETCH_MORE:"view\u002Fsubscribe\u002Fsubscribed\u002Flist\u002FFETCH_MORE",FETCH:"view\u002Fsubscribe\u002Fsubscribed\u002Flist\u002FFETCH",RESET:"view\u002Fsubscribe\u002Fsubscribed\u002Flist\u002FRESET"}},all:{list:[],cursor:f,loading:a,skeleton:b,hasMore:a,linkList:e,actionType:{UPDATE_STATE:"view\u002Fsubscribe\u002Fall\u002Flist\u002FUPDATE_STATE",FETCH_MORE:"view\u002Fsubscribe\u002Fall\u002Flist\u002FFETCH_MORE",FETCH:"view\u002Fsubscribe\u002Fall\u002Flist\u002FFETCH",RESET:"view\u002Fsubscribe\u002Fall\u002Flist\u002FRESET"}}},entryPublic:{entry:{user:{}},relatedEntryList:[],relatedCollectionList:[],actionType:{FETCH:"@\u002Fview\u002FentryPublic\u002FFETCH",RESET:"@\u002Fview\u002FentryPublic\u002FRESET"}},user:{user:{},serverRendered:a,userAnnuals:[],actionType:{FETCH:"@\u002Fview\u002Fuser\u002FFETCH",RESET:"@\u002Fview\u002Fuser\u002FRESET",UPDATE:"@\u002Fview\u002Fuser\u002FUPDATE",FETCH_ANNUALS:"@\u002Fview\u002Fuser\u002FFETCH_ANNUALS"},detailList:{actionType:{RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FRESET"},likeList:{list:[],cursor:f,hasMore:a,loading:a,skeleton:b,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FlikePostList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FlikePostList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FlikePostList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FlikePostList\u002FRESET"}},postList:{list:[],hasMore:a,skeleton:a,loading:a,sort:m,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FpostList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FpostList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FpostList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FpostList\u002FRESET"}},searchList:{list:[],hasMore:a,skeleton:a,loading:a,key_word:e,search_type:d,cursor:f,isPostSearch:a,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FsearchList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FsearchList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FsearchList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FsearchList\u002FRESET"}},tagList:{list:[],loading:a,skeleton:b,hasMore:a,cursor:f,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FtagList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FtagList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FtagList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FtagList\u002FRESET"}},collectionList:{list:[],userId:e,skeleton:b,hasMore:a,cursor:f,type:"created",loading:a,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FcollectionList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FcollectionList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FcollectionList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FcollectionList\u002FRESET",TOGGLE_FOLLOW_COLLECTION:"@\u002Fview\u002Fuser\u002FdetailList\u002FcollectionList\u002FTOGGLE_FOLLOW_COLLECTION",FOLLOW_COLLECTION:"@\u002Fview\u002Fuser\u002FdetailList\u002FcollectionList\u002FFOLLOW_COLLECTION",UNFOLLOW_COLLECTION:"@\u002Fview\u002Fuser\u002FdetailList\u002FcollectionList\u002FUNFOLLOW_COLLECTION",DELELTE_COLLECTION:"@\u002Fview\u002Fuser\u002FdetailList\u002FcollectionList\u002FDELELTE_COLLECTION",ADD_COLLECTION:"@\u002Fview\u002Fuser\u002FdetailList\u002FcollectionList\u002FADD_COLLECTION",EDIT_COLLECTION:"@\u002Fview\u002Fuser\u002FdetailList\u002FcollectionList\u002FEDIT_COLLECTION"}},followerList:{list:[],cursor:f,hasMore:a,loading:a,skeleton:a,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FfollowerList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FfollowerList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FfollowerList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FfollowerList\u002FRESET"}},followingList:{list:[],cursor:f,hasMore:a,skeleton:a,loading:a,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FfollowingList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FfollowingList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FfollowingList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FfollowingList\u002FRESET"}},followingTeamsList:{list:[],cursor:f,hasMore:a,skeleton:a,loading:a,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FfollowingTeamsList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FfollowingTeamsList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FfollowingTeamsList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FfollowingTeamsList\u002FRESET"}},activityList:{list:[],cursor:f,hasMore:a,loading:a,skeleton:a,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FactivityList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FactivityList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FactivityList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FactivityList\u002FRESET"}},bookList:{list:[],cursor:f,skeleton:b,hasMore:a,loading:a,type:"bought",actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FbookList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FbookList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FbookList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FbookList\u002FRESET"}},pinList:{list:[],hasMore:a,loading:a,skeleton:b,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FpinList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FpinList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FpinList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FpinList\u002FRESET"}},courseList:{list:[],hasMore:a,loading:a,skeleton:b,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FcourseList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FcourseList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FcourseList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FcourseList\u002FRESET"}},pinPraisedList:{list:[],cursor:f,hasMore:a,loading:a,skeleton:b,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FpinPraisedList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FpinPraisedList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FpinPraisedList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FpinPraisedList\u002FRESET"}},eventList:{list:[],cursor:f,hasMore:a,loading:a,skeleton:a,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FeventList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FeventList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FeventList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FeventList\u002FRESET"}},selfColumnList:{list:[],hasMore:a,skeleton:a,loading:a,cursor:f,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FcolumnList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FcolumnList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FcolumnList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FcolumnList\u002FRESET"}},columnFollowedList:{list:[],hasMore:a,skeleton:a,loading:a,cursor:f,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FcolumnFollowedList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FcolumnFollowedList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FcolumnFollowedList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FcolumnFollowedList\u002FRESET",FILTER:"@\u002Fview\u002Fuser\u002FdetailList\u002FcolumnFollowedList\u002FFILTER"}},realtimes:{list:[],cursor:f,hasMore:a,loading:a,skeleton:a,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002Frealtimes\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002Frealtimes\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002Frealtimes\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002Frealtimes\u002FRESET",DELETE:"@\u002Fview\u002Fuser\u002FdetailList\u002Frealtimes\u002FDELETE"}},realtimeliked:{list:[],cursor:f,hasMore:a,loading:a,skeleton:a,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002Frealtimeliked\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002Frealtimeliked\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002Frealtimeliked\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002Frealtimeliked\u002FRESET",DELETE:"@\u002Fview\u002Fuser\u002FdetailList\u002Frealtimeliked\u002FDELETE"}}}},tag:{tag:{},actionType:{FETCH:"@\u002Fview\u002Ftag\u002FFETCH",FETCH_LIST:"@\u002Fview\u002Ftag\u002FFETCH_LIST",RESET:"@\u002Fview\u002Ftag\u002FRESET"},list:{list:[],cursor:f,loading:a,skeleton:a,hasMore:a,actionType:{UPDATE_STATE:"@\u002Fview\u002Ftag\u002Flist\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Ftag\u002Flist\u002FFETCH_MORE",FETCH:"@\u002Fview\u002Ftag\u002Flist\u002FFETCH",RESET:"@\u002Fview\u002Ftag\u002Flist\u002FRESET"}}},notification:{user:{actionType:{READ_ALL:"@\u002Fview\u002Fnotification\u002Fuser\u002FREAD_ALL",RESET:"@\u002Fview\u002Fnotification\u002Fuser\u002FRESET"},listState:{list:[],cursor:f,hasMore:a,isLoading:a,messageType:3,msgTotal:d,msgSubMap:{"1":d,"2":d,"3":d,"4":d}},list:{pageSize:h,page:g,total:d,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:b,canNext:b,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002Fnotification\u002Fuser\u002Flist\u002FUPDATE",FETCH:"@\u002Fview\u002Fnotification\u002Fuser\u002Flist\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002Fnotification\u002Fuser\u002Flist\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002Fnotification\u002Fuser\u002Flist\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fnotification\u002Fuser\u002Flist\u002FRESET"}}},system:{actionType:{READ_ALL:"@\u002Fview\u002Fnotification\u002Fsystem\u002FREAD_ALL",RESET:"@\u002Fview\u002Fnotification\u002Fsystem\u002FRESET"},list:{pageSize:h,page:g,total:d,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:b,canNext:b,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002Fnotification\u002Fsystem\u002Flist\u002FUPDATE",FETCH:"@\u002Fview\u002Fnotification\u002Fsystem\u002Flist\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002Fnotification\u002Fsystem\u002Flist\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002Fnotification\u002Fsystem\u002Flist\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fnotification\u002Fsystem\u002Flist\u002FRESET"}}}},column:{renderPost:b,serverRenderList:a,column:{id:w},entry:{id:w,screenshot:void 0,liked:a,article_id:w,article_info:{article_id:w,user_id:"3227821871208174",category_id:"6809637769959178254",tag_ids:[6809640445233070000],visible_level:d,link_url:"https:\u002F\u002Fjuejin.im\u002Fpost\u002F6844903953566531597",cover_image:e,is_gfw:d,title:"HashMap源码解析，扩容机制及其思考",brief_content:"位运算是对整数在内存中的二进制位进行操作。 在hashMap源码中有很多使用位运算的地方。例如: 我们都知道&在java中表示与操作&表示按位与，这里的位是指二进制位。都为1才为真(1),否则结果为0，举个简单的例子 在Java中，所有数据的表示方法都是以补码的形式表示，如果没…",is_english:d,is_original:g,user_index:d,original_type:d,original_author:e,content:"\u003Ch1\u003E1.概述\u003C\u002Fh1\u003E\u003Cblockquote\u003E\u003Cp\u003EHashMap是日常java开发中常用的类之一，是java设计中非常经典的一个类，它巧妙的设计思想与实现，还有涉及到的数据结构和算法，，值得我们去深入的学习。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cblockquote\u003E\u003Cp\u003E简单来说，HashMap就是一个散列表，是基于哈希表的Map接口实现，它存储的内容是键值对 (key-value) 映射，并且键值允许为null(键的话只允许一个为null)。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Ch3\u003E1.1 注意事项\u003C\u002Fh3\u003E\u003Cblockquote\u003E\u003Cp\u003E①根据键的hashCode存储数据。(String，和Integer、Long、Double这样的包装类都重写了hashCode方法，String比较特殊根据ascil码还有自己的算法计算，Double做位移运算【具体看源码的hashcode实现】，Integer，Long包装类则是自身大小int值)，\u003Cbr\u003EHashMap中的结构不能有基本类型，一方面是基本类型没有hashCode方法，还有HashMap是泛型结构，泛型要求包容对象类型，而基本类型在java中不属于对象。\u003Cbr\u003E②HashMap的存储单位是Node&lt;k,v&gt;,可以认作为节点。\u003Cbr\u003E③Hashmap中的扩容的个数是针对size(内部元素(节点)总个数)，而不是数组的个数。比如说初始容量为16，第十三个节点put进来，不管前面十二个占的数组位置如何，就开始扩容。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Ch3\u003E1.2 hashmap几个特征\u003C\u002Fh3\u003E\u003Ctable\u003E\u003Cthead\u003E\u003Ctr\u003E\u003Cth\u003E特征\u003C\u002Fth\u003E\u003Cth\u003E说明\u003C\u002Fth\u003E\u003C\u002Ftr\u003E\u003C\u002Fthead\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E是否允许重复数据\u003C\u002Ftd\u003E\u003Ctd\u003Ekey如果重复会覆盖，value允许重复\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003EhashMap是否有序\u003C\u002Ftd\u003E\u003Ctd\u003E无序，这里的无序指的是遍历HashMap的时候，得到的顺序大都跟put进去的顺序不一致\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003EhashMap是否线程安全\u003C\u002Ftd\u003E\u003Ctd\u003E非线程安全，因为里面的实现不是同步的，如果想要线程安全，推荐使用\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E键值是否允许为空\u003C\u002Ftd\u003E\u003Ctd\u003Ekey和value都允许为空，但只允许一个为空\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\u003Ch1\u003E2.一些概念\u003C\u002Fh1\u003E\u003Ch3\u003E2.1.位运算\u003C\u002Fh3\u003E\u003Cp\u003E位运算是对整数在内存中的二进制位进行操作。\u003C\u002Fp\u003E\u003Cp\u003E在java中 &gt;&gt; 表示右移 若该数为正，则高位补0，若为负数，高位补1\u003C\u002Fp\u003E\u003Cp\u003E&lt;&lt;表示左移 跟右移相反 如果是正数在低位补0\u003C\u002Fp\u003E\u003Cp\u003E例如20的二进制为0001 0100 20&gt;&gt;2为 0101 0000 结果为5(左高右低)\u003C\u002Fp\u003E\u003Cp\u003E20&lt;&lt;2 为 0101 0000 则为80\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003Ejava中&gt;&gt;&gt;和&gt;&gt;的区别\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E&gt;&gt;&gt;表示无符号右移，也叫逻辑右移。不管数字是正数还是负数，高位都是补0\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E在hashMap源码中有很多使用位运算的地方。例如:\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E\u002F\u002F之所以用1 &lt;&lt; 4不直接用16，0000 0001 -&gt; 0001 0000 则为16，如果用16的话最后其实也是要转换成0和1这样的二进制，位运算的计算在计算机中是非常快的，直接用位运算表示大小以二进制形式去运行，在jvm中效率更高。\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;  \u002F\u002F初始化容量\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cb\u003E注意:左移没有&lt;&lt;&lt;运算符\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Ch3\u003E2.2 位运算符-(与(&amp;)、非(~)、,或(|)、异或(^))\u003C\u002Fh3\u003E\u003Ch5\u003E①与运算(&amp;)\u003C\u002Fh5\u003E\u003Cp\u003E我们都知道&amp;在java中表示与操作&amp;表示按位与，这里的位是指二进制位。都为1才为真(1),否则结果为0，举个简单的例子\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003ESystem.out.println(9 &amp; 8); \u002F\u002F1&amp;1=1，1&amp;0 0&amp;1 0&amp;0都=0，因此1001 1000 -&gt; 1000 输出为8\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch5\u003E②非运算(~)\u003C\u002Fh5\u003E\u003Cp\u003E\u003Cb\u003E源码 -&gt; 取反 -&gt; 反码 -&gt; 加1 -&gt; 补码 -&gt; 取反 -&gt; 按位非值\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E在Java中，所有数据的表示方法都是以补码的形式表示，如果没有特殊说明，Java中的数据类型默认是int,int数据类型的长度是8位，一位是四个字节，就是32字节，32bit.\u003C\u002Fp\u003E\u003Cp\u003E例如5的二进制为0101\u003C\u002Fp\u003E\u003Cp\u003E补码后为 00000000 00000000 00000000 00000101\u003C\u002Fp\u003E\u003Cp\u003E取反后为 11111111 11111111 11111111 11111010\u003C\u002Fp\u003E\u003Cp\u003E【因为高位为1 所以源码为负数，负数的补码是其绝对值源码取反，末尾再加1】\u003C\u002Fp\u003E\u003Cp\u003E所以反着来末尾减1得到反码然后再取负数\u003C\u002Fp\u003E\u003Cp\u003E末位减1：11111111 11111111 11111111 11111001\u003C\u002Fp\u003E\u003Cp\u003E【后八位前面4位不动 后面 减1 1010减1 相当于 10-1为9 后四位就是 1001 】\u003C\u002Fp\u003E\u003Cp\u003E取反后再负数： 00000000 00000000 00000000 00000110 为-6\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003ESystem.out.println(~ 5); \u002F\u002F输出-6\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch5\u003E③或运算(|)\u003C\u002Fh5\u003E\u003Cp\u003E\u003Cb\u003E只要有一个为1，结果为1，否则都为0\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003ESystem.out.println(5 | 15); \u002F\u002F输出为15，0101或上1111,结果为1111\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch5\u003E④异或运算(^)\u003C\u002Fh5\u003E\u003Cp\u003E\u003Cb\u003E相同为0(假)，不同为真(1)\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003ESystem.out.println(5 ^ 15); \u002F\u002F输出10 0101异或1111结果为1010\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Ch3\u003E2.3 hashcode\u003C\u002Fh3\u003E\u003Cp\u003Ehash意为散列，hashcode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值，顶级父类Object类中含hashCode方法(native本地方法，是根据地址来计算值)，有一些类会重写该方法，比如String类。\u003C\u002Fp\u003E\u003Cp\u003E重写的原因。为了保证一致性，如果对象的equals方法被重写，那么对象的hashcode()也尽量重写。\u003C\u002Fp\u003E\u003Cp\u003E简单来说 就是hashcode()和equals()需保持一致性，如果equals方法返回true，那么两个对象的hashCode 返回也必须一样。\u003C\u002Fp\u003E\u003Cp\u003E否则可能会出现这种情况。\u003C\u002Fp\u003E\u003Cp\u003E假设一个类重写了equals方法，其相等条件为属性相等就返回true，如果不重写hashcode方法，那么依据就是Object的依据比较两个对象内存地址，则必然不相等，这就出现了equals方法相等但是hashcode不等的情况，这不符合hashcode的规则，这种情况可能会导致一系列的问题。\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E因此，在hashMap中，key如果使用了自定义的类，最好要合理的重写Object类的equals和hashcode方法。\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Ch3\u003E2.4 哈希桶\u003C\u002Fh3\u003E\u003Cp\u003E哈希桶的概念比较模糊，个人理解是数组表中一块区域结果下面的单向链表组成的，在hashmap中，这个单向链表的头部是所在数组上第一个元素，单向链表如果过长超过8，那么这个\"桶\"就可能变成了红黑树(前提是数组长度达到64）。\u003C\u002Fp\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Ch3\u003E2.5 hash函数\u003C\u002Fh3\u003E\u003Cp\u003E在程序设定中，把一个对象通过某种算法或者说转换机制对应到一个整形。\u003C\u002Fp\u003E\u003Cp\u003E主要用于解决冲突的。\u003C\u002Fp\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Ch3\u003E2.6 哈希表\u003C\u002Fh3\u003E\u003Cp\u003E也称为散列表，这也是一种数据结构，可以根据对象产生一个为整数的散列码(hashCode)。\u003C\u002Fp\u003E\u003Ch4\u003E\u003C\u002Fh4\u003E\u003Ch3\u003Ehash冲突\u003C\u002Fh3\u003E\u003Cp\u003EHashMap之所以有那么快的查询速度，是因为他的底层是由数组实现，通过key计算散列码(hashCode)决定存储的位置，HashMap中通过key的hashCode来计算hash值，只要hashCode相同，hash值也一样，但是可能存在存的对象多了，不同对象计算出的hash值相同，这就是hash冲突。\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E举个例子\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003EHashMap&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();\nmap.put(\u003Cspan class=\"hljs-string\"\u003E\"Aa\"\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E\"haha\"\u003C\u002Fspan\u003E);\nmap.put(\u003Cspan class=\"hljs-string\"\u003E\"BB\"\u003C\u002Fspan\u003E,\u003Cspan class=\"hljs-string\"\u003E\"heihei\"\u003C\u002Fspan\u003E);\nSystem.out.println(\u003Cspan class=\"hljs-string\"\u003E\"Aa\"\u003C\u002Fspan\u003E.hashCode()); \u002F\u002F2112\nSystem.out.println(\u003Cspan class=\"hljs-string\"\u003E\"BB\"\u003C\u002Fspan\u003E.hashCode()); \u002F\u002F2112\n\u002F\u002F这里的Aa和BB为String型，String类重写了\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003ECode方法(根据ascil码和特定的算法来计算，虽然很巧妙但也难以避免不对对象\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003ECode相同的情况)，Aa和BB的\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003ECode值相同，相同的HashCode的\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E值相同 \n\u002F\u002F根据源码就算key不相同 但key.hashCode()相同 则会返回相同的\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E，导致\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E冲突\nstatic final int \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E(Object key) {\u002F\u002F取关键key的\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E值\n    int h;\n    \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\u002F\u002F任何小于2的16次方的数 右移16位都为0 2的16次方&gt;&gt;&gt;16刚好为1 任何一个数和0按位异或都为这个数本身(1和0为1 0和0为0)，所以这个\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E()函数对于null的\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E值 仅在hashcode大于2的16次方才会调整值,这边16设计的很巧妙，因为int刚好是32位的取中间位数\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003E2.7 二叉查找树和红黑树\u003C\u002Fh3\u003E\u003Cp\u003E红黑树是一种自平衡二叉查找树。是一种数据结构，又称二叉b树，（→_→ 2b树？），红黑树本质上也是二叉查找树。所以先理解下二叉查找树。\u003C\u002Fp\u003E\u003Ch4\u003E2.7.1二叉查找树\u003C\u002Fh4\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E二叉查找树，又称有序二叉树，已排序二叉树\n它的三大特点如下\n1.左子树上所有结点的值均小于或等于它的根结点的值。\n2.右子树上所有结点的值均大于或等于它的根结点的值。\n3.左、右子树也分别为二叉排序树。\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E\u003Cimg alt=\"img_15bc610b523331178a92ad63dcfac5f8.png\" src=\"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fgold-user-assets\u002F2019\u002F9\u002F26\u002F16d6cc9bf1be2e12~tplv-t2oaga2asx-image.image\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E二叉树.png\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Ch4\u003E2.7.2 红黑树(RBTree)\u003C\u002Fh4\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E由于二叉查找树可能存在难以平衡呈线性的缺陷，所以出现的红黑树的概念。顾名思义，红黑树是只有红色和黑色节点的二叉树。\n它的5大性质如下。\n1.节点是红色或黑色。\n2.根节点是黑色。\n3.每个叶子节点都是黑色的空节点（NIL节点）。\n4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)\n5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E简单来说红黑树是一种自平衡二叉查找树，相比于普通的二叉查找树，它的数据结构更为复杂，但是在复杂的情况也能通过自平衡(变色，左右旋转)保持良好的性能。\u003C\u002Fp\u003E\u003Cp\u003E关于红黑树，很形象的一组漫画，查看\u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzIxMjE5MTE1Nw%3D%3D%26amp%3Bmid%3D2653191832%26amp%3Bidx%3D1%26amp%3Bsn%3D12017161025495c6914b5ab9397baa59%26amp%3Bchksm%3D8c990c42bbee8554ba02eb83d839123bd3bead6ffc736111456ea77367a3df75750cf88016e0%26amp%3Bscene%3D21%23wechat_redirect\"\u003E这里\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003E在线模拟红黑树增删的地址\u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fwww.cs.usfca.edu%2F%7Egalles%2Fvisualization%2FRedBlack.html\"\u003E地址1\u003C\u002Fa\u003E、 \u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fsandbox.runjs.cn%2Fshow%2F2nngvn8w\"\u003E地址2\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E红黑树的时间复杂度为【吐槽下简书这边如果用数学公式太蛋疼了】：\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003EO(logn)\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003E\u003C\u002Fp\u003E\u003Cdiv\u003E\u003Cdiv\u003E它的高度为:[logN,logN+1]（理论上，极端的情况下可以出现RBTree的高度达到2\u003C\u002Fdiv\u003ElogN，但实际上很难遇到）。\u003C\u002Fdiv\u003E*\u003Cp\u003E\u003C\u002Fp\u003E\u003Cp\u003E此外，由于它的设计任何不平衡将在三次旋转内解决。\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E红黑树和avl树(最早的自平衡二叉树)的比较：\navl更加平衡，查询速率稍强于红黑树，但是插入和删除红黑树完爆avl树，可能由于\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003EMap的增删也挺频繁的，所以综合考虑而选择红黑树。\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cb\u003E总结：红黑树是种可以通过变色旋转的自平衡二叉查找树，对于hashMap来说，使用红黑树的好处在于，当有多个元素hash相同在同一数组下标的时候，使用红黑树在查找这些hash冲突的元素更快，它的时间复杂度从遍历链表O(n)降到O(logN)。\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Ch3\u003E2.8 复杂度\u003C\u002Fh3\u003E\u003Cp\u003E算法复杂度分时间复杂度和空间复杂度。\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E时间复杂度：执行算法所需要的计算工作量\n空间复杂度：执行算法所需要内存空间大小\n时间和空间都是计算机资源的体现，算法的复杂性体现在运行该算法时计算机所需资源的大小。\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cb\u003E这里重点讲下时间复杂度\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E(1)时间频度\n用T(n)表示\n一个算法执行所消耗的时间，理论上不能算出来而是通过运行测试得知，但不可能也没必要对每个算法都做上机测试，只需知道哪个算法花费时间多哪个花费少即可。在算法中一个算法花费的时间和这个算法执行的次数成正比。\n在一个算法中，语句执行次数称为时间频度(或称为语句频度)，记做为T(n)，这里的n代表问题的规模。暂且不考虑这个T是啥，把它理解为一个函数。\n(2)时间复杂度 \n用Ｏ(f(n))表示\n当n变化时，时间频度T(n)也会不断变化，但是它是个不确定的函数，我们想知道它呈现的规律是什么样的。这个时候引入了时间复杂度的概念。\n前面说T(n)是个不确定的函数，它代表算法中基本操作重复执行的次数是问题规模n的某个函数。\n假设有某个辅助函数f(n),当n趋近∞，T(n)\u002Ff(n)的极限值不为0切位常数，那么可以认为f(n)和T(n)为同一数量级的函数，记做为T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。\n\nf(n)虽然没有规定但一般都尽可能取简单的函数\n例如 O(2n²+n +1) = O (3n²+n+3) = O (7n² + n) = O ( n² ) 省去了系数,只保留最高阶项。\n时间频度不同时，时间复杂度有可能相同，例如T(n)=n²+3n+4与T(n)=4n²+2n+1它们的频度不同，但时间复杂度相同，都为O(n²)。\n\n总结两者关系:时间复杂度就是对时间频度函数的一层包装，它的特点(大O表示法)为\n①省去系数为1处理②保留最高项\n如果把T(n)当做为一棵树，那么O(f(n))只关心其主干部分。\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cb\u003E常见算法的时间复杂度从小到大依次为\u003C\u002Fb\u003E\u003Cbr\u003E\u003C\u002Fp\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E\u003Cimg alt=\"img_8f75b001aae9edc9b86bb1e9fc7c7f6d.png\" src=\"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fgold-user-assets\u002F2019\u002F9\u002F26\u002F16d6cc9bed0cf8cc~tplv-t2oaga2asx-image.image\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E复杂度比较\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E求解算法的时间复杂度具体步骤为：\n①找出算法中执行次数最多的基本语句，一般是最内层的循环体。\n②计算基本语句的数量级\n③将基本语句执行次数的数量级放入大O记号中\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cb\u003E举几个例子\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003EO(1),又称常数阶，一般来说算法中没有循环体，执行次数为常数那么时间复杂度就为O(1)，例如\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003Eint sum = 0,n = 100; \u002F\u002F执行一次  \nsum = (1+n)*n\u002F2; \u002F\u002F执行一次  \nSystem.out.println (sum); \u002F\u002F执行一次 \n\u002F\u002F上面的算法运行次数为f(n)=3,那么根据大O表示法，该算法的时间复杂度为O(1)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch5\u003E\u003C\u002Fh5\u003E\u003Cp\u003E\u003Cb\u003E为什么O(logN)，对数阶不用底数\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E如红黑树的查找复杂为O(logN)\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E这里面有个可能存在的疑问，有时候时间复杂度都用包含O(logN)这样的描述 但是没有明确说明n的底数是多少，通常底数为2来计算\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E这种描述其实也是合理的，算法中log级别的时间复杂度都是由于使用了分治思想,这个底数直接由分治的复杂度决定。当n趋近于无穷大，两个大小比较也只是一个常数，所以这种时候O(logN)统一代表对数复杂度。\u003Cbr\u003E\\lim_{n\\rightarrow+\\infty} Ο(\\log_x{n})\u002FΟ(\\log_y{n}) = C\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E其它简单举例\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Ctable\u003E\u003Cthead\u003E\u003Ctr\u003E\u003Cth\u003E描述\u003C\u002Fth\u003E\u003Cth\u003E增长数量级\u003C\u002Fth\u003E\u003Cth\u003E典型代码\u003C\u002Fth\u003E\u003Cth\u003E说明\u003C\u002Fth\u003E\u003C\u002Ftr\u003E\u003C\u002Fthead\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E常数阶\u003C\u002Ftd\u003E\u003Ctd\u003E1\u003C\u002Ftd\u003E\u003Ctd\u003Ea = b + c\u003C\u002Ftd\u003E\u003Ctd\u003E普通简单算法操作\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E对数阶\u003C\u002Ftd\u003E\u003Ctd\u003ElogN\u003C\u002Ftd\u003E\u003Ctd\u003E二叉树中的二分法\u003C\u002Ftd\u003E\u003Ctd\u003E二分策略\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E线性级别\u003C\u002Ftd\u003E\u003Ctd\u003EN\u003C\u002Ftd\u003E\u003Ctd\u003Efor(int i = 0;i &lt; 10; i++) {...}\u003C\u002Ftd\u003E\u003Ctd\u003E普通单层循环算法\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E平方级别\u003C\u002Ftd\u003E\u003Ctd\u003EN²\u003C\u002Ftd\u003E\u003Ctd\u003Efor(int i = 0;i &lt; 10; i++) {for(int j = 0; j &lt; 10) {...}}\u003C\u002Ftd\u003E\u003Ctd\u003E双层循环，例如冒泡排序\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E指数级别\u003C\u002Ftd\u003E\u003Ctd\u003E2的n次方\u003C\u002Ftd\u003E\u003Ctd\u003E一个背包大小一定时，找出不大于背包所有物品组合，假设有3个物品，a，b，c，可能的组合有8种。(a,b,c,ab,ac,bc,abc+空(背包太小一个都容纳不下))\u003C\u002Ftd\u003E\u003Ctd\u003E穷举查找(背包问题\u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fwww.cnblogs.com%2Ftinaluo%2Fp%2F5264190.html\"\u003Ehttps:\u002F\u002Fwww.cnblogs.com\u002Ftinaluo\u002Fp\u002F5264190.html\u003C\u002Fa\u003E)\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Ch1\u003E3. HashMap的内部实现(基于jdk1.8)\u003C\u002Fh1\u003E\u003Cblockquote\u003E\u003Cp\u003E刚开始看hashMap源码的时候，感觉思路很乱不知道写的啥东西，所以还是得从它的【数据结构】开始入手。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E\u003Cimg alt=\"img_550edf98975a3d557599d6792129fba5.jpe\" src=\"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fgold-user-assets\u002F2019\u002F9\u002F26\u002F16d6cc9bef779b0b~tplv-t2oaga2asx-image.image\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E不同于一般类的数据结构，从结构来讲 HashMap = 数组 + 链表 + 红黑树(1.8开始加入，大程度的优化了HashMap的性能)\narrayList  数组\nlinkedList 双向链表 查询效率慢，需通过遍历，新增或删除快，比如说删除一个元素 知道那个元素的上下引用 并改变关联上下元素的引用指向即可。\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003E3.1 数组和链表\u003C\u002Fh3\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E\u003Cimg alt=\"img_fdee83a22ddec90d5d4b5779804d0cd8.png\" src=\"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fgold-user-assets\u002F2019\u002F9\u002F26\u002F16d6cc9beec7d8de~tplv-t2oaga2asx-image.image\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E数组和链表.png\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Ch3\u003E3.2 HashMap数据结构(数组+链表+红黑树)\u003C\u002Fh3\u003E\u003Cblockquote\u003E\u003Cp\u003E在jdk8以前，如果发生频繁碰撞的话，查找时间复杂度是O(1) + O(n) (先找在数组的位置再找链表)，n如果比较大则严重影响了查找性能，而到了jdk8引入红黑树,O(1) + O(logN)。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E\u003Cimg alt=\"img_97ec833243a8d841f179b1fd3d54c982.png\" src=\"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fgold-user-assets\u002F2019\u002F9\u002F26\u002F16d6cc9bf47291f9~tplv-t2oaga2asx-image.image\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003Ehashmap.png\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Ch2\u003E大致思路\u003C\u002Fh2\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E①数组的优点是查询快，链表的优点是增删快，红黑树查询性能较好，\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003EMap的存储方式结合了它们的优点，那么\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003EMap的存储单元又可以在数组里，又可以在某个数组下的链表里。还有可能在红黑树当中。\n②我们已经知道HashMap是键值对的存在，且可以为各种类型，那么它又是以键值对的方式存在，它的最小存储单位是以Node节点为存储单位。\n这个Node结构大概有Key，Value，记录所在数组索引，以及记录链表指针的东西。\n大概结构如下\nstatic class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {\n  final int \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E;\n  final K key;\n  V value;\n  Node&lt;K,V&gt; next;\n  ...\n}\n\n③新来的Node节点怎么放?\nHashMap利用hashcode来确定存放的位置，但是又有个疑问，假设map对象key为String型\nHashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();\nmap.put(\u003Cspan class=\"hljs-string\"\u003E\"1\"\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E\"first\"\u003C\u002Fspan\u003E);\n\n\u002F\u002F这个时候看put方法 \nput方法的大致思路为\n①对key做\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E运算，通过\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E值计算index下标位置\n②如果没冲突直接放在桶上\n③如果冲突了，以链表的形式存在桶里面，达到一定条件链表变为红黑树\n④如果节点已经存在，则替换旧的value(保证唯一性)\n⑤如果桶的个数超过了 加载因子乘当前容量，则做resize操作\n\n\u002F\u002F可以注意到有个\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E函数\npublic V put(K key, V value) {\n   \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E putVal(\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E(key), key, value, \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E);\n}\n\n\u002F\u002F\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E函数 \nstatic final int \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E(Object key) {\n   int h;\n   \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n}\n\n\u002F\u002F上述代码String类型的1的Hashcode为49超过了HashMap的初始长度16，这个时候\u003Cspan class=\"hljs-string\"\u003E\"1\"\u003C\u002Fspan\u003E这个key放在哪。这里\n\u002F\u002F通过巧妙的设计存放在合适的位置 4.3.3做分析\np = tab[i = (n - 1) &amp; \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E]，\n\n\n\u002F\u002F这里的p为Node&lt;K,V&gt;对象，n为当前哈希桶数组长度，进行与运算后，因为这是第一个插入的元素，无需扩容长度为16,那么49 &amp; 15 = 1，说明在的第二个位置。\n\n④新节点插入后什么时候开始扩容\n接下来不断的插入的元素 经过\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E函数和计算索引位置后，都可以根据它的散列性插入到不同的16个位置，\n当元素个数达到16 * 0.75 即12时，继续插入新的时候，开始扩容。\n【这里注意一下并不是说占满12个位置才开始扩容，而是12个节点，根据散列性分布12个节点，占...5，6，7，8...个位置都有可能,比如说key为Integer类型，假如key为Integer类型，有五个节点key分别为3，19，12，28，44这个时候3，19在同一个位置，12，28，44在同一个位置，这个时候5个节点就占了两个位置】\n\n\n⑤resize()方法进行扩容操作。\n1.先判断节点数组是否为空，并取它的容量(节点个数)，创建新数组，大小时新的capacity\n如果不为空：\n如果容量超过最大值不做扩容，否则位运算一位做容量乘2处理，\n如果为空：\n桶数组容量为默认容量16，即有默认放16个桶，阈值默认为默认容量乘默认加载因子 12\n2.将旧数组的元素放到新数组中，重新做映射\n如果旧的数组不为空，则遍历桶数组，并将键值对映射到新的桶数组中[树节点和链表节点做不同操作]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch1\u003E4.源码分析\u003C\u002Fh1\u003E\u003Ch3\u003E4.1 基本存储单位Node节点\u003C\u002Fh3\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003Estatic class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { \u002F\u002F实现Entry接口 存储的是键值对的映射\n    final int \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E; \u002F\u002F\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E值，用于记录数组所在位置\n    final K key; \u002F\u002F用于匹配\n    V value; \u002F\u002F值\n    Node&lt;K,V&gt; next; \u002F\u002F用于记录单链表下一节点 用于解决\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E冲突(即\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E值一样该存在哪里的问题)\n    Node(int \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E, K key, V value, Node&lt;K,V&gt; next) {\n        this.hash = \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E;\n        this.key = key;\n        this.value = value;\n        this.next = next;\n    }\n    public final K \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003EgetKey\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E()        { \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E key; }\n    public final V \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003EgetValue\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E()      { \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E value; }\n    public final String \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003EtoString\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() { \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E key + \u003Cspan class=\"hljs-string\"\u003E\"=\"\u003C\u002Fspan\u003E + value; }\n    public final int \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003EhashCode\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() {\n        \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E Objects.hashCode(key) ^ Objects.hashCode(value);\n    }\n    public final V \u003Cspan class=\"hljs-built_in\"\u003Eset\u003C\u002Fspan\u003EValue(V newValue) {\u002F\u002F赋值\n        V oldValue = value;\n        value = newValue;\n        \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E oldValue;\n    }\n    public final boolean equals(Object o) {\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (o == this)\n            \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (o instanceof Map.Entry) {\n            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (Objects.equals(key, e.getKey()) &amp;&amp;\n                Objects.equals(value, e.getValue()))\n                \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n        }\n        \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n    }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003E4.2 HashMap中的几个重要实现：hash函数，put、get、resize\u003C\u002Fh3\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E\u002F\u002Fput\npublic V put(K key, V value) {\n    \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E putVal(\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E(key), key, value, \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E);\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003Efinal V putVal(int \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    \u002F\u002F哈希表数组节点 \n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n    \u002F\u002F如果为空 调用resize以默认大小16扩容 \n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    \u002F\u002F通过(n - 1) &amp; \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E计算存放索引位置 此处设计很巧妙\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E ((p = tab[i = (n - 1) &amp; \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E]) == null)\n      \u002F\u002F如果tab[i]为空 该下标下没有节点 则直接新建一个Node放在该位置 \n        tab[i] = newNode(\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E, key, value, null);\n    \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n        \u002F\u002F下标上有节点 说明有\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E冲突\n        Node&lt;K,V&gt; e; K k;\n        \u002F\u002F如果插入的新节点key已经存在，那么直接覆盖整个节点\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (p.hash == \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E &amp;&amp;\n            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n            e = p;\n        \u002F\u002F如果为红黑树节点\n        \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (p instanceof TreeNode)\n            \u002F\u002F调用红黑树插入键值对的putTreeVal方法\n            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E, key, value);\n        \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n            \u002F\u002F不管tab[index]是否为空，p节点已经为 tab[index]上\n            \u002F\u002F如果有冲突 且不为红黑树节点 那么此时遍历链表节点 binCount计算链表长度\n            \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (int binCount = 0; ; ++binCount) {\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E ((e = p.next) == null) {\n                    p.next = newNode(\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E, key, value, null);\n                   \u002F\u002F链表长度大于等于7，调用treeifyB\u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E对链表进行树化\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (binCount &gt;= TREEIFY_THRESHOLD - 1) \u002F\u002F -1 \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E 1st\n                        treeifyB\u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E(tab, \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E);\n                    \u003Cspan class=\"hljs-built_in\"\u003Ebreak\u003C\u002Fspan\u003E;\n                }\n                \u002F\u002F遍历链表时发现重复 覆盖并跳出循环\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (e.hash == \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E &amp;&amp;\n                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                    \u003Cspan class=\"hljs-built_in\"\u003Ebreak\u003C\u002Fspan\u003E;\n                p = e;\n            }\n        }\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (e != null) { \u002F\u002F existing mapping \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E key\n            V oldValue = e.value;\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E oldValue;\n        }\n    }\n    ++modCount;\n    \u002F\u002F插入成功后 再根据实际判断是否到到阈值 比如说现在容量16(桶的个数16) 正在插第13个元素时 到达则扩容 \n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (++size &gt; threshold)\n        resize();\n    afterNodeInsertion(evict);\n    \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E null;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003Eget方法\u003C\u002Fh3\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003Epublic V get(Object key) {\n    Node&lt;K,V&gt; e;\n    \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E (e = getNode(\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E(key), key)) == null ? null : e.value;\n}\n\nfinal Node&lt;K,V&gt; getNode(int \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E, Object key) {\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;\n    \u002F\u002F先定位键值对在所在桶的位置\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;\n        (first = tab[(n - 1) &amp; \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E]) != null) {\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (first.hash == \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E &amp;&amp; \u002F\u002F always check first node \n            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))\n            \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E first;\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E ((e = first.next) != null) {\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (first instanceof TreeNode)\n                \u002F\u002F如果是红黑树节点 通过红黑树查找方法查找\n                \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E ((TreeNode&lt;K,V&gt;)first).getTreeNode(\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E, key);\n            \u003Cspan class=\"hljs-keyword\"\u003Edo\u003C\u002Fspan\u003E {\n                \u002F\u002F对链表查找\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (e.hash == \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E &amp;&amp;\n                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                    \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E e;\n            } \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E ((e = e.next) != null);\n        }\n    }\n    \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E null;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003E4.4.5 resize()\u003C\u002Fh3\u003E\u003Cp\u003E扩容就是重新定义容量，在hashmap中，如果不断的put元素，而hashMap对象中的数组无法装得下更多对象时，对象就需要进行扩容，扩大数组长度。这边注意的是：\u003C\u002Fp\u003E\u003Cp\u003E\u003C\u002Fp\u003E\u003Cdiv\u003E\u003Cdiv\u003E①假如初始大小为默认值16，什么时候扩容，我们可以知道阈值是16\u003C\u002Fdiv\u003E0.75即12，这个12是指hashMap的size(全局变量，每次put+1.remove-1)，put后为大于12即13时开始执行resize方法扩容。\u003C\u002Fdiv\u003E*\u003Cp\u003E\u003C\u002Fp\u003E\u003Cp\u003E②\u003Cb\u003E在java中数组是不能够自动扩容的，是采用一个新的大容量数组代替原有的小数组，就好比用一个小桶装水，如果想用一个桶装更多的水，就换一个大桶再把原来小桶的水装过去。\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E③扩容后，普通链表上的节点包括红黑树都得重新映射。\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003E对于hashmap来说\u003Cbr\u003E什么时候换大桶：达到阈值的时候\u003Cbr\u003E换多大的桶：原有小桶的两倍大小\u003Cbr\u003E但桶的大小也是有限的，对于hashMap，最大的桶能容纳包含2^30个数，大于的话就不再扩容，就随里面碰撞了。(实际上也很难用到这么大的容量)\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003Efinal Node&lt;K,V&gt;[] \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003Eresize\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() {\n    \u002F\u002Ftable为全局变量transient Node&lt;K,V&gt;[] table; 赋值给oldTab\n    Node&lt;K,V&gt;[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\u002F\u002F旧表数组个数\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (oldCap &gt; 0) { \u002F\u002F如果旧容量大于0    \n        \u002F\u002F超过最大值就不扩容了，随它碰撞去吧 -。-\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (oldCap &gt;= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E oldTab;\n        }\n        \u002F\u002F×2还没超过最大值，新数组就扩容为原来两倍 阈值也做×2处理\n        \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;\n                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr &lt;&lt; 1; \u002F\u002F double threshold \n    }\n    \u002F\u002F如果原来的阈值 &gt; 0且旧容量为0，则将新容量设为原来的阈值，初始化有参给threshold赋值会有此情况\n    \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (oldThr &gt; 0) \n        newCap = oldThr;\n    \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E { \u002F\u002F zero initial threshold signifies using defaults\n        \u002F\u002F默认初始化无参构造的情况 \n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    \u002F\u002F如果\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (newThr == 0) {\n        \u003Cspan class=\"hljs-built_in\"\u003Efloat\u003C\u002Fspan\u003E ft = (\u003Cspan class=\"hljs-built_in\"\u003Efloat\u003C\u002Fspan\u003E)newCap * loadFactor;\n        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (\u003Cspan class=\"hljs-built_in\"\u003Efloat\u003C\u002Fspan\u003E)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    @SuppressWarnings({\u003Cspan class=\"hljs-string\"\u003E\"rawtypes\"\u003C\u002Fspan\u003E,\u003Cspan class=\"hljs-string\"\u003E\"unchecked\"\u003C\u002Fspan\u003E}) \u002F\u002F屏蔽无关紧要的警告\n        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];\n    table = newTab;\n    \u002F\u002F如果旧数组不为空 \n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (oldTab != null) {\n        \u002F\u002F遍历数组\n        \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (int j = 0; j &lt; oldCap; ++j) {\n            Node&lt;K,V&gt; e;\n            \u002F\u002F数组中的节点不为空\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                \u002F\u002F如果该桶只有一个节点(说明下面没有链表，或者说只有一个链表节点)\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (e.next == null)\n                    \u002F\u002Fe.hash &amp; (newCap - 1)确定元素存放位置\n                    newTab[e.hash &amp; (newCap - 1)] = e;\n                \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (e instanceof TreeNode)\n                    \u002F\u002F红黑树节点\n                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);\n                \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E { \n                    \u002F\u002F链表节点且当前链表节点不止1个\n                    Node&lt;K,V&gt; loHead = null, loTail = null;\n                    Node&lt;K,V&gt; hiHead = null, hiTail = null;\n                    Node&lt;K,V&gt; next;\n                    \u003Cspan class=\"hljs-keyword\"\u003Edo\u003C\u002Fspan\u003E {\n                        next = e.next;\n                        \u002F\u002F根据e.hash &amp; oldCap 判断节点存放位置\n                        \u002F\u002F如果为0 扩容还在原来位置 如果为1 新的位置为 旧的index + oldCap 下面如何扩容有做介绍\n                        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E ((e.hash &amp; oldCap) == 0) {\n                            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (loTail == null)\n                                loHead = e;\n                            \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n                            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (hiTail == null)\n                                hiHead = e;\n                            \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E ((e = next) != null);\u002F\u002F旧链表迁移到新链表\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (loTail != null) {\n                        loTail.next = null;\u002F\u002F将链表的尾节点的next设置为空\n                        newTab[j] = loHead;\n                    }\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (hiTail != null) {\n                        hiTail.next = null;\u002F\u002F 将链表的尾节点 的next 设置为空\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E newTab;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003E4.3 HashMap经典代码 p = tab[i = (n - 1) &amp; hash])\u003C\u002Fh3\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003Ep = tab[i = (n - 1) &amp; \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E])\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E当hashCode小于65536，散列是很规律的，基本上索引的位置就是\u003C\u002Fp\u003E\u003Cp\u003E因为小于这个数右移16为都为0，且和占位符都为0的值异或后的hashcode就是自身的值。\u003C\u002Fp\u003E\u003Cp\u003E这个值比较特殊\u003C\u002Fp\u003E\u003Cp\u003E转换为二进制：00000000000000010000000000000000，右移16的话00000000000000000000000000000001并不全为0\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003Estatic final int \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E(Object key) {\n    int h;\n    \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Ekey的hashcode为65536\u003C\u002Fp\u003E\u003Cp\u003E转为二进制：h=key.hashCode() 00000000000000010000000000000000\u003C\u002Fp\u003E\u003Cp\u003E跟右移16位的再做异或操作 00000000000000000000000000000001\u003C\u002Fp\u003E\u003Cp\u003Ehash = h ^(h&gt;&gt;&gt;16) 00000000000000010000000000000001\u003C\u002Fp\u003E\u003Cp\u003E​\u003C\u002Fp\u003E\u003Cp\u003E计算hash 00000000000000010000000000000001\u003C\u002Fp\u003E\u003Cp\u003E​ 00000000000000000000000000001111\u003C\u002Fp\u003E\u003Cp\u003E结果 1\u003C\u002Fp\u003E\u003Cp\u003E但是65536 % 16 = 0\u003C\u002Fp\u003E\u003Cp\u003Ekey的hashcode为17 异或相同为0 不同为假\u003C\u002Fp\u003E\u003Cp\u003E转为二进制：h=key.hashCode() 00000000000000000000000000010001\u003C\u002Fp\u003E\u003Cp\u003E跟右移16位的再做异或操作 00000000000000000000000000000000\u003C\u002Fp\u003E\u003Cp\u003Ehash = h ^(h&gt;&gt;16) 00000000000000000000000000010001\u003C\u002Fp\u003E\u003Cp\u003E计算hash 00000000000000000000000000010001\u003C\u002Fp\u003E\u003Cp\u003E​ 00000000000000000000000000001111\u003C\u002Fp\u003E\u003Cp\u003E​ 00000000000000000000000000000001\u003C\u002Fp\u003E\u003Cp\u003E做个小测试，假设这个时候桶的个数为16，代码如下\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (int key = 65533; key &lt; 65543; key++) { \u002F\u002F从65536开始变得有点\u003Cspan class=\"hljs-string\"\u003E\"特别\"\u003C\u002Fspan\u003E\n    System.out.println(\u003Cspan class=\"hljs-string\"\u003E\"key为：\"\u003C\u002Fspan\u003E + key +  \u003Cspan class=\"hljs-string\"\u003E\"，索引位置：\"\u003C\u002Fspan\u003E + ((key ^ (key &gt;&gt;&gt; 16)) &amp; 15));\u002F\u002F假设初始容量为16 测试没扩容时这些数的索引位置\n}\n\u002F\u002F输出结果为，可以发现从65536开始不为0而是1，有点特殊，然后相邻两个索引位置呈1,3的增长，具体可画图尝试\ni为：65533，输出13\ni为：65534，输出14\ni为：65535，输出15\ni为：65536，输出1\ni为：65537，输出0\ni为：65538，输出3\ni为：65539，输出2\ni为：65540，输出5\ni为：65541，输出4\ni为：65542，输出7\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E这段代码主要是计算索引位置的，HashMap 底层数组的长度总是 2 的 n 次方\u003C\u002Fp\u003E\u003Cp\u003E当 length 总是 2 的倍数时，h&amp; (length-1)，将是一个非常巧妙的设计：\u003C\u002Fp\u003E\u003Ctable\u003E\u003Cthead\u003E\u003Ctr\u003E\u003Cth\u003Ehash值\u003C\u002Fth\u003E\u003Cth\u003Elength(假设长度为16)\u003C\u002Fth\u003E\u003Cth\u003Eh &amp; length - 1\u003C\u002Fth\u003E\u003C\u002Ftr\u003E\u003C\u002Fthead\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E5\u003C\u002Ftd\u003E\u003Ctd\u003E16\u003C\u002Ftd\u003E\u003Ctd\u003E5\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E6\u003C\u002Ftd\u003E\u003Ctd\u003E16\u003C\u002Ftd\u003E\u003Ctd\u003E6\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E15\u003C\u002Ftd\u003E\u003Ctd\u003E16\u003C\u002Ftd\u003E\u003Ctd\u003E15\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E16\u003C\u002Ftd\u003E\u003Ctd\u003E16\u003C\u002Ftd\u003E\u003Ctd\u003E0\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E17\u003C\u002Ftd\u003E\u003Ctd\u003E16\u003C\u002Ftd\u003E\u003Ctd\u003E1\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\u003Cp\u003E\u003Cb\u003E可以看到计算得到的索引值总是位于 table 数组的索引之内。并且通常分布的比较均匀\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Ch3\u003E4.4 树形化treeifyBin()\u003C\u002Fh3\u003E\u003Cp\u003E在jdk8以前，如果发生频繁碰撞的话，查找时间复杂度是O(1) + O(n) (先找在数组的位置再找链表)，n如果比较大则严重影响了查找性能，而到了jdk8引入红黑树,O(1) + O(logN)。\u003C\u002Fp\u003E\u003Cp\u003Ejdk1.8中，如果一个桶中元素个数超过TREEIFY_THRESHOLD(8)时，就用红黑树替换链表以提升速度(主要是查找)\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E\u002F\u002F将桶内所有链表节点换成红黑树节点\nfinal void treeifyB\u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E(Node&lt;K,V&gt;[] tab, int \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E) {\n    int n, index; Node&lt;K,V&gt; e;\n    \u002F\u002F如果当前哈希表为空 或者哈希表中元素 MIN_TREEIFY_CAPACITY默认为64，对于这个值可以认为，如果节点数组长度小于64，就没必要去进行结构转换，而是通过resize()操作，这样原先一个链表的元素可能会进行重新分配。\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)\n        resize(); \u002F\u002F扩容\n    \u002F\u002F大于等于64 就树化 链表上的普通节点变成树节点\n    \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E ((e = tab[index = (n - 1) &amp; \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E]) != null) {      \n        TreeNode&lt;K,V&gt; hd = null, tl = null; \u002F\u002F定义首、尾节点\n        \u003Cspan class=\"hljs-keyword\"\u003Edo\u003C\u002Fspan\u003E {\n            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); \u002F\u002F普通节点 -&gt; 树节点\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (tl == null) \u002F\u002F如果尾节点为空 说明还没有根节点\n                hd = p; \u002F\u002F首节点(根节点) 指向当前节点\n            \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E { \u002F\u002F尾节点不为空 \n                p.prev = tl; \u002F\u002F当前树节点前一个节点指向尾节点\n                tl.next = p; \u002F\u002F尾节点后一个节点 指向当前节点\n            }\n            tl = p; \n        } \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E ((e = e.next) != null); \u002F\u002F继续遍历链表\n      \n        \u002F\u002F这个时候只是把Node对象变成TreeNode对象，把单向链表变成双向链表\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E ((tab[index] = hd) != null)\n            hd.treeify(tab);\n    }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch1\u003E5.思考\u003C\u002Fh1\u003E\u003Ch3\u003E1.HashMap和HashTable的区别是什么\u003C\u002Fh3\u003E\u003Cp\u003EHashMap和Hashtable都实现了Map接口\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003EHashMap功能上几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。\u003Cbr\u003EHashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的\u003Cbr\u003E由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。\u003Cbr\u003EHashMap不能保证随着时间的推移Map中的元素次序是不变的。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003E由于性能问题，以及HashTable处理Hash冲突比HashMap逊色很多，现在HashTable已经很少使用了。但由于线程安全以及以前的项目还在使用，SUN依然还保留着它并没有加Deprecated过时注解。\u003C\u002Fp\u003E\u003Cp\u003E摘自hashtable源码\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003EIf a thread-safe implementation is not needed, it is recommended to use HashMap in place of Hashtable. If a thread-safe highly-concurrent implementation is desired, then it is recommended to use java.util.concurrent.ConcurrentHashMap in place of Hashtable.\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003E简单来说就是不需要线程安全，那么使用HashMap，如果需要线程安全，那么使用ConcurrentHashMap。\u003C\u002Fp\u003E\u003Ch3\u003E2.HashMap为什么线程不安全，如果想要线程安全怎么做\u003C\u002Fh3\u003E\u003Cp\u003E因为hashmap为了性能，它的put，resize等操作都不是同步的，假设两个线程同一时间做put操作,可能最后计算的size并不正确，值得一提的是jdk1.8以前多线程put甚至会导致闭环死循环，1.8开始不会有这个问题但依然存在线程安全问题。\u003C\u002Fp\u003E\u003Cp\u003Ejdk8前的闭环死循环。\u003C\u002Fp\u003E\u003Cp\u003E这种问题在单线程下不存在，但在多线程下可能引起死循环导致cpu占用过高。\u003C\u002Fp\u003E\u003Cp\u003E如果hash冲突大，同一链表下下有多个节点容易出现这种问题。具体参考\u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fwww.jianshu.com%2Fp%2F1e9cf0ac07f4\"\u003E老生常谈，HashMap的死循环\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E若想要线程安全\n1、使用ConcurrentHashMap。(线程安全的\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003EMap)\n2、使用Collections.synchronizedMap(Mao&lt;K,V&gt; m)方法把HashMap变成一个线程安全的Map。\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003E3.HashMap是怎么解决Hash冲突的\u003C\u002Fh3\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E在实际应用中，无论怎么构造哈希函数，冲突也难以完全避免。\nHashMap根据链地址法(拉链法)来解决冲突,jdk8中如果链表长度大于8且节点数组长度大于64的时候，就把链表下所有节点转为红黑树，位于数组上的节点为根节点，来维护\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E冲突的元素，链表中冲突的元素可以通过key的equals()方法来确定。\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003E4.HashMap是怎么扩容的\u003C\u002Fh3\u003E\u003Cp\u003E先写个例子测试hashMap有没有在扩容。\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003Epublic static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n    HashMap&lt;Integer,String&gt; o = new HashMap&lt;&gt;(1);\n    System.out.println(o.size()); \u002F\u002F0 size为元素个数\n    \u002F\u002F扩容条件是 如果没有定义初始容量 默认扩容至16 如果没有 根据put的情况扩容\n    \u002F\u002Fput的过程中 如果插入一个元素过后的size &gt; 阈值(加载因子 * 最近容量)\n    \u002F**\n     * 代码体现 put后执行\n     *   \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (++size &gt; threshold)\n     *         resize();\n     *\u002F\n    \u002F\u002F有定义容量的话会采用大于这个数的最小二次幂 第一次初始化为1 则输出为2 4 5 11  111 11\n    HashMap&lt;Integer,String&gt; map = new HashMap&lt;&gt;(1);\n    map.put(1, \u003Cspan class=\"hljs-string\"\u003E\"一\"\u003C\u002Fspan\u003E);\n    \u002F\u002F由于方法由final修饰 利用反射机制获取容量值\n    Class&lt;?&gt; mapType = map.getClass();\n    Method capacity = mapType.getDeclaredMethod(\u003Cspan class=\"hljs-string\"\u003E\"capacity\"\u003C\u002Fspan\u003E);\n    capacity.setAccessible(\u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E); \u002F\u002F由于capacity方法由final修饰 暴力获取\n    System.out.println(\u003Cspan class=\"hljs-string\"\u003E\"capacity : \"\u003C\u002Fspan\u003E + capacity.invoke(map)); \u002F\u002Fcapacity : 2\n \n    map.put(2, \u003Cspan class=\"hljs-string\"\u003E\"二\"\u003C\u002Fspan\u003E);\n    capacity = mapType.getDeclaredMethod(\u003Cspan class=\"hljs-string\"\u003E\"capacity\"\u003C\u002Fspan\u003E);\n    capacity.setAccessible(\u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E);\n    System.out.println(\u003Cspan class=\"hljs-string\"\u003E\"capacity : \"\u003C\u002Fspan\u003E + capacity.invoke(map)); \u002F\u002Fcapacity : 4 当前容量为2 插入该元素后size为 2 &gt; 2 * 3\u002F4 开始扩容\n\n    \u002F\u002F当前容量为4 此时已有2个 3 = 4 * 3\u002F4 不进行扩容\n    map.put(3, \u003Cspan class=\"hljs-string\"\u003E\"三\"\u003C\u002Fspan\u003E);\n    capacity = mapType.getDeclaredMethod(\u003Cspan class=\"hljs-string\"\u003E\"capacity\"\u003C\u002Fspan\u003E);\n    capacity.setAccessible(\u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E);\n    System.out.println(\u003Cspan class=\"hljs-string\"\u003E\"capacity : \"\u003C\u002Fspan\u003E + capacity.invoke(map)); \u002F\u002Fcapacity : 4 当前容量为2 插入该元素后size为 3 = 4 * 3\u002F4 不扩容\n\n    map.put(4, \u003Cspan class=\"hljs-string\"\u003E\"四\"\u003C\u002Fspan\u003E);\n    capacity = mapType.getDeclaredMethod(\u003Cspan class=\"hljs-string\"\u003E\"capacity\"\u003C\u002Fspan\u003E);\n    capacity.setAccessible(\u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E);\n    System.out.println(\u003Cspan class=\"hljs-string\"\u003E\"capacity : \"\u003C\u002Fspan\u003E + capacity.invoke(map));\u002F\u002Fcapacity : 8  当前容量为4 此时已有4个 4 &gt; 4 * 3\u002F4 开始扩容\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E上面的例子可以看出put后，hashmap确实有进行扩容，hashMap的扩容机制与其它的集合边长不太一样，它是通过当前hash桶个数乘2进行扩容\u003C\u002Fp\u003E\u003Cp\u003EhashMap主要是通过resize()方法扩容\u003C\u002Fp\u003E\u003Cp\u003E假设oldTable的key的hash为15，7，4，5，8，1，hashMap为初始容量为8的数组桶，存储位置如下\u003C\u002Fp\u003E\u003Ctable\u003E\u003Cthead\u003E\u003Ctr\u003E\u003Cth\u003Eindex\u003C\u002Fth\u003E\u003Cth\u003E0\u003C\u002Fth\u003E\u003Cth\u003E1\u003C\u002Fth\u003E\u003Cth\u003E2\u003C\u002Fth\u003E\u003Cth\u003E3\u003C\u002Fth\u003E\u003Cth\u003E4\u003C\u002Fth\u003E\u003Cth\u003E5\u003C\u002Fth\u003E\u003Cth\u003E6\u003C\u002Fth\u003E\u003Cth\u003E7\u003C\u002Fth\u003E\u003C\u002Ftr\u003E\u003C\u002Fthead\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003Ehash\u003C\u002Ftd\u003E\u003Ctd\u003E8\u003C\u002Ftd\u003E\u003Ctd\u003E1\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E4\u003C\u002Ftd\u003E\u003Ctd\u003E5\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E7，15\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\u003Cp\u003E当put一个新元素 假设为9，且加载因子使用默认的0.75，在内存空间中新的存储位置如下\u003C\u002Fp\u003E\u003Ctable\u003E\u003Cthead\u003E\u003Ctr\u003E\u003Cth\u003Eindex\u003C\u002Fth\u003E\u003Cth\u003E0\u003C\u002Fth\u003E\u003Cth\u003E1\u003C\u002Fth\u003E\u003Cth\u003E2\u003C\u002Fth\u003E\u003Cth\u003E3\u003C\u002Fth\u003E\u003Cth\u003E4\u003C\u002Fth\u003E\u003Cth\u003E5\u003C\u002Fth\u003E\u003Cth\u003E6\u003C\u002Fth\u003E\u003Cth\u003E7\u003C\u002Fth\u003E\u003Cth\u003E8\u003C\u002Fth\u003E\u003Cth\u003E9\u003C\u002Fth\u003E\u003Cth\u003E10\u003C\u002Fth\u003E\u003Cth\u003E11\u003C\u002Fth\u003E\u003Cth\u003E12\u003C\u002Fth\u003E\u003Cth\u003E13\u003C\u002Fth\u003E\u003Cth\u003E14\u003C\u002Fth\u003E\u003Cth\u003E15\u003C\u002Fth\u003E\u003C\u002Ftr\u003E\u003C\u002Fthead\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003Ehash\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E1\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E4\u003C\u002Ftd\u003E\u003Ctd\u003E5\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E7\u003C\u002Ftd\u003E\u003Ctd\u003E8\u003C\u002Ftd\u003E\u003Ctd\u003E9\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E15\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\u003Cp\u003E可以看到扩容之后8跑到了第9个位置，15跑到了第16个位置，旧的8，1，4，5在各自的链表上只有一个节点\u003C\u002Fp\u003E\u003Cp\u003E根据 \u003Cb\u003Ee.hash &amp; (newCap - 1)\u003C\u002Fb\u003E 相当于 与上15后，都为自己本身所以位置保持不变\u003C\u002Fp\u003E\u003Cp\u003E但是链表上不止有一个节点的情况，比如说上面的7，15存放的位置\u003C\u002Fp\u003E\u003Cp\u003E这个时候是先根据 \u003Cb\u003Ee.hash &amp; oldCap\u003C\u002Fb\u003E判断元素在数组的位置是否需要移动\u003C\u002Fp\u003E\u003Cp\u003E比如说 7 &amp; 8 = 0111 &amp; 1000 = 0 ; 15 &amp; 8 = 1111 &amp; 1000 = 1，规律是比较高位的第一个 比如说15为高位，第一个为1，如果高位为1那么与后结果也为1\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E当e.hash &amp; oldCap == 0时\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E链表上节点位置保持不变\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E当e.hash &amp; oldCap == 1时\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E链表上节点的位置为原位置的index + oldCap 比如说15，新的索引位置为7+8为15\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003E值得一提的是，jdk1.8的resize()方法相比与之前做了点优化，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但JDK1.8不会倒置，jdk8通过e.hash &amp; oldCap，通过0和1的值均匀把之前的冲突的节点分散到新的bucket了，这样做更为高效。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003E代码见【4.4.5 resize()方法】\u003C\u002Fp\u003E\u003Ch3\u003E5.loadFactor加载因子为何为0.75f\u003C\u002Fh3\u003E\u003Cblockquote\u003E\u003Cp\u003E加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之越小。\u003Cbr\u003E简单来说就是如果加载因子太小，空间利用率低，且太容易扩容对性能不太友好，设置太高，不及时扩容容易导致冲突几率大，将提高了查询成本。所以0.75是很合适的值，经过试验，在理想情况下,使用随机哈希码,节点出现的频率在hash桶中遵循泊松分布【在频率附近发生概率高，向两边对称下降。】\u003Cbr\u003E详细见 \u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fwww.cnblogs.com%2FDarrenChan%2Fp%2F8854859.html\"\u003E为什么HashMap中默认加载因子为0.75\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Ch3\u003E6.hashMap中一般使用什么类型的元素作为key，为什么？\u003C\u002Fh3\u003E\u003Cblockquote\u003E\u003Cp\u003E常用String，Integer这样的key\u003Cbr\u003E主要原因为\u003Cbr\u003E这些类是Immutable(不可变的)，String和基本类型的包装类规范的重写了hashCode()和equals()方法。作为不可变类天生是线程安全的，而且可以很好的优化比如可以缓存hash值，避免重复计算等等，如果采用可变的对象类型，可能出现put进去就无法查询到的情况。\u003Cbr\u003E如果想用自定义的类型作为键，那么需要遵守equals()和hashCode()方法的定义规则且不可变，对象插入到map后就不会再改变。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=http%3A%2F%2Fwww.cnblogs.com%2F0201zcr%2Fp%2F4810813.html\"\u003EHashMap的key可以是可变对象吗？\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Ch3\u003E7.源码中为什么要用transient修饰桶数组table\u003C\u002Fh3\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003Etransient Node&lt;K,V&gt;[] table;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E在java中，被transient关键字修饰的变量不会被默认的序列化机制序列化。\u003C\u002Fp\u003E\u003Cp\u003EhashMap实现了Serializable接口，通过实现\u003Ccode\u003EreadObject\u002FwriteObject\u003C\u002Fcode\u003E两个方法自定义了序列化的内容，size不用多说了，一般涉及到大小可以直接计算的就没必要再序列化。\u003C\u002Fp\u003E\u003Cp\u003E为什么不序列化table？原因有下\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003E1.table大多数情况是无法存满的。比如说桶数组容量是16，只put了一个元素，这会造成序列化未使用的部分。造成浪费。\u003C\u002Fp\u003E\u003Cp\u003E2.同一个键值对在不同jvm下，所处桶的位置可能是不同的，在不同的jvm下反序列化可能发生错误。(hashmap的get\u002Fput\u002Fremove等方法刚开始都是通过hash找到键所在的桶位置，就是数组下标，但如果键没有重写hashCode方法，就会调用Object的hashCode方法，而Object的hashcode方法是navtive(本地方法)的，这里的hashcode是对对象内存地址的映射得出的int结果，具体怎么计算不得而知，但是在不同jvm下，可能有不同的hashcode实现，这样产生的hash也不一样)。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Ch3\u003E8.HashMap的key如果为null，怎么查找值\u003C\u002Fh3\u003E\u003Cp\u003E我们知道hashMap只允许一个为null的key，如果key为null，因为key为null，那么hash为0，那么p = tab[i = (n - 1) &amp; hash 也一定为0，所以是从数组上第一个位置的链表下查找。\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003Estatic final int \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E(Object key) {\n    int h;\n    \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch1\u003E6.使用建议\u003C\u002Fh1\u003E\u003Cp\u003E1.默认情况下HashMap的容量是16，但是，如果用户通过构造函数指定了一个数字作为容量，那么Hash会选择大于该数字的第一个2的幂作为容量。(1-&gt;2、7-&gt;8、9-&gt;16)\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003E在初始化HashMap的时候，应该尽量指定其大小。尤其是当你已知map中存放的元素个数时。（《阿里巴巴Java开发规约》）\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003E这边可以看下hashMap的4个构造方法，一般采用3，但如果已经知道个数，建议用2(加载因子0.75很合适不建议改动)\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E\u002F\u002F1 自定义传初始容量和加载因子\npublic HashMap(int initialCapacity, \u003Cspan class=\"hljs-built_in\"\u003Efloat\u003C\u002Fspan\u003E loadFactor) {\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (initialCapacity &lt; 0)\n        throw new IllegalArgumentException(\u003Cspan class=\"hljs-string\"\u003E\"Illegal initial capacity: \"\u003C\u002Fspan\u003E +\n                                           initialCapacity);\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (initialCapacity &gt; MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (loadFactor &lt;= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(\u003Cspan class=\"hljs-string\"\u003E\"Illegal load factor: \"\u003C\u002Fspan\u003E +\n                                           loadFactor);\n    this.loadFactor = loadFactor;\n    this.threshold = tableSizeFor(initialCapacity);\n}\n\n\u002F\u002F2 自定义初始大小 调1构造方法，加载因子使用默认大小\npublic HashMap(int initialCapacity) {\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n}\n\n\u002F\u002F3 最常用的无参构造方法\npublic \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003EHashMap\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() {\n    this.loadFactor = DEFAULT_LOAD_FACTOR; \u002F\u002F all other fields defaulted\n}\n\n\u002F\u002F4 将别的map对象映射到自身存储，很少用\npublic HashMap(Map&lt;? extends K, ? extends V&gt; m) {\n    this.loadFactor = DEFAULT_LOAD_FACTOR;\n    putMapEntries(m, \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E);\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E这边讲解一下tableSizeFor方法。简述一下该方法的作用：\u003C\u002Fp\u003E\u003Cp\u003E如果自定义容量大小时(调1或2的构造方法)，传入一个初始容量大小，\u003Cb\u003E大于输入参数且最近的2的整数次幂的数\u003C\u002Fb\u003E。比如10，则返回16，75返回128\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003E不这么做的缺点\u003C\u002Fp\u003E\u003Cp\u003E假设HashMap需要放置1024个元素，由于没有设置初始容量大小，随着元素不断增加，容量7次被迫扩大。而resize过程需要重建hash表，这会严重影响性能。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E\u002F**\n * Returns a power of two size \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E the given target capacity.\n *\u002F\nstatic final int tableSizeFor(int \u003Cspan class=\"hljs-built_in\"\u003Ecap\u003C\u002Fspan\u003E) {\n    \u002F\u002F\u003Cspan class=\"hljs-built_in\"\u003Ecap\u003C\u002Fspan\u003E-1的目的是因为如果\u003Cspan class=\"hljs-built_in\"\u003Ecap\u003C\u002Fspan\u003E是2的幂数不做-1操作的话 那么最后执行完右移操作的话，返回的值将会是原有值得两倍。如果n为0的话，即\u003Cspan class=\"hljs-built_in\"\u003Ecap\u003C\u002Fspan\u003E=1，经过后面几次操作返回的为0，最后返回的capacity仍然为1(最后有加1的操作)\n    int n = \u003Cspan class=\"hljs-built_in\"\u003Ecap\u003C\u002Fspan\u003E - 1;\n    n |= n &gt;&gt;&gt; 1;\n    n |= n &gt;&gt;&gt; 2;\n    n |= n &gt;&gt;&gt; 4;\n    n |= n &gt;&gt;&gt; 8;\n    n |= n &gt;&gt;&gt; 16;\n    \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cb\u003E解释一下这段代码\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E在java中，|=的作用是比较两个对象是否相等\u003C\u002Fp\u003E\u003Cp\u003Ea|=b的意思就是把a和b按位或然后赋值给a\u003C\u002Fp\u003E\u003Cp\u003E以10为例整体流程大致如下\u003C\u002Fp\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E\u003Cimg alt=\"img_eadde165ab656c39debed0afc9a20492.png\" src=\"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fgold-user-assets\u002F2019\u002F9\u002F26\u002F16d6cc9bf3b23a1b~tplv-t2oaga2asx-image.image\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E算法流程\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E简单来说，这种运算最后会导致1占满了它自己所占位，比如说250，它的二进制为\u003C\u002Fp\u003E\u003Cp\u003E11111010，经过上面的或运算之后，最终将变为11111111，这种情况在加上1，就是大于这个数的最小二次幂。\u003C\u002Fp\u003E\u003Ch1\u003E7.总结\u003C\u002Fh1\u003E\u003Cp\u003EHashMap的设计与实现十分的巧妙。jdk8更是有很多提升，还没写这篇博客对于HashMap的理解仅仅只在表面。阅读源码后才发现里面还有不少的学问，由于本人水平有限，虽然花了很多时间写了很多但还有很多细节并不了解，比如说红黑树的代码实现细节，也有可能有几个地方描述错误或者不到位，如果文章有误请指正，以便于我及时修改和学习。\u003C\u002Fp\u003E\u003Ch1\u003E8.参考链接\u003C\u002Fh1\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=http%3A%2F%2Fwww.coolblog.xyz%2F2018%2F01%2F18%2FHashMap-%25E6%25BA%2590%25E7%25A0%2581%25E8%25AF%25A6%25E7%25BB%2586%25E5%2588%2586%25E6%259E%2590-JDK1-8%2F\"\u003EHashMap 源码详细分析(JDK1.8)\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fwww.cnblogs.com%2Fwoniu4%2Fp%2F8301099.html\"\u003EHashMap resize方法的理解（一)\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?spm=a2c4e.11153940.0.0.5bf05442WOllqe&amp;url=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F20733617\"\u003EJDK 源码中 HashMap 的 hash 方法原理是什么\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fwww.cnblogs.com%2Fdongguacai%2Fp%2F5599100.html\"\u003EhashMap死循环问题\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fblog.csdn.net%2FLovePluto%2Farticle%2Fdetails%2F79712473\"\u003E浅谈jdk8为何线程不安全\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Farticles\u002F651050\"\u003Ehttps:\u002F\u002Fyq.aliyun.com\u002Farticles\u002F651050\u003C\u002Fa\u003E\u003Cbr\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Cbr\u003E\u003C\u002Fp\u003E",ctime:"1569488258",mtime:"1600135304",rtime:"1569568499",draft_id:"6845076477000548365",view_count:2349,collect_count:h,digg_count:8,comment_count:g,hot_index:126,is_hot:d,rank_index:.00021707,status:n,verify_status:g,audit_status:n,mark_content:e,display_count:d,is_markdown:d},author_user_info:{user_id:"3227821871208174",user_name:"Forgotten在掘金",company:e,job_title:e,avatar_large:"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fmirror-assets\u002F16d667c91bd62c35136~tplv-t2oaga2asx-image.image",level:n,description:e,followee_count:35,follower_count:d,post_article_count:n,digg_article_count:d,got_digg_count:8,got_view_count:2500,post_shortmsg_count:d,digg_shortmsg_count:d,isfollowed:a,favorable_author:d,power:93,study_point:d,university:{university_id:f,name:e,logo:e},major:{major_id:f,parent_id:f,name:e},student_status:d,select_event_count:d,select_online_course_count:d,identity:d,is_select_annual:a,select_annual_rank:d,annual_list_type:d,extraMap:{},is_logout:d,annual_info:[],account_amount:d,user_growth_info:{user_id:3227821871208174,jpower:93,jscore:3.3,jpower_level:n,jscore_level:g,jscore_title:"预备掘友",author_achievement_list:[],vip_level:d,vip_title:e,jscore_next_level_score:15,jscore_this_level_mini_score:d},is_vip:a,become_author_days:d,collection_set_article_count:d},category:{category_id:"6809637769959178254",category_name:"后端",category_url:"backend",rank:g,back_ground:"https:\u002F\u002Flc-mhke0kuv.cn-n1.lcfile.com\u002Ffb3b208d06e6fe32.png",icon:"https:\u002F\u002Flc-mhke0kuv.cn-n1.lcfile.com\u002Fa2ec01b816abd4c5.png",ctime:1457483880,mtime:1432503193,show_type:3,item_type:n,promote_tag_cap:4,promote_priority:g,id:"6809637769959178254",name:"后端",title:"后端",alias:"backend"},tags:[{entriesCount:void 0,subscribed:a,id:"6809640445233070094",tag_id:"6809640445233070094",tag_name:"Java",color:"#DD2C2A",icon:"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fleancloud-assets\u002Ff8ee3cd45f949a546263.png~tplv-t2oaga2asx-image.image",back_ground:e,show_navi:d,ctime:1436156295,mtime:1667315974,id_type:9,tag_alias:e,post_article_count:109301,concern_user_count:355903,title:"Java",tagId:"6809640445233070094",articleCount:109301,subscribersCount:355903,createdAt:c,updatedAt:c}],user_interact:{id:6844903953566532000,omitempty:n,user_id:d,is_digg:a,is_follow:a,is_collect:a},org:{org_info:c,org_user:c,is_followed:a},req_id:"202211012323320102121381470992895E",status:{push_status:d},author_interact:c,extra:{boost_type:e},title:"HashMap源码解析，扩容机制及其思考",user:{id:"3227821871208174",self_description:void 0,followed:a,viewerIsFollowing:void 0,community:void 0,subscribedTagCount:d,wroteBookCount:d,boughtBookCount:d,isBindedPhone:a,level:n,user_id:"3227821871208174",user_name:"Forgotten在掘金",company:e,job_title:e,avatar_large:"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fmirror-assets\u002F16d667c91bd62c35136~tplv-t2oaga2asx-image.image",description:e,followee_count:35,follower_count:d,post_article_count:n,digg_article_count:d,got_digg_count:8,got_view_count:2500,post_shortmsg_count:d,digg_shortmsg_count:d,isfollowed:a,favorable_author:d,power:93,study_point:d,university:{university_id:f,name:e,logo:e},major:{major_id:f,parent_id:f,name:e},student_status:d,select_event_count:d,select_online_course_count:d,identity:d,is_select_annual:a,select_annual_rank:d,annual_list_type:d,extraMap:{},is_logout:d,annual_info:[],account_amount:d,user_growth_info:{user_id:3227821871208174,jpower:93,jscore:3.3,jpower_level:n,jscore_level:g,jscore_title:"预备掘友",author_achievement_list:[],vip_level:d,vip_title:e,jscore_next_level_score:15,jscore_this_level_mini_score:d},is_vip:a,become_author_days:d,collection_set_article_count:d,juejinPower:93,jobTitle:e,roles:{isBookAuthor:a,isFavorableAuthor:a,isCobuilder:a,isAdmin:a},username:"Forgotten在掘金",blogAddress:void 0,selfDescription:e,beLikedCount:8,beReadCount:2500,followerCount:d,followingCount:35,collectionCount:d,createdCollectionCount:d,followingCollectionCount:d,postedPostsCount:n,pinCount:d,likedArticleCount:d,likedPinCount:d,avatar:"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fmirror-assets\u002F16d667c91bd62c35136~tplv-t2oaga2asx-image.image",latestLoginedInAt:c,createdAt:c,updatedAt:c,phoneNumber:e,titleDescription:e,followeesCount:35,applyEventCount:d,need_lead:d,followTopicCnt:void 0},viewCount:void 0,commentsCount:g,isEvent:void 0,abstract:"位运算是对整数在内存中的二进制位进行操作。 在hashMap源码中有很多使用位运算的地方。例如: 我们都知道&在java中表示与操作&表示按位与，这里的位是指二进制位。都为1才为真(1),否则结果为0，举个简单的例子 在Java中，所有数据的表示方法都是以补码的形式表示，如果没…",latestCommentAt:c,createdAt:new Date(1569488258000),updatedAt:c,isTopicEvent:a,likedCount:8,likeCount:8,content:"\u003Ch1\u003E1.概述\u003C\u002Fh1\u003E\u003Cblockquote\u003E\u003Cp\u003EHashMap是日常java开发中常用的类之一，是java设计中非常经典的一个类，它巧妙的设计思想与实现，还有涉及到的数据结构和算法，，值得我们去深入的学习。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cblockquote\u003E\u003Cp\u003E简单来说，HashMap就是一个散列表，是基于哈希表的Map接口实现，它存储的内容是键值对 (key-value) 映射，并且键值允许为null(键的话只允许一个为null)。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Ch3\u003E1.1 注意事项\u003C\u002Fh3\u003E\u003Cblockquote\u003E\u003Cp\u003E①根据键的hashCode存储数据。(String，和Integer、Long、Double这样的包装类都重写了hashCode方法，String比较特殊根据ascil码还有自己的算法计算，Double做位移运算【具体看源码的hashcode实现】，Integer，Long包装类则是自身大小int值)，\u003Cbr\u003EHashMap中的结构不能有基本类型，一方面是基本类型没有hashCode方法，还有HashMap是泛型结构，泛型要求包容对象类型，而基本类型在java中不属于对象。\u003Cbr\u003E②HashMap的存储单位是Node&lt;k,v&gt;,可以认作为节点。\u003Cbr\u003E③Hashmap中的扩容的个数是针对size(内部元素(节点)总个数)，而不是数组的个数。比如说初始容量为16，第十三个节点put进来，不管前面十二个占的数组位置如何，就开始扩容。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Ch3\u003E1.2 hashmap几个特征\u003C\u002Fh3\u003E\u003Ctable\u003E\u003Cthead\u003E\u003Ctr\u003E\u003Cth\u003E特征\u003C\u002Fth\u003E\u003Cth\u003E说明\u003C\u002Fth\u003E\u003C\u002Ftr\u003E\u003C\u002Fthead\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E是否允许重复数据\u003C\u002Ftd\u003E\u003Ctd\u003Ekey如果重复会覆盖，value允许重复\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003EhashMap是否有序\u003C\u002Ftd\u003E\u003Ctd\u003E无序，这里的无序指的是遍历HashMap的时候，得到的顺序大都跟put进去的顺序不一致\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003EhashMap是否线程安全\u003C\u002Ftd\u003E\u003Ctd\u003E非线程安全，因为里面的实现不是同步的，如果想要线程安全，推荐使用\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E键值是否允许为空\u003C\u002Ftd\u003E\u003Ctd\u003Ekey和value都允许为空，但只允许一个为空\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\u003Ch1\u003E2.一些概念\u003C\u002Fh1\u003E\u003Ch3\u003E2.1.位运算\u003C\u002Fh3\u003E\u003Cp\u003E位运算是对整数在内存中的二进制位进行操作。\u003C\u002Fp\u003E\u003Cp\u003E在java中 &gt;&gt; 表示右移 若该数为正，则高位补0，若为负数，高位补1\u003C\u002Fp\u003E\u003Cp\u003E&lt;&lt;表示左移 跟右移相反 如果是正数在低位补0\u003C\u002Fp\u003E\u003Cp\u003E例如20的二进制为0001 0100 20&gt;&gt;2为 0101 0000 结果为5(左高右低)\u003C\u002Fp\u003E\u003Cp\u003E20&lt;&lt;2 为 0101 0000 则为80\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003Ejava中&gt;&gt;&gt;和&gt;&gt;的区别\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E&gt;&gt;&gt;表示无符号右移，也叫逻辑右移。不管数字是正数还是负数，高位都是补0\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E在hashMap源码中有很多使用位运算的地方。例如:\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E\u002F\u002F之所以用1 &lt;&lt; 4不直接用16，0000 0001 -&gt; 0001 0000 则为16，如果用16的话最后其实也是要转换成0和1这样的二进制，位运算的计算在计算机中是非常快的，直接用位运算表示大小以二进制形式去运行，在jvm中效率更高。\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;  \u002F\u002F初始化容量\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cb\u003E注意:左移没有&lt;&lt;&lt;运算符\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Ch3\u003E2.2 位运算符-(与(&amp;)、非(~)、,或(|)、异或(^))\u003C\u002Fh3\u003E\u003Ch5\u003E①与运算(&amp;)\u003C\u002Fh5\u003E\u003Cp\u003E我们都知道&amp;在java中表示与操作&amp;表示按位与，这里的位是指二进制位。都为1才为真(1),否则结果为0，举个简单的例子\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003ESystem.out.println(9 &amp; 8); \u002F\u002F1&amp;1=1，1&amp;0 0&amp;1 0&amp;0都=0，因此1001 1000 -&gt; 1000 输出为8\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch5\u003E②非运算(~)\u003C\u002Fh5\u003E\u003Cp\u003E\u003Cb\u003E源码 -&gt; 取反 -&gt; 反码 -&gt; 加1 -&gt; 补码 -&gt; 取反 -&gt; 按位非值\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E在Java中，所有数据的表示方法都是以补码的形式表示，如果没有特殊说明，Java中的数据类型默认是int,int数据类型的长度是8位，一位是四个字节，就是32字节，32bit.\u003C\u002Fp\u003E\u003Cp\u003E例如5的二进制为0101\u003C\u002Fp\u003E\u003Cp\u003E补码后为 00000000 00000000 00000000 00000101\u003C\u002Fp\u003E\u003Cp\u003E取反后为 11111111 11111111 11111111 11111010\u003C\u002Fp\u003E\u003Cp\u003E【因为高位为1 所以源码为负数，负数的补码是其绝对值源码取反，末尾再加1】\u003C\u002Fp\u003E\u003Cp\u003E所以反着来末尾减1得到反码然后再取负数\u003C\u002Fp\u003E\u003Cp\u003E末位减1：11111111 11111111 11111111 11111001\u003C\u002Fp\u003E\u003Cp\u003E【后八位前面4位不动 后面 减1 1010减1 相当于 10-1为9 后四位就是 1001 】\u003C\u002Fp\u003E\u003Cp\u003E取反后再负数： 00000000 00000000 00000000 00000110 为-6\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003ESystem.out.println(~ 5); \u002F\u002F输出-6\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch5\u003E③或运算(|)\u003C\u002Fh5\u003E\u003Cp\u003E\u003Cb\u003E只要有一个为1，结果为1，否则都为0\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003ESystem.out.println(5 | 15); \u002F\u002F输出为15，0101或上1111,结果为1111\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch5\u003E④异或运算(^)\u003C\u002Fh5\u003E\u003Cp\u003E\u003Cb\u003E相同为0(假)，不同为真(1)\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003ESystem.out.println(5 ^ 15); \u002F\u002F输出10 0101异或1111结果为1010\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Ch3\u003E2.3 hashcode\u003C\u002Fh3\u003E\u003Cp\u003Ehash意为散列，hashcode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值，顶级父类Object类中含hashCode方法(native本地方法，是根据地址来计算值)，有一些类会重写该方法，比如String类。\u003C\u002Fp\u003E\u003Cp\u003E重写的原因。为了保证一致性，如果对象的equals方法被重写，那么对象的hashcode()也尽量重写。\u003C\u002Fp\u003E\u003Cp\u003E简单来说 就是hashcode()和equals()需保持一致性，如果equals方法返回true，那么两个对象的hashCode 返回也必须一样。\u003C\u002Fp\u003E\u003Cp\u003E否则可能会出现这种情况。\u003C\u002Fp\u003E\u003Cp\u003E假设一个类重写了equals方法，其相等条件为属性相等就返回true，如果不重写hashcode方法，那么依据就是Object的依据比较两个对象内存地址，则必然不相等，这就出现了equals方法相等但是hashcode不等的情况，这不符合hashcode的规则，这种情况可能会导致一系列的问题。\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E因此，在hashMap中，key如果使用了自定义的类，最好要合理的重写Object类的equals和hashcode方法。\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Ch3\u003E2.4 哈希桶\u003C\u002Fh3\u003E\u003Cp\u003E哈希桶的概念比较模糊，个人理解是数组表中一块区域结果下面的单向链表组成的，在hashmap中，这个单向链表的头部是所在数组上第一个元素，单向链表如果过长超过8，那么这个\"桶\"就可能变成了红黑树(前提是数组长度达到64）。\u003C\u002Fp\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Ch3\u003E2.5 hash函数\u003C\u002Fh3\u003E\u003Cp\u003E在程序设定中，把一个对象通过某种算法或者说转换机制对应到一个整形。\u003C\u002Fp\u003E\u003Cp\u003E主要用于解决冲突的。\u003C\u002Fp\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Ch3\u003E2.6 哈希表\u003C\u002Fh3\u003E\u003Cp\u003E也称为散列表，这也是一种数据结构，可以根据对象产生一个为整数的散列码(hashCode)。\u003C\u002Fp\u003E\u003Ch4\u003E\u003C\u002Fh4\u003E\u003Ch3\u003Ehash冲突\u003C\u002Fh3\u003E\u003Cp\u003EHashMap之所以有那么快的查询速度，是因为他的底层是由数组实现，通过key计算散列码(hashCode)决定存储的位置，HashMap中通过key的hashCode来计算hash值，只要hashCode相同，hash值也一样，但是可能存在存的对象多了，不同对象计算出的hash值相同，这就是hash冲突。\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E举个例子\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003EHashMap&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();\nmap.put(\u003Cspan class=\"hljs-string\"\u003E\"Aa\"\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E\"haha\"\u003C\u002Fspan\u003E);\nmap.put(\u003Cspan class=\"hljs-string\"\u003E\"BB\"\u003C\u002Fspan\u003E,\u003Cspan class=\"hljs-string\"\u003E\"heihei\"\u003C\u002Fspan\u003E);\nSystem.out.println(\u003Cspan class=\"hljs-string\"\u003E\"Aa\"\u003C\u002Fspan\u003E.hashCode()); \u002F\u002F2112\nSystem.out.println(\u003Cspan class=\"hljs-string\"\u003E\"BB\"\u003C\u002Fspan\u003E.hashCode()); \u002F\u002F2112\n\u002F\u002F这里的Aa和BB为String型，String类重写了\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003ECode方法(根据ascil码和特定的算法来计算，虽然很巧妙但也难以避免不对对象\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003ECode相同的情况)，Aa和BB的\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003ECode值相同，相同的HashCode的\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E值相同 \n\u002F\u002F根据源码就算key不相同 但key.hashCode()相同 则会返回相同的\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E，导致\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E冲突\nstatic final int \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E(Object key) {\u002F\u002F取关键key的\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E值\n    int h;\n    \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\u002F\u002F任何小于2的16次方的数 右移16位都为0 2的16次方&gt;&gt;&gt;16刚好为1 任何一个数和0按位异或都为这个数本身(1和0为1 0和0为0)，所以这个\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E()函数对于null的\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E值 仅在hashcode大于2的16次方才会调整值,这边16设计的很巧妙，因为int刚好是32位的取中间位数\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003E2.7 二叉查找树和红黑树\u003C\u002Fh3\u003E\u003Cp\u003E红黑树是一种自平衡二叉查找树。是一种数据结构，又称二叉b树，（→_→ 2b树？），红黑树本质上也是二叉查找树。所以先理解下二叉查找树。\u003C\u002Fp\u003E\u003Ch4\u003E2.7.1二叉查找树\u003C\u002Fh4\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E二叉查找树，又称有序二叉树，已排序二叉树\n它的三大特点如下\n1.左子树上所有结点的值均小于或等于它的根结点的值。\n2.右子树上所有结点的值均大于或等于它的根结点的值。\n3.左、右子树也分别为二叉排序树。\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E\u003Cimg alt=\"img_15bc610b523331178a92ad63dcfac5f8.png\" src=\"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fgold-user-assets\u002F2019\u002F9\u002F26\u002F16d6cc9bf1be2e12~tplv-t2oaga2asx-image.image\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E二叉树.png\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Ch4\u003E2.7.2 红黑树(RBTree)\u003C\u002Fh4\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E由于二叉查找树可能存在难以平衡呈线性的缺陷，所以出现的红黑树的概念。顾名思义，红黑树是只有红色和黑色节点的二叉树。\n它的5大性质如下。\n1.节点是红色或黑色。\n2.根节点是黑色。\n3.每个叶子节点都是黑色的空节点（NIL节点）。\n4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)\n5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E简单来说红黑树是一种自平衡二叉查找树，相比于普通的二叉查找树，它的数据结构更为复杂，但是在复杂的情况也能通过自平衡(变色，左右旋转)保持良好的性能。\u003C\u002Fp\u003E\u003Cp\u003E关于红黑树，很形象的一组漫画，查看\u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzIxMjE5MTE1Nw%3D%3D%26amp%3Bmid%3D2653191832%26amp%3Bidx%3D1%26amp%3Bsn%3D12017161025495c6914b5ab9397baa59%26amp%3Bchksm%3D8c990c42bbee8554ba02eb83d839123bd3bead6ffc736111456ea77367a3df75750cf88016e0%26amp%3Bscene%3D21%23wechat_redirect\"\u003E这里\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003E在线模拟红黑树增删的地址\u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fwww.cs.usfca.edu%2F%7Egalles%2Fvisualization%2FRedBlack.html\"\u003E地址1\u003C\u002Fa\u003E、 \u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fsandbox.runjs.cn%2Fshow%2F2nngvn8w\"\u003E地址2\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E红黑树的时间复杂度为【吐槽下简书这边如果用数学公式太蛋疼了】：\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003EO(logn)\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003E\u003C\u002Fp\u003E\u003Cdiv\u003E\u003Cdiv\u003E它的高度为:[logN,logN+1]（理论上，极端的情况下可以出现RBTree的高度达到2\u003C\u002Fdiv\u003ElogN，但实际上很难遇到）。\u003C\u002Fdiv\u003E*\u003Cp\u003E\u003C\u002Fp\u003E\u003Cp\u003E此外，由于它的设计任何不平衡将在三次旋转内解决。\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E红黑树和avl树(最早的自平衡二叉树)的比较：\navl更加平衡，查询速率稍强于红黑树，但是插入和删除红黑树完爆avl树，可能由于\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003EMap的增删也挺频繁的，所以综合考虑而选择红黑树。\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cb\u003E总结：红黑树是种可以通过变色旋转的自平衡二叉查找树，对于hashMap来说，使用红黑树的好处在于，当有多个元素hash相同在同一数组下标的时候，使用红黑树在查找这些hash冲突的元素更快，它的时间复杂度从遍历链表O(n)降到O(logN)。\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Ch3\u003E2.8 复杂度\u003C\u002Fh3\u003E\u003Cp\u003E算法复杂度分时间复杂度和空间复杂度。\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E时间复杂度：执行算法所需要的计算工作量\n空间复杂度：执行算法所需要内存空间大小\n时间和空间都是计算机资源的体现，算法的复杂性体现在运行该算法时计算机所需资源的大小。\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cb\u003E这里重点讲下时间复杂度\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E(1)时间频度\n用T(n)表示\n一个算法执行所消耗的时间，理论上不能算出来而是通过运行测试得知，但不可能也没必要对每个算法都做上机测试，只需知道哪个算法花费时间多哪个花费少即可。在算法中一个算法花费的时间和这个算法执行的次数成正比。\n在一个算法中，语句执行次数称为时间频度(或称为语句频度)，记做为T(n)，这里的n代表问题的规模。暂且不考虑这个T是啥，把它理解为一个函数。\n(2)时间复杂度 \n用Ｏ(f(n))表示\n当n变化时，时间频度T(n)也会不断变化，但是它是个不确定的函数，我们想知道它呈现的规律是什么样的。这个时候引入了时间复杂度的概念。\n前面说T(n)是个不确定的函数，它代表算法中基本操作重复执行的次数是问题规模n的某个函数。\n假设有某个辅助函数f(n),当n趋近∞，T(n)\u002Ff(n)的极限值不为0切位常数，那么可以认为f(n)和T(n)为同一数量级的函数，记做为T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。\n\nf(n)虽然没有规定但一般都尽可能取简单的函数\n例如 O(2n²+n +1) = O (3n²+n+3) = O (7n² + n) = O ( n² ) 省去了系数,只保留最高阶项。\n时间频度不同时，时间复杂度有可能相同，例如T(n)=n²+3n+4与T(n)=4n²+2n+1它们的频度不同，但时间复杂度相同，都为O(n²)。\n\n总结两者关系:时间复杂度就是对时间频度函数的一层包装，它的特点(大O表示法)为\n①省去系数为1处理②保留最高项\n如果把T(n)当做为一棵树，那么O(f(n))只关心其主干部分。\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cb\u003E常见算法的时间复杂度从小到大依次为\u003C\u002Fb\u003E\u003Cbr\u003E\u003C\u002Fp\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E\u003Cimg alt=\"img_8f75b001aae9edc9b86bb1e9fc7c7f6d.png\" src=\"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fgold-user-assets\u002F2019\u002F9\u002F26\u002F16d6cc9bed0cf8cc~tplv-t2oaga2asx-image.image\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E复杂度比较\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E求解算法的时间复杂度具体步骤为：\n①找出算法中执行次数最多的基本语句，一般是最内层的循环体。\n②计算基本语句的数量级\n③将基本语句执行次数的数量级放入大O记号中\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cb\u003E举几个例子\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003EO(1),又称常数阶，一般来说算法中没有循环体，执行次数为常数那么时间复杂度就为O(1)，例如\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003Eint sum = 0,n = 100; \u002F\u002F执行一次  \nsum = (1+n)*n\u002F2; \u002F\u002F执行一次  \nSystem.out.println (sum); \u002F\u002F执行一次 \n\u002F\u002F上面的算法运行次数为f(n)=3,那么根据大O表示法，该算法的时间复杂度为O(1)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch5\u003E\u003C\u002Fh5\u003E\u003Cp\u003E\u003Cb\u003E为什么O(logN)，对数阶不用底数\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E如红黑树的查找复杂为O(logN)\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E这里面有个可能存在的疑问，有时候时间复杂度都用包含O(logN)这样的描述 但是没有明确说明n的底数是多少，通常底数为2来计算\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E这种描述其实也是合理的，算法中log级别的时间复杂度都是由于使用了分治思想,这个底数直接由分治的复杂度决定。当n趋近于无穷大，两个大小比较也只是一个常数，所以这种时候O(logN)统一代表对数复杂度。\u003Cbr\u003E\\lim_{n\\rightarrow+\\infty} Ο(\\log_x{n})\u002FΟ(\\log_y{n}) = C\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E其它简单举例\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Ctable\u003E\u003Cthead\u003E\u003Ctr\u003E\u003Cth\u003E描述\u003C\u002Fth\u003E\u003Cth\u003E增长数量级\u003C\u002Fth\u003E\u003Cth\u003E典型代码\u003C\u002Fth\u003E\u003Cth\u003E说明\u003C\u002Fth\u003E\u003C\u002Ftr\u003E\u003C\u002Fthead\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E常数阶\u003C\u002Ftd\u003E\u003Ctd\u003E1\u003C\u002Ftd\u003E\u003Ctd\u003Ea = b + c\u003C\u002Ftd\u003E\u003Ctd\u003E普通简单算法操作\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E对数阶\u003C\u002Ftd\u003E\u003Ctd\u003ElogN\u003C\u002Ftd\u003E\u003Ctd\u003E二叉树中的二分法\u003C\u002Ftd\u003E\u003Ctd\u003E二分策略\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E线性级别\u003C\u002Ftd\u003E\u003Ctd\u003EN\u003C\u002Ftd\u003E\u003Ctd\u003Efor(int i = 0;i &lt; 10; i++) {...}\u003C\u002Ftd\u003E\u003Ctd\u003E普通单层循环算法\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E平方级别\u003C\u002Ftd\u003E\u003Ctd\u003EN²\u003C\u002Ftd\u003E\u003Ctd\u003Efor(int i = 0;i &lt; 10; i++) {for(int j = 0; j &lt; 10) {...}}\u003C\u002Ftd\u003E\u003Ctd\u003E双层循环，例如冒泡排序\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E指数级别\u003C\u002Ftd\u003E\u003Ctd\u003E2的n次方\u003C\u002Ftd\u003E\u003Ctd\u003E一个背包大小一定时，找出不大于背包所有物品组合，假设有3个物品，a，b，c，可能的组合有8种。(a,b,c,ab,ac,bc,abc+空(背包太小一个都容纳不下))\u003C\u002Ftd\u003E\u003Ctd\u003E穷举查找(背包问题\u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fwww.cnblogs.com%2Ftinaluo%2Fp%2F5264190.html\"\u003Ehttps:\u002F\u002Fwww.cnblogs.com\u002Ftinaluo\u002Fp\u002F5264190.html\u003C\u002Fa\u003E)\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Ch1\u003E3. HashMap的内部实现(基于jdk1.8)\u003C\u002Fh1\u003E\u003Cblockquote\u003E\u003Cp\u003E刚开始看hashMap源码的时候，感觉思路很乱不知道写的啥东西，所以还是得从它的【数据结构】开始入手。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E\u003Cimg alt=\"img_550edf98975a3d557599d6792129fba5.jpe\" src=\"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fgold-user-assets\u002F2019\u002F9\u002F26\u002F16d6cc9bef779b0b~tplv-t2oaga2asx-image.image\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E不同于一般类的数据结构，从结构来讲 HashMap = 数组 + 链表 + 红黑树(1.8开始加入，大程度的优化了HashMap的性能)\narrayList  数组\nlinkedList 双向链表 查询效率慢，需通过遍历，新增或删除快，比如说删除一个元素 知道那个元素的上下引用 并改变关联上下元素的引用指向即可。\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003E3.1 数组和链表\u003C\u002Fh3\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E\u003Cimg alt=\"img_fdee83a22ddec90d5d4b5779804d0cd8.png\" src=\"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fgold-user-assets\u002F2019\u002F9\u002F26\u002F16d6cc9beec7d8de~tplv-t2oaga2asx-image.image\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E数组和链表.png\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Ch3\u003E3.2 HashMap数据结构(数组+链表+红黑树)\u003C\u002Fh3\u003E\u003Cblockquote\u003E\u003Cp\u003E在jdk8以前，如果发生频繁碰撞的话，查找时间复杂度是O(1) + O(n) (先找在数组的位置再找链表)，n如果比较大则严重影响了查找性能，而到了jdk8引入红黑树,O(1) + O(logN)。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E\u003Cimg alt=\"img_97ec833243a8d841f179b1fd3d54c982.png\" src=\"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fgold-user-assets\u002F2019\u002F9\u002F26\u002F16d6cc9bf47291f9~tplv-t2oaga2asx-image.image\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003Ehashmap.png\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Ch2\u003E大致思路\u003C\u002Fh2\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E①数组的优点是查询快，链表的优点是增删快，红黑树查询性能较好，\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003EMap的存储方式结合了它们的优点，那么\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003EMap的存储单元又可以在数组里，又可以在某个数组下的链表里。还有可能在红黑树当中。\n②我们已经知道HashMap是键值对的存在，且可以为各种类型，那么它又是以键值对的方式存在，它的最小存储单位是以Node节点为存储单位。\n这个Node结构大概有Key，Value，记录所在数组索引，以及记录链表指针的东西。\n大概结构如下\nstatic class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {\n  final int \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E;\n  final K key;\n  V value;\n  Node&lt;K,V&gt; next;\n  ...\n}\n\n③新来的Node节点怎么放?\nHashMap利用hashcode来确定存放的位置，但是又有个疑问，假设map对象key为String型\nHashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();\nmap.put(\u003Cspan class=\"hljs-string\"\u003E\"1\"\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E\"first\"\u003C\u002Fspan\u003E);\n\n\u002F\u002F这个时候看put方法 \nput方法的大致思路为\n①对key做\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E运算，通过\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E值计算index下标位置\n②如果没冲突直接放在桶上\n③如果冲突了，以链表的形式存在桶里面，达到一定条件链表变为红黑树\n④如果节点已经存在，则替换旧的value(保证唯一性)\n⑤如果桶的个数超过了 加载因子乘当前容量，则做resize操作\n\n\u002F\u002F可以注意到有个\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E函数\npublic V put(K key, V value) {\n   \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E putVal(\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E(key), key, value, \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E);\n}\n\n\u002F\u002F\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E函数 \nstatic final int \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E(Object key) {\n   int h;\n   \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n}\n\n\u002F\u002F上述代码String类型的1的Hashcode为49超过了HashMap的初始长度16，这个时候\u003Cspan class=\"hljs-string\"\u003E\"1\"\u003C\u002Fspan\u003E这个key放在哪。这里\n\u002F\u002F通过巧妙的设计存放在合适的位置 4.3.3做分析\np = tab[i = (n - 1) &amp; \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E]，\n\n\n\u002F\u002F这里的p为Node&lt;K,V&gt;对象，n为当前哈希桶数组长度，进行与运算后，因为这是第一个插入的元素，无需扩容长度为16,那么49 &amp; 15 = 1，说明在的第二个位置。\n\n④新节点插入后什么时候开始扩容\n接下来不断的插入的元素 经过\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E函数和计算索引位置后，都可以根据它的散列性插入到不同的16个位置，\n当元素个数达到16 * 0.75 即12时，继续插入新的时候，开始扩容。\n【这里注意一下并不是说占满12个位置才开始扩容，而是12个节点，根据散列性分布12个节点，占...5，6，7，8...个位置都有可能,比如说key为Integer类型，假如key为Integer类型，有五个节点key分别为3，19，12，28，44这个时候3，19在同一个位置，12，28，44在同一个位置，这个时候5个节点就占了两个位置】\n\n\n⑤resize()方法进行扩容操作。\n1.先判断节点数组是否为空，并取它的容量(节点个数)，创建新数组，大小时新的capacity\n如果不为空：\n如果容量超过最大值不做扩容，否则位运算一位做容量乘2处理，\n如果为空：\n桶数组容量为默认容量16，即有默认放16个桶，阈值默认为默认容量乘默认加载因子 12\n2.将旧数组的元素放到新数组中，重新做映射\n如果旧的数组不为空，则遍历桶数组，并将键值对映射到新的桶数组中[树节点和链表节点做不同操作]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch1\u003E4.源码分析\u003C\u002Fh1\u003E\u003Ch3\u003E4.1 基本存储单位Node节点\u003C\u002Fh3\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003Estatic class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { \u002F\u002F实现Entry接口 存储的是键值对的映射\n    final int \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E; \u002F\u002F\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E值，用于记录数组所在位置\n    final K key; \u002F\u002F用于匹配\n    V value; \u002F\u002F值\n    Node&lt;K,V&gt; next; \u002F\u002F用于记录单链表下一节点 用于解决\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E冲突(即\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E值一样该存在哪里的问题)\n    Node(int \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E, K key, V value, Node&lt;K,V&gt; next) {\n        this.hash = \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E;\n        this.key = key;\n        this.value = value;\n        this.next = next;\n    }\n    public final K \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003EgetKey\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E()        { \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E key; }\n    public final V \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003EgetValue\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E()      { \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E value; }\n    public final String \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003EtoString\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() { \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E key + \u003Cspan class=\"hljs-string\"\u003E\"=\"\u003C\u002Fspan\u003E + value; }\n    public final int \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003EhashCode\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() {\n        \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E Objects.hashCode(key) ^ Objects.hashCode(value);\n    }\n    public final V \u003Cspan class=\"hljs-built_in\"\u003Eset\u003C\u002Fspan\u003EValue(V newValue) {\u002F\u002F赋值\n        V oldValue = value;\n        value = newValue;\n        \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E oldValue;\n    }\n    public final boolean equals(Object o) {\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (o == this)\n            \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (o instanceof Map.Entry) {\n            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (Objects.equals(key, e.getKey()) &amp;&amp;\n                Objects.equals(value, e.getValue()))\n                \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n        }\n        \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n    }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003E4.2 HashMap中的几个重要实现：hash函数，put、get、resize\u003C\u002Fh3\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E\u002F\u002Fput\npublic V put(K key, V value) {\n    \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E putVal(\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E(key), key, value, \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E);\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003Efinal V putVal(int \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    \u002F\u002F哈希表数组节点 \n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n    \u002F\u002F如果为空 调用resize以默认大小16扩容 \n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    \u002F\u002F通过(n - 1) &amp; \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E计算存放索引位置 此处设计很巧妙\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E ((p = tab[i = (n - 1) &amp; \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E]) == null)\n      \u002F\u002F如果tab[i]为空 该下标下没有节点 则直接新建一个Node放在该位置 \n        tab[i] = newNode(\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E, key, value, null);\n    \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n        \u002F\u002F下标上有节点 说明有\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E冲突\n        Node&lt;K,V&gt; e; K k;\n        \u002F\u002F如果插入的新节点key已经存在，那么直接覆盖整个节点\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (p.hash == \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E &amp;&amp;\n            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n            e = p;\n        \u002F\u002F如果为红黑树节点\n        \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (p instanceof TreeNode)\n            \u002F\u002F调用红黑树插入键值对的putTreeVal方法\n            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E, key, value);\n        \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n            \u002F\u002F不管tab[index]是否为空，p节点已经为 tab[index]上\n            \u002F\u002F如果有冲突 且不为红黑树节点 那么此时遍历链表节点 binCount计算链表长度\n            \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (int binCount = 0; ; ++binCount) {\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E ((e = p.next) == null) {\n                    p.next = newNode(\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E, key, value, null);\n                   \u002F\u002F链表长度大于等于7，调用treeifyB\u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E对链表进行树化\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (binCount &gt;= TREEIFY_THRESHOLD - 1) \u002F\u002F -1 \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E 1st\n                        treeifyB\u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E(tab, \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E);\n                    \u003Cspan class=\"hljs-built_in\"\u003Ebreak\u003C\u002Fspan\u003E;\n                }\n                \u002F\u002F遍历链表时发现重复 覆盖并跳出循环\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (e.hash == \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E &amp;&amp;\n                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                    \u003Cspan class=\"hljs-built_in\"\u003Ebreak\u003C\u002Fspan\u003E;\n                p = e;\n            }\n        }\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (e != null) { \u002F\u002F existing mapping \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E key\n            V oldValue = e.value;\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E oldValue;\n        }\n    }\n    ++modCount;\n    \u002F\u002F插入成功后 再根据实际判断是否到到阈值 比如说现在容量16(桶的个数16) 正在插第13个元素时 到达则扩容 \n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (++size &gt; threshold)\n        resize();\n    afterNodeInsertion(evict);\n    \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E null;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003Eget方法\u003C\u002Fh3\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003Epublic V get(Object key) {\n    Node&lt;K,V&gt; e;\n    \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E (e = getNode(\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E(key), key)) == null ? null : e.value;\n}\n\nfinal Node&lt;K,V&gt; getNode(int \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E, Object key) {\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;\n    \u002F\u002F先定位键值对在所在桶的位置\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;\n        (first = tab[(n - 1) &amp; \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E]) != null) {\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (first.hash == \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E &amp;&amp; \u002F\u002F always check first node \n            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))\n            \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E first;\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E ((e = first.next) != null) {\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (first instanceof TreeNode)\n                \u002F\u002F如果是红黑树节点 通过红黑树查找方法查找\n                \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E ((TreeNode&lt;K,V&gt;)first).getTreeNode(\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E, key);\n            \u003Cspan class=\"hljs-keyword\"\u003Edo\u003C\u002Fspan\u003E {\n                \u002F\u002F对链表查找\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (e.hash == \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E &amp;&amp;\n                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                    \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E e;\n            } \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E ((e = e.next) != null);\n        }\n    }\n    \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E null;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003E4.4.5 resize()\u003C\u002Fh3\u003E\u003Cp\u003E扩容就是重新定义容量，在hashmap中，如果不断的put元素，而hashMap对象中的数组无法装得下更多对象时，对象就需要进行扩容，扩大数组长度。这边注意的是：\u003C\u002Fp\u003E\u003Cp\u003E\u003C\u002Fp\u003E\u003Cdiv\u003E\u003Cdiv\u003E①假如初始大小为默认值16，什么时候扩容，我们可以知道阈值是16\u003C\u002Fdiv\u003E0.75即12，这个12是指hashMap的size(全局变量，每次put+1.remove-1)，put后为大于12即13时开始执行resize方法扩容。\u003C\u002Fdiv\u003E*\u003Cp\u003E\u003C\u002Fp\u003E\u003Cp\u003E②\u003Cb\u003E在java中数组是不能够自动扩容的，是采用一个新的大容量数组代替原有的小数组，就好比用一个小桶装水，如果想用一个桶装更多的水，就换一个大桶再把原来小桶的水装过去。\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E③扩容后，普通链表上的节点包括红黑树都得重新映射。\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003E对于hashmap来说\u003Cbr\u003E什么时候换大桶：达到阈值的时候\u003Cbr\u003E换多大的桶：原有小桶的两倍大小\u003Cbr\u003E但桶的大小也是有限的，对于hashMap，最大的桶能容纳包含2^30个数，大于的话就不再扩容，就随里面碰撞了。(实际上也很难用到这么大的容量)\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003Efinal Node&lt;K,V&gt;[] \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003Eresize\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() {\n    \u002F\u002Ftable为全局变量transient Node&lt;K,V&gt;[] table; 赋值给oldTab\n    Node&lt;K,V&gt;[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\u002F\u002F旧表数组个数\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (oldCap &gt; 0) { \u002F\u002F如果旧容量大于0    \n        \u002F\u002F超过最大值就不扩容了，随它碰撞去吧 -。-\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (oldCap &gt;= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E oldTab;\n        }\n        \u002F\u002F×2还没超过最大值，新数组就扩容为原来两倍 阈值也做×2处理\n        \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;\n                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr &lt;&lt; 1; \u002F\u002F double threshold \n    }\n    \u002F\u002F如果原来的阈值 &gt; 0且旧容量为0，则将新容量设为原来的阈值，初始化有参给threshold赋值会有此情况\n    \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (oldThr &gt; 0) \n        newCap = oldThr;\n    \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E { \u002F\u002F zero initial threshold signifies using defaults\n        \u002F\u002F默认初始化无参构造的情况 \n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    \u002F\u002F如果\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (newThr == 0) {\n        \u003Cspan class=\"hljs-built_in\"\u003Efloat\u003C\u002Fspan\u003E ft = (\u003Cspan class=\"hljs-built_in\"\u003Efloat\u003C\u002Fspan\u003E)newCap * loadFactor;\n        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (\u003Cspan class=\"hljs-built_in\"\u003Efloat\u003C\u002Fspan\u003E)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    @SuppressWarnings({\u003Cspan class=\"hljs-string\"\u003E\"rawtypes\"\u003C\u002Fspan\u003E,\u003Cspan class=\"hljs-string\"\u003E\"unchecked\"\u003C\u002Fspan\u003E}) \u002F\u002F屏蔽无关紧要的警告\n        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];\n    table = newTab;\n    \u002F\u002F如果旧数组不为空 \n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (oldTab != null) {\n        \u002F\u002F遍历数组\n        \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (int j = 0; j &lt; oldCap; ++j) {\n            Node&lt;K,V&gt; e;\n            \u002F\u002F数组中的节点不为空\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                \u002F\u002F如果该桶只有一个节点(说明下面没有链表，或者说只有一个链表节点)\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (e.next == null)\n                    \u002F\u002Fe.hash &amp; (newCap - 1)确定元素存放位置\n                    newTab[e.hash &amp; (newCap - 1)] = e;\n                \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (e instanceof TreeNode)\n                    \u002F\u002F红黑树节点\n                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);\n                \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E { \n                    \u002F\u002F链表节点且当前链表节点不止1个\n                    Node&lt;K,V&gt; loHead = null, loTail = null;\n                    Node&lt;K,V&gt; hiHead = null, hiTail = null;\n                    Node&lt;K,V&gt; next;\n                    \u003Cspan class=\"hljs-keyword\"\u003Edo\u003C\u002Fspan\u003E {\n                        next = e.next;\n                        \u002F\u002F根据e.hash &amp; oldCap 判断节点存放位置\n                        \u002F\u002F如果为0 扩容还在原来位置 如果为1 新的位置为 旧的index + oldCap 下面如何扩容有做介绍\n                        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E ((e.hash &amp; oldCap) == 0) {\n                            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (loTail == null)\n                                loHead = e;\n                            \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n                            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (hiTail == null)\n                                hiHead = e;\n                            \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E ((e = next) != null);\u002F\u002F旧链表迁移到新链表\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (loTail != null) {\n                        loTail.next = null;\u002F\u002F将链表的尾节点的next设置为空\n                        newTab[j] = loHead;\n                    }\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (hiTail != null) {\n                        hiTail.next = null;\u002F\u002F 将链表的尾节点 的next 设置为空\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E newTab;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003E4.3 HashMap经典代码 p = tab[i = (n - 1) &amp; hash])\u003C\u002Fh3\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003Ep = tab[i = (n - 1) &amp; \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E])\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E当hashCode小于65536，散列是很规律的，基本上索引的位置就是\u003C\u002Fp\u003E\u003Cp\u003E因为小于这个数右移16为都为0，且和占位符都为0的值异或后的hashcode就是自身的值。\u003C\u002Fp\u003E\u003Cp\u003E这个值比较特殊\u003C\u002Fp\u003E\u003Cp\u003E转换为二进制：00000000000000010000000000000000，右移16的话00000000000000000000000000000001并不全为0\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003Estatic final int \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E(Object key) {\n    int h;\n    \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Ekey的hashcode为65536\u003C\u002Fp\u003E\u003Cp\u003E转为二进制：h=key.hashCode() 00000000000000010000000000000000\u003C\u002Fp\u003E\u003Cp\u003E跟右移16位的再做异或操作 00000000000000000000000000000001\u003C\u002Fp\u003E\u003Cp\u003Ehash = h ^(h&gt;&gt;&gt;16) 00000000000000010000000000000001\u003C\u002Fp\u003E\u003Cp\u003E​\u003C\u002Fp\u003E\u003Cp\u003E计算hash 00000000000000010000000000000001\u003C\u002Fp\u003E\u003Cp\u003E​ 00000000000000000000000000001111\u003C\u002Fp\u003E\u003Cp\u003E结果 1\u003C\u002Fp\u003E\u003Cp\u003E但是65536 % 16 = 0\u003C\u002Fp\u003E\u003Cp\u003Ekey的hashcode为17 异或相同为0 不同为假\u003C\u002Fp\u003E\u003Cp\u003E转为二进制：h=key.hashCode() 00000000000000000000000000010001\u003C\u002Fp\u003E\u003Cp\u003E跟右移16位的再做异或操作 00000000000000000000000000000000\u003C\u002Fp\u003E\u003Cp\u003Ehash = h ^(h&gt;&gt;16) 00000000000000000000000000010001\u003C\u002Fp\u003E\u003Cp\u003E计算hash 00000000000000000000000000010001\u003C\u002Fp\u003E\u003Cp\u003E​ 00000000000000000000000000001111\u003C\u002Fp\u003E\u003Cp\u003E​ 00000000000000000000000000000001\u003C\u002Fp\u003E\u003Cp\u003E做个小测试，假设这个时候桶的个数为16，代码如下\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (int key = 65533; key &lt; 65543; key++) { \u002F\u002F从65536开始变得有点\u003Cspan class=\"hljs-string\"\u003E\"特别\"\u003C\u002Fspan\u003E\n    System.out.println(\u003Cspan class=\"hljs-string\"\u003E\"key为：\"\u003C\u002Fspan\u003E + key +  \u003Cspan class=\"hljs-string\"\u003E\"，索引位置：\"\u003C\u002Fspan\u003E + ((key ^ (key &gt;&gt;&gt; 16)) &amp; 15));\u002F\u002F假设初始容量为16 测试没扩容时这些数的索引位置\n}\n\u002F\u002F输出结果为，可以发现从65536开始不为0而是1，有点特殊，然后相邻两个索引位置呈1,3的增长，具体可画图尝试\ni为：65533，输出13\ni为：65534，输出14\ni为：65535，输出15\ni为：65536，输出1\ni为：65537，输出0\ni为：65538，输出3\ni为：65539，输出2\ni为：65540，输出5\ni为：65541，输出4\ni为：65542，输出7\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E这段代码主要是计算索引位置的，HashMap 底层数组的长度总是 2 的 n 次方\u003C\u002Fp\u003E\u003Cp\u003E当 length 总是 2 的倍数时，h&amp; (length-1)，将是一个非常巧妙的设计：\u003C\u002Fp\u003E\u003Ctable\u003E\u003Cthead\u003E\u003Ctr\u003E\u003Cth\u003Ehash值\u003C\u002Fth\u003E\u003Cth\u003Elength(假设长度为16)\u003C\u002Fth\u003E\u003Cth\u003Eh &amp; length - 1\u003C\u002Fth\u003E\u003C\u002Ftr\u003E\u003C\u002Fthead\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E5\u003C\u002Ftd\u003E\u003Ctd\u003E16\u003C\u002Ftd\u003E\u003Ctd\u003E5\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E6\u003C\u002Ftd\u003E\u003Ctd\u003E16\u003C\u002Ftd\u003E\u003Ctd\u003E6\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E15\u003C\u002Ftd\u003E\u003Ctd\u003E16\u003C\u002Ftd\u003E\u003Ctd\u003E15\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E16\u003C\u002Ftd\u003E\u003Ctd\u003E16\u003C\u002Ftd\u003E\u003Ctd\u003E0\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E17\u003C\u002Ftd\u003E\u003Ctd\u003E16\u003C\u002Ftd\u003E\u003Ctd\u003E1\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\u003Cp\u003E\u003Cb\u003E可以看到计算得到的索引值总是位于 table 数组的索引之内。并且通常分布的比较均匀\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Ch3\u003E4.4 树形化treeifyBin()\u003C\u002Fh3\u003E\u003Cp\u003E在jdk8以前，如果发生频繁碰撞的话，查找时间复杂度是O(1) + O(n) (先找在数组的位置再找链表)，n如果比较大则严重影响了查找性能，而到了jdk8引入红黑树,O(1) + O(logN)。\u003C\u002Fp\u003E\u003Cp\u003Ejdk1.8中，如果一个桶中元素个数超过TREEIFY_THRESHOLD(8)时，就用红黑树替换链表以提升速度(主要是查找)\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E\u002F\u002F将桶内所有链表节点换成红黑树节点\nfinal void treeifyB\u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E(Node&lt;K,V&gt;[] tab, int \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E) {\n    int n, index; Node&lt;K,V&gt; e;\n    \u002F\u002F如果当前哈希表为空 或者哈希表中元素 MIN_TREEIFY_CAPACITY默认为64，对于这个值可以认为，如果节点数组长度小于64，就没必要去进行结构转换，而是通过resize()操作，这样原先一个链表的元素可能会进行重新分配。\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)\n        resize(); \u002F\u002F扩容\n    \u002F\u002F大于等于64 就树化 链表上的普通节点变成树节点\n    \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E ((e = tab[index = (n - 1) &amp; \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E]) != null) {      \n        TreeNode&lt;K,V&gt; hd = null, tl = null; \u002F\u002F定义首、尾节点\n        \u003Cspan class=\"hljs-keyword\"\u003Edo\u003C\u002Fspan\u003E {\n            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); \u002F\u002F普通节点 -&gt; 树节点\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (tl == null) \u002F\u002F如果尾节点为空 说明还没有根节点\n                hd = p; \u002F\u002F首节点(根节点) 指向当前节点\n            \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E { \u002F\u002F尾节点不为空 \n                p.prev = tl; \u002F\u002F当前树节点前一个节点指向尾节点\n                tl.next = p; \u002F\u002F尾节点后一个节点 指向当前节点\n            }\n            tl = p; \n        } \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E ((e = e.next) != null); \u002F\u002F继续遍历链表\n      \n        \u002F\u002F这个时候只是把Node对象变成TreeNode对象，把单向链表变成双向链表\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E ((tab[index] = hd) != null)\n            hd.treeify(tab);\n    }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch1\u003E5.思考\u003C\u002Fh1\u003E\u003Ch3\u003E1.HashMap和HashTable的区别是什么\u003C\u002Fh3\u003E\u003Cp\u003EHashMap和Hashtable都实现了Map接口\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003EHashMap功能上几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。\u003Cbr\u003EHashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的\u003Cbr\u003E由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。\u003Cbr\u003EHashMap不能保证随着时间的推移Map中的元素次序是不变的。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003E由于性能问题，以及HashTable处理Hash冲突比HashMap逊色很多，现在HashTable已经很少使用了。但由于线程安全以及以前的项目还在使用，SUN依然还保留着它并没有加Deprecated过时注解。\u003C\u002Fp\u003E\u003Cp\u003E摘自hashtable源码\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003EIf a thread-safe implementation is not needed, it is recommended to use HashMap in place of Hashtable. If a thread-safe highly-concurrent implementation is desired, then it is recommended to use java.util.concurrent.ConcurrentHashMap in place of Hashtable.\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003E简单来说就是不需要线程安全，那么使用HashMap，如果需要线程安全，那么使用ConcurrentHashMap。\u003C\u002Fp\u003E\u003Ch3\u003E2.HashMap为什么线程不安全，如果想要线程安全怎么做\u003C\u002Fh3\u003E\u003Cp\u003E因为hashmap为了性能，它的put，resize等操作都不是同步的，假设两个线程同一时间做put操作,可能最后计算的size并不正确，值得一提的是jdk1.8以前多线程put甚至会导致闭环死循环，1.8开始不会有这个问题但依然存在线程安全问题。\u003C\u002Fp\u003E\u003Cp\u003Ejdk8前的闭环死循环。\u003C\u002Fp\u003E\u003Cp\u003E这种问题在单线程下不存在，但在多线程下可能引起死循环导致cpu占用过高。\u003C\u002Fp\u003E\u003Cp\u003E如果hash冲突大，同一链表下下有多个节点容易出现这种问题。具体参考\u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fwww.jianshu.com%2Fp%2F1e9cf0ac07f4\"\u003E老生常谈，HashMap的死循环\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E若想要线程安全\n1、使用ConcurrentHashMap。(线程安全的\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003EMap)\n2、使用Collections.synchronizedMap(Mao&lt;K,V&gt; m)方法把HashMap变成一个线程安全的Map。\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003E3.HashMap是怎么解决Hash冲突的\u003C\u002Fh3\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E在实际应用中，无论怎么构造哈希函数，冲突也难以完全避免。\nHashMap根据链地址法(拉链法)来解决冲突,jdk8中如果链表长度大于8且节点数组长度大于64的时候，就把链表下所有节点转为红黑树，位于数组上的节点为根节点，来维护\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E冲突的元素，链表中冲突的元素可以通过key的equals()方法来确定。\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003E4.HashMap是怎么扩容的\u003C\u002Fh3\u003E\u003Cp\u003E先写个例子测试hashMap有没有在扩容。\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003Epublic static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n    HashMap&lt;Integer,String&gt; o = new HashMap&lt;&gt;(1);\n    System.out.println(o.size()); \u002F\u002F0 size为元素个数\n    \u002F\u002F扩容条件是 如果没有定义初始容量 默认扩容至16 如果没有 根据put的情况扩容\n    \u002F\u002Fput的过程中 如果插入一个元素过后的size &gt; 阈值(加载因子 * 最近容量)\n    \u002F**\n     * 代码体现 put后执行\n     *   \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (++size &gt; threshold)\n     *         resize();\n     *\u002F\n    \u002F\u002F有定义容量的话会采用大于这个数的最小二次幂 第一次初始化为1 则输出为2 4 5 11  111 11\n    HashMap&lt;Integer,String&gt; map = new HashMap&lt;&gt;(1);\n    map.put(1, \u003Cspan class=\"hljs-string\"\u003E\"一\"\u003C\u002Fspan\u003E);\n    \u002F\u002F由于方法由final修饰 利用反射机制获取容量值\n    Class&lt;?&gt; mapType = map.getClass();\n    Method capacity = mapType.getDeclaredMethod(\u003Cspan class=\"hljs-string\"\u003E\"capacity\"\u003C\u002Fspan\u003E);\n    capacity.setAccessible(\u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E); \u002F\u002F由于capacity方法由final修饰 暴力获取\n    System.out.println(\u003Cspan class=\"hljs-string\"\u003E\"capacity : \"\u003C\u002Fspan\u003E + capacity.invoke(map)); \u002F\u002Fcapacity : 2\n \n    map.put(2, \u003Cspan class=\"hljs-string\"\u003E\"二\"\u003C\u002Fspan\u003E);\n    capacity = mapType.getDeclaredMethod(\u003Cspan class=\"hljs-string\"\u003E\"capacity\"\u003C\u002Fspan\u003E);\n    capacity.setAccessible(\u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E);\n    System.out.println(\u003Cspan class=\"hljs-string\"\u003E\"capacity : \"\u003C\u002Fspan\u003E + capacity.invoke(map)); \u002F\u002Fcapacity : 4 当前容量为2 插入该元素后size为 2 &gt; 2 * 3\u002F4 开始扩容\n\n    \u002F\u002F当前容量为4 此时已有2个 3 = 4 * 3\u002F4 不进行扩容\n    map.put(3, \u003Cspan class=\"hljs-string\"\u003E\"三\"\u003C\u002Fspan\u003E);\n    capacity = mapType.getDeclaredMethod(\u003Cspan class=\"hljs-string\"\u003E\"capacity\"\u003C\u002Fspan\u003E);\n    capacity.setAccessible(\u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E);\n    System.out.println(\u003Cspan class=\"hljs-string\"\u003E\"capacity : \"\u003C\u002Fspan\u003E + capacity.invoke(map)); \u002F\u002Fcapacity : 4 当前容量为2 插入该元素后size为 3 = 4 * 3\u002F4 不扩容\n\n    map.put(4, \u003Cspan class=\"hljs-string\"\u003E\"四\"\u003C\u002Fspan\u003E);\n    capacity = mapType.getDeclaredMethod(\u003Cspan class=\"hljs-string\"\u003E\"capacity\"\u003C\u002Fspan\u003E);\n    capacity.setAccessible(\u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E);\n    System.out.println(\u003Cspan class=\"hljs-string\"\u003E\"capacity : \"\u003C\u002Fspan\u003E + capacity.invoke(map));\u002F\u002Fcapacity : 8  当前容量为4 此时已有4个 4 &gt; 4 * 3\u002F4 开始扩容\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E上面的例子可以看出put后，hashmap确实有进行扩容，hashMap的扩容机制与其它的集合边长不太一样，它是通过当前hash桶个数乘2进行扩容\u003C\u002Fp\u003E\u003Cp\u003EhashMap主要是通过resize()方法扩容\u003C\u002Fp\u003E\u003Cp\u003E假设oldTable的key的hash为15，7，4，5，8，1，hashMap为初始容量为8的数组桶，存储位置如下\u003C\u002Fp\u003E\u003Ctable\u003E\u003Cthead\u003E\u003Ctr\u003E\u003Cth\u003Eindex\u003C\u002Fth\u003E\u003Cth\u003E0\u003C\u002Fth\u003E\u003Cth\u003E1\u003C\u002Fth\u003E\u003Cth\u003E2\u003C\u002Fth\u003E\u003Cth\u003E3\u003C\u002Fth\u003E\u003Cth\u003E4\u003C\u002Fth\u003E\u003Cth\u003E5\u003C\u002Fth\u003E\u003Cth\u003E6\u003C\u002Fth\u003E\u003Cth\u003E7\u003C\u002Fth\u003E\u003C\u002Ftr\u003E\u003C\u002Fthead\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003Ehash\u003C\u002Ftd\u003E\u003Ctd\u003E8\u003C\u002Ftd\u003E\u003Ctd\u003E1\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E4\u003C\u002Ftd\u003E\u003Ctd\u003E5\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E7，15\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\u003Cp\u003E当put一个新元素 假设为9，且加载因子使用默认的0.75，在内存空间中新的存储位置如下\u003C\u002Fp\u003E\u003Ctable\u003E\u003Cthead\u003E\u003Ctr\u003E\u003Cth\u003Eindex\u003C\u002Fth\u003E\u003Cth\u003E0\u003C\u002Fth\u003E\u003Cth\u003E1\u003C\u002Fth\u003E\u003Cth\u003E2\u003C\u002Fth\u003E\u003Cth\u003E3\u003C\u002Fth\u003E\u003Cth\u003E4\u003C\u002Fth\u003E\u003Cth\u003E5\u003C\u002Fth\u003E\u003Cth\u003E6\u003C\u002Fth\u003E\u003Cth\u003E7\u003C\u002Fth\u003E\u003Cth\u003E8\u003C\u002Fth\u003E\u003Cth\u003E9\u003C\u002Fth\u003E\u003Cth\u003E10\u003C\u002Fth\u003E\u003Cth\u003E11\u003C\u002Fth\u003E\u003Cth\u003E12\u003C\u002Fth\u003E\u003Cth\u003E13\u003C\u002Fth\u003E\u003Cth\u003E14\u003C\u002Fth\u003E\u003Cth\u003E15\u003C\u002Fth\u003E\u003C\u002Ftr\u003E\u003C\u002Fthead\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003Ehash\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E1\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E4\u003C\u002Ftd\u003E\u003Ctd\u003E5\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E7\u003C\u002Ftd\u003E\u003Ctd\u003E8\u003C\u002Ftd\u003E\u003Ctd\u003E9\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E15\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\u003Cp\u003E可以看到扩容之后8跑到了第9个位置，15跑到了第16个位置，旧的8，1，4，5在各自的链表上只有一个节点\u003C\u002Fp\u003E\u003Cp\u003E根据 \u003Cb\u003Ee.hash &amp; (newCap - 1)\u003C\u002Fb\u003E 相当于 与上15后，都为自己本身所以位置保持不变\u003C\u002Fp\u003E\u003Cp\u003E但是链表上不止有一个节点的情况，比如说上面的7，15存放的位置\u003C\u002Fp\u003E\u003Cp\u003E这个时候是先根据 \u003Cb\u003Ee.hash &amp; oldCap\u003C\u002Fb\u003E判断元素在数组的位置是否需要移动\u003C\u002Fp\u003E\u003Cp\u003E比如说 7 &amp; 8 = 0111 &amp; 1000 = 0 ; 15 &amp; 8 = 1111 &amp; 1000 = 1，规律是比较高位的第一个 比如说15为高位，第一个为1，如果高位为1那么与后结果也为1\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E当e.hash &amp; oldCap == 0时\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E链表上节点位置保持不变\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E当e.hash &amp; oldCap == 1时\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E链表上节点的位置为原位置的index + oldCap 比如说15，新的索引位置为7+8为15\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003E值得一提的是，jdk1.8的resize()方法相比与之前做了点优化，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但JDK1.8不会倒置，jdk8通过e.hash &amp; oldCap，通过0和1的值均匀把之前的冲突的节点分散到新的bucket了，这样做更为高效。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003E代码见【4.4.5 resize()方法】\u003C\u002Fp\u003E\u003Ch3\u003E5.loadFactor加载因子为何为0.75f\u003C\u002Fh3\u003E\u003Cblockquote\u003E\u003Cp\u003E加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之越小。\u003Cbr\u003E简单来说就是如果加载因子太小，空间利用率低，且太容易扩容对性能不太友好，设置太高，不及时扩容容易导致冲突几率大，将提高了查询成本。所以0.75是很合适的值，经过试验，在理想情况下,使用随机哈希码,节点出现的频率在hash桶中遵循泊松分布【在频率附近发生概率高，向两边对称下降。】\u003Cbr\u003E详细见 \u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fwww.cnblogs.com%2FDarrenChan%2Fp%2F8854859.html\"\u003E为什么HashMap中默认加载因子为0.75\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Ch3\u003E6.hashMap中一般使用什么类型的元素作为key，为什么？\u003C\u002Fh3\u003E\u003Cblockquote\u003E\u003Cp\u003E常用String，Integer这样的key\u003Cbr\u003E主要原因为\u003Cbr\u003E这些类是Immutable(不可变的)，String和基本类型的包装类规范的重写了hashCode()和equals()方法。作为不可变类天生是线程安全的，而且可以很好的优化比如可以缓存hash值，避免重复计算等等，如果采用可变的对象类型，可能出现put进去就无法查询到的情况。\u003Cbr\u003E如果想用自定义的类型作为键，那么需要遵守equals()和hashCode()方法的定义规则且不可变，对象插入到map后就不会再改变。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=http%3A%2F%2Fwww.cnblogs.com%2F0201zcr%2Fp%2F4810813.html\"\u003EHashMap的key可以是可变对象吗？\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Ch3\u003E7.源码中为什么要用transient修饰桶数组table\u003C\u002Fh3\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003Etransient Node&lt;K,V&gt;[] table;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E在java中，被transient关键字修饰的变量不会被默认的序列化机制序列化。\u003C\u002Fp\u003E\u003Cp\u003EhashMap实现了Serializable接口，通过实现\u003Ccode\u003EreadObject\u002FwriteObject\u003C\u002Fcode\u003E两个方法自定义了序列化的内容，size不用多说了，一般涉及到大小可以直接计算的就没必要再序列化。\u003C\u002Fp\u003E\u003Cp\u003E为什么不序列化table？原因有下\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003E1.table大多数情况是无法存满的。比如说桶数组容量是16，只put了一个元素，这会造成序列化未使用的部分。造成浪费。\u003C\u002Fp\u003E\u003Cp\u003E2.同一个键值对在不同jvm下，所处桶的位置可能是不同的，在不同的jvm下反序列化可能发生错误。(hashmap的get\u002Fput\u002Fremove等方法刚开始都是通过hash找到键所在的桶位置，就是数组下标，但如果键没有重写hashCode方法，就会调用Object的hashCode方法，而Object的hashcode方法是navtive(本地方法)的，这里的hashcode是对对象内存地址的映射得出的int结果，具体怎么计算不得而知，但是在不同jvm下，可能有不同的hashcode实现，这样产生的hash也不一样)。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Ch3\u003E8.HashMap的key如果为null，怎么查找值\u003C\u002Fh3\u003E\u003Cp\u003E我们知道hashMap只允许一个为null的key，如果key为null，因为key为null，那么hash为0，那么p = tab[i = (n - 1) &amp; hash 也一定为0，所以是从数组上第一个位置的链表下查找。\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003Estatic final int \u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E(Object key) {\n    int h;\n    \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch1\u003E6.使用建议\u003C\u002Fh1\u003E\u003Cp\u003E1.默认情况下HashMap的容量是16，但是，如果用户通过构造函数指定了一个数字作为容量，那么Hash会选择大于该数字的第一个2的幂作为容量。(1-&gt;2、7-&gt;8、9-&gt;16)\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003E在初始化HashMap的时候，应该尽量指定其大小。尤其是当你已知map中存放的元素个数时。（《阿里巴巴Java开发规约》）\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003E这边可以看下hashMap的4个构造方法，一般采用3，但如果已经知道个数，建议用2(加载因子0.75很合适不建议改动)\u003C\u002Fp\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E\u002F\u002F1 自定义传初始容量和加载因子\npublic HashMap(int initialCapacity, \u003Cspan class=\"hljs-built_in\"\u003Efloat\u003C\u002Fspan\u003E loadFactor) {\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (initialCapacity &lt; 0)\n        throw new IllegalArgumentException(\u003Cspan class=\"hljs-string\"\u003E\"Illegal initial capacity: \"\u003C\u002Fspan\u003E +\n                                           initialCapacity);\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (initialCapacity &gt; MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (loadFactor &lt;= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(\u003Cspan class=\"hljs-string\"\u003E\"Illegal load factor: \"\u003C\u002Fspan\u003E +\n                                           loadFactor);\n    this.loadFactor = loadFactor;\n    this.threshold = tableSizeFor(initialCapacity);\n}\n\n\u002F\u002F2 自定义初始大小 调1构造方法，加载因子使用默认大小\npublic HashMap(int initialCapacity) {\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n}\n\n\u002F\u002F3 最常用的无参构造方法\npublic \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003EHashMap\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() {\n    this.loadFactor = DEFAULT_LOAD_FACTOR; \u002F\u002F all other fields defaulted\n}\n\n\u002F\u002F4 将别的map对象映射到自身存储，很少用\npublic HashMap(Map&lt;? extends K, ? extends V&gt; m) {\n    this.loadFactor = DEFAULT_LOAD_FACTOR;\n    putMapEntries(m, \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E);\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E这边讲解一下tableSizeFor方法。简述一下该方法的作用：\u003C\u002Fp\u003E\u003Cp\u003E如果自定义容量大小时(调1或2的构造方法)，传入一个初始容量大小，\u003Cb\u003E大于输入参数且最近的2的整数次幂的数\u003C\u002Fb\u003E。比如10，则返回16，75返回128\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003E不这么做的缺点\u003C\u002Fp\u003E\u003Cp\u003E假设HashMap需要放置1024个元素，由于没有设置初始容量大小，随着元素不断增加，容量7次被迫扩大。而resize过程需要重建hash表，这会严重影响性能。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cpre code-lang=\"\" class=\"hljs bash\"\u003E\u003Ccode class=\"hljs bash\" lang=\"bash\"\u003E\u002F**\n * Returns a power of two size \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E the given target capacity.\n *\u002F\nstatic final int tableSizeFor(int \u003Cspan class=\"hljs-built_in\"\u003Ecap\u003C\u002Fspan\u003E) {\n    \u002F\u002F\u003Cspan class=\"hljs-built_in\"\u003Ecap\u003C\u002Fspan\u003E-1的目的是因为如果\u003Cspan class=\"hljs-built_in\"\u003Ecap\u003C\u002Fspan\u003E是2的幂数不做-1操作的话 那么最后执行完右移操作的话，返回的值将会是原有值得两倍。如果n为0的话，即\u003Cspan class=\"hljs-built_in\"\u003Ecap\u003C\u002Fspan\u003E=1，经过后面几次操作返回的为0，最后返回的capacity仍然为1(最后有加1的操作)\n    int n = \u003Cspan class=\"hljs-built_in\"\u003Ecap\u003C\u002Fspan\u003E - 1;\n    n |= n &gt;&gt;&gt; 1;\n    n |= n &gt;&gt;&gt; 2;\n    n |= n &gt;&gt;&gt; 4;\n    n |= n &gt;&gt;&gt; 8;\n    n |= n &gt;&gt;&gt; 16;\n    \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cb\u003E解释一下这段代码\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E在java中，|=的作用是比较两个对象是否相等\u003C\u002Fp\u003E\u003Cp\u003Ea|=b的意思就是把a和b按位或然后赋值给a\u003C\u002Fp\u003E\u003Cp\u003E以10为例整体流程大致如下\u003C\u002Fp\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E\u003Cimg alt=\"img_eadde165ab656c39debed0afc9a20492.png\" src=\"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fgold-user-assets\u002F2019\u002F9\u002F26\u002F16d6cc9bf3b23a1b~tplv-t2oaga2asx-image.image\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E算法流程\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E简单来说，这种运算最后会导致1占满了它自己所占位，比如说250，它的二进制为\u003C\u002Fp\u003E\u003Cp\u003E11111010，经过上面的或运算之后，最终将变为11111111，这种情况在加上1，就是大于这个数的最小二次幂。\u003C\u002Fp\u003E\u003Ch1\u003E7.总结\u003C\u002Fh1\u003E\u003Cp\u003EHashMap的设计与实现十分的巧妙。jdk8更是有很多提升，还没写这篇博客对于HashMap的理解仅仅只在表面。阅读源码后才发现里面还有不少的学问，由于本人水平有限，虽然花了很多时间写了很多但还有很多细节并不了解，比如说红黑树的代码实现细节，也有可能有几个地方描述错误或者不到位，如果文章有误请指正，以便于我及时修改和学习。\u003C\u002Fp\u003E\u003Ch1\u003E8.参考链接\u003C\u002Fh1\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=http%3A%2F%2Fwww.coolblog.xyz%2F2018%2F01%2F18%2FHashMap-%25E6%25BA%2590%25E7%25A0%2581%25E8%25AF%25A6%25E7%25BB%2586%25E5%2588%2586%25E6%259E%2590-JDK1-8%2F\"\u003EHashMap 源码详细分析(JDK1.8)\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fwww.cnblogs.com%2Fwoniu4%2Fp%2F8301099.html\"\u003EHashMap resize方法的理解（一)\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?spm=a2c4e.11153940.0.0.5bf05442WOllqe&amp;url=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F20733617\"\u003EJDK 源码中 HashMap 的 hash 方法原理是什么\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fwww.cnblogs.com%2Fdongguacai%2Fp%2F5599100.html\"\u003EhashMap死循环问题\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fblog.csdn.net%2FLovePluto%2Farticle%2Fdetails%2F79712473\"\u003E浅谈jdk8为何线程不安全\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fyq.aliyun.com\u002Farticles\u002F651050\"\u003Ehttps:\u002F\u002Fyq.aliyun.com\u002Farticles\u002F651050\u003C\u002Fa\u003E\u003Cbr\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Cbr\u003E\u003C\u002Fp\u003E",originalUrl:"https:\u002F\u002Fjuejin.im\u002Fpost\u002F6844903953566531597",type:"post",collected:a,viewsCount:2349,username:"Forgotten在掘金",viewerHasLiked:a,draftId:"6845076477000548365",collectionCount:h},entryView:{},author:{id:"3227821871208174",self_description:void 0,followed:a,viewerIsFollowing:void 0,community:void 0,subscribedTagCount:d,wroteBookCount:d,boughtBookCount:d,isBindedPhone:a,level:n,user_id:"3227821871208174",user_name:"Forgotten在掘金",company:e,job_title:e,avatar_large:"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fmirror-assets\u002F16d667c91bd62c35136~tplv-t2oaga2asx-image.image",description:e,followee_count:35,follower_count:d,post_article_count:n,digg_article_count:d,got_digg_count:8,got_view_count:2500,post_shortmsg_count:d,digg_shortmsg_count:d,isfollowed:a,favorable_author:d,power:93,study_point:d,university:{university_id:f,name:e,logo:e},major:{major_id:f,parent_id:f,name:e},student_status:d,select_event_count:d,select_online_course_count:d,identity:d,is_select_annual:a,select_annual_rank:d,annual_list_type:d,extraMap:{},is_logout:d,annual_info:[],account_amount:d,user_growth_info:{user_id:3227821871208174,jpower:93,jscore:3.3,jpower_level:n,jscore_level:g,jscore_title:"预备掘友",author_achievement_list:[],vip_level:d,vip_title:e,jscore_next_level_score:15,jscore_this_level_mini_score:d},is_vip:a,become_author_days:d,collection_set_article_count:d,juejinPower:93,jobTitle:e,roles:{isBookAuthor:a,isFavorableAuthor:a,isCobuilder:a,isAdmin:a},username:"Forgotten在掘金",blogAddress:void 0,selfDescription:e,beLikedCount:8,beReadCount:2500,followerCount:d,followingCount:35,collectionCount:d,createdCollectionCount:d,followingCollectionCount:d,postedPostsCount:n,pinCount:d,likedArticleCount:d,likedPinCount:d,avatar:"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fmirror-assets\u002F16d667c91bd62c35136~tplv-t2oaga2asx-image.image",latestLoginedInAt:c,createdAt:c,updatedAt:c,phoneNumber:e,titleDescription:e,followeesCount:35,applyEventCount:d,need_lead:d,followTopicCnt:void 0},adEntryList:[],relatedEntryList:[],linkVotingList:[],userAnnuals:[],columnList:[],cachedHtml:"\u003Cstyle\u003E.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#333}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;margin-bottom:5px}.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{font-size:20px}.markdown-body h2{padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre\u003Ecode{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:\"\"}.markdown-body blockquote\u003Ep{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}\u003C\u002Fstyle\u003E\u003Ch1 data-id=\"heading-0\"\u003E1.概述\u003C\u002Fh1\u003E\u003Cblockquote\u003E\u003Cp\u003EHashMap是日常java开发中常用的类之一，是java设计中非常经典的一个类，它巧妙的设计思想与实现，还有涉及到的数据结构和算法，，值得我们去深入的学习。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cblockquote\u003E\u003Cp\u003E简单来说，HashMap就是一个散列表，是基于哈希表的Map接口实现，它存储的内容是键值对 (key-value) 映射，并且键值允许为null(键的话只允许一个为null)。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Ch3 data-id=\"heading-1\"\u003E1.1 注意事项\u003C\u002Fh3\u003E\u003Cblockquote\u003E\u003Cp\u003E①根据键的hashCode存储数据。(String，和Integer、Long、Double这样的包装类都重写了hashCode方法，String比较特殊根据ascil码还有自己的算法计算，Double做位移运算【具体看源码的hashcode实现】，Integer，Long包装类则是自身大小int值)，\u003Cbr\u003EHashMap中的结构不能有基本类型，一方面是基本类型没有hashCode方法，还有HashMap是泛型结构，泛型要求包容对象类型，而基本类型在java中不属于对象。\u003Cbr\u003E②HashMap的存储单位是Node&#x3C;k,v\u003E,可以认作为节点。\u003Cbr\u003E③Hashmap中的扩容的个数是针对size(内部元素(节点)总个数)，而不是数组的个数。比如说初始容量为16，第十三个节点put进来，不管前面十二个占的数组位置如何，就开始扩容。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Ch3 data-id=\"heading-2\"\u003E1.2 hashmap几个特征\u003C\u002Fh3\u003E\u003Ctable\u003E\u003Cthead\u003E\u003Ctr\u003E\u003Cth\u003E特征\u003C\u002Fth\u003E\u003Cth\u003E说明\u003C\u002Fth\u003E\u003C\u002Ftr\u003E\u003C\u002Fthead\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E是否允许重复数据\u003C\u002Ftd\u003E\u003Ctd\u003Ekey如果重复会覆盖，value允许重复\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003EhashMap是否有序\u003C\u002Ftd\u003E\u003Ctd\u003E无序，这里的无序指的是遍历HashMap的时候，得到的顺序大都跟put进去的顺序不一致\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003EhashMap是否线程安全\u003C\u002Ftd\u003E\u003Ctd\u003E非线程安全，因为里面的实现不是同步的，如果想要线程安全，推荐使用\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E键值是否允许为空\u003C\u002Ftd\u003E\u003Ctd\u003Ekey和value都允许为空，但只允许一个为空\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\u003Ch1 data-id=\"heading-3\"\u003E2.一些概念\u003C\u002Fh1\u003E\u003Ch3 data-id=\"heading-4\"\u003E2.1.位运算\u003C\u002Fh3\u003E\u003Cp\u003E位运算是对整数在内存中的二进制位进行操作。\u003C\u002Fp\u003E\u003Cp\u003E在java中 \u003E\u003E 表示右移 若该数为正，则高位补0，若为负数，高位补1\u003C\u002Fp\u003E\u003Cp\u003E&#x3C;&#x3C;表示左移 跟右移相反 如果是正数在低位补0\u003C\u002Fp\u003E\u003Cp\u003E例如20的二进制为0001 0100 20\u003E\u003E2为 0101 0000 结果为5(左高右低)\u003C\u002Fp\u003E\u003Cp\u003E20&#x3C;&#x3C;2 为 0101 0000 则为80\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003Ejava中\u003E\u003E\u003E和\u003E\u003E的区别\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode lang=\"shell\" class=\"hljs language-shell copyable\"\u003E\u003Cspan class=\"hljs-meta prompt_\"\u003E\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"bash\"\u003E\u003E\u003E表示无符号右移，也叫逻辑右移。不管数字是正数还是负数，高位都是补0\u003C\u002Fspan\u003E\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E在hashMap源码中有很多使用位运算的地方。例如:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode lang=\"arduino\" class=\"hljs language-arduino copyable\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F之所以用1 &#x3C;&#x3C; 4不直接用16，0000 0001 -\u003E 0001 0000 则为16，如果用16的话最后其实也是要转换成0和1这样的二进制，位运算的计算在计算机中是非常快的，直接用位运算表示大小以二进制形式去运行，在jvm中效率更高。\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-type\"\u003Estatic\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Efinal\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-type\"\u003Eint\u003C\u002Fspan\u003E DEFAULT_INITIAL_CAPACITY = \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E &#x3C;&#x3C; \u003Cspan class=\"hljs-number\"\u003E4\u003C\u002Fspan\u003E;  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F初始化容量\u003C\u002Fspan\u003E\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cb\u003E注意:左移没有&#x3C;&#x3C;&#x3C;运算符\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Ch3 data-id=\"heading-5\"\u003E2.2 位运算符-(与(&#x26;)、非(~)、,或(|)、异或(^))\u003C\u002Fh3\u003E\u003Ch5 data-id=\"heading-6\"\u003E①与运算(&#x26;)\u003C\u002Fh5\u003E\u003Cp\u003E我们都知道&#x26;在java中表示与操作&#x26;表示按位与，这里的位是指二进制位。都为1才为真(1),否则结果为0，举个简单的例子\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode lang=\"csharp\" class=\"hljs language-csharp copyable\"\u003ESystem.\u003Cspan class=\"hljs-keyword\"\u003Eout\u003C\u002Fspan\u003E.println(\u003Cspan class=\"hljs-number\"\u003E9\u003C\u002Fspan\u003E &#x26; \u003Cspan class=\"hljs-number\"\u003E8\u003C\u002Fspan\u003E); \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F1&#x26;1=1，1&#x26;0 0&#x26;1 0&#x26;0都=0，因此1001 1000 -\u003E 1000 输出为8\u003C\u002Fspan\u003E\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch5 data-id=\"heading-7\"\u003E②非运算(~)\u003C\u002Fh5\u003E\u003Cp\u003E\u003Cb\u003E源码 -\u003E 取反 -\u003E 反码 -\u003E 加1 -\u003E 补码 -\u003E 取反 -\u003E 按位非值\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E在Java中，所有数据的表示方法都是以补码的形式表示，如果没有特殊说明，Java中的数据类型默认是int,int数据类型的长度是8位，一位是四个字节，就是32字节，32bit.\u003C\u002Fp\u003E\u003Cp\u003E例如5的二进制为0101\u003C\u002Fp\u003E\u003Cp\u003E补码后为 00000000 00000000 00000000 00000101\u003C\u002Fp\u003E\u003Cp\u003E取反后为 11111111 11111111 11111111 11111010\u003C\u002Fp\u003E\u003Cp\u003E【因为高位为1 所以源码为负数，负数的补码是其绝对值源码取反，末尾再加1】\u003C\u002Fp\u003E\u003Cp\u003E所以反着来末尾减1得到反码然后再取负数\u003C\u002Fp\u003E\u003Cp\u003E末位减1：11111111 11111111 11111111 11111001\u003C\u002Fp\u003E\u003Cp\u003E【后八位前面4位不动 后面 减1 1010减1 相当于 10-1为9 后四位就是 1001 】\u003C\u002Fp\u003E\u003Cp\u003E取反后再负数： 00000000 00000000 00000000 00000110 为-6\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode lang=\"csharp\" class=\"hljs language-csharp copyable\"\u003ESystem.\u003Cspan class=\"hljs-keyword\"\u003Eout\u003C\u002Fspan\u003E.println(~ \u003Cspan class=\"hljs-number\"\u003E5\u003C\u002Fspan\u003E); \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F输出-6\u003C\u002Fspan\u003E\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch5 data-id=\"heading-8\"\u003E③或运算(|)\u003C\u002Fh5\u003E\u003Cp\u003E\u003Cb\u003E只要有一个为1，结果为1，否则都为0\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode lang=\"csharp\" class=\"hljs language-csharp copyable\"\u003ESystem.\u003Cspan class=\"hljs-keyword\"\u003Eout\u003C\u002Fspan\u003E.println(\u003Cspan class=\"hljs-number\"\u003E5\u003C\u002Fspan\u003E | \u003Cspan class=\"hljs-number\"\u003E15\u003C\u002Fspan\u003E); \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F输出为15，0101或上1111,结果为1111\u003C\u002Fspan\u003E\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch5 data-id=\"heading-9\"\u003E④异或运算(^)\u003C\u002Fh5\u003E\u003Cp\u003E\u003Cb\u003E相同为0(假)，不同为真(1)\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode lang=\"csharp\" class=\"hljs language-csharp copyable\"\u003ESystem.\u003Cspan class=\"hljs-keyword\"\u003Eout\u003C\u002Fspan\u003E.println(\u003Cspan class=\"hljs-number\"\u003E5\u003C\u002Fspan\u003E ^ \u003Cspan class=\"hljs-number\"\u003E15\u003C\u002Fspan\u003E); \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F输出10 0101异或1111结果为1010\u003C\u002Fspan\u003E\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Ch3 data-id=\"heading-10\"\u003E2.3 hashcode\u003C\u002Fh3\u003E\u003Cp\u003Ehash意为散列，hashcode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值，顶级父类Object类中含hashCode方法(native本地方法，是根据地址来计算值)，有一些类会重写该方法，比如String类。\u003C\u002Fp\u003E\u003Cp\u003E重写的原因。为了保证一致性，如果对象的equals方法被重写，那么对象的hashcode()也尽量重写。\u003C\u002Fp\u003E\u003Cp\u003E简单来说 就是hashcode()和equals()需保持一致性，如果equals方法返回true，那么两个对象的hashCode 返回也必须一样。\u003C\u002Fp\u003E\u003Cp\u003E否则可能会出现这种情况。\u003C\u002Fp\u003E\u003Cp\u003E假设一个类重写了equals方法，其相等条件为属性相等就返回true，如果不重写hashcode方法，那么依据就是Object的依据比较两个对象内存地址，则必然不相等，这就出现了equals方法相等但是hashcode不等的情况，这不符合hashcode的规则，这种情况可能会导致一系列的问题。\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E因此，在hashMap中，key如果使用了自定义的类，最好要合理的重写Object类的equals和hashcode方法。\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Ch3 data-id=\"heading-11\"\u003E2.4 哈希桶\u003C\u002Fh3\u003E\u003Cp\u003E哈希桶的概念比较模糊，个人理解是数组表中一块区域结果下面的单向链表组成的，在hashmap中，这个单向链表的头部是所在数组上第一个元素，单向链表如果过长超过8，那么这个\"桶\"就可能变成了红黑树(前提是数组长度达到64）。\u003C\u002Fp\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Ch3 data-id=\"heading-12\"\u003E2.5 hash函数\u003C\u002Fh3\u003E\u003Cp\u003E在程序设定中，把一个对象通过某种算法或者说转换机制对应到一个整形。\u003C\u002Fp\u003E\u003Cp\u003E主要用于解决冲突的。\u003C\u002Fp\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Ch3 data-id=\"heading-13\"\u003E2.6 哈希表\u003C\u002Fh3\u003E\u003Cp\u003E也称为散列表，这也是一种数据结构，可以根据对象产生一个为整数的散列码(hashCode)。\u003C\u002Fp\u003E\u003Ch4 data-id=\"heading-14\"\u003E\u003C\u002Fh4\u003E\u003Ch3 data-id=\"heading-15\"\u003Ehash冲突\u003C\u002Fh3\u003E\u003Cp\u003EHashMap之所以有那么快的查询速度，是因为他的底层是由数组实现，通过key计算散列码(hashCode)决定存储的位置，HashMap中通过key的hashCode来计算hash值，只要hashCode相同，hash值也一样，但是可能存在存的对象多了，不同对象计算出的hash值相同，这就是hash冲突。\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E举个例子\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode lang=\"arduino\" class=\"hljs language-arduino copyable\"\u003EHashMap&#x3C;\u003Cspan class=\"hljs-type\"\u003EString\u003C\u002Fspan\u003E,\u003Cspan class=\"hljs-type\"\u003EString\u003C\u002Fspan\u003E\u003E map = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EHashMap\u003C\u002Fspan\u003E&#x3C;\u003Cspan class=\"hljs-type\"\u003EString\u003C\u002Fspan\u003E,\u003Cspan class=\"hljs-type\"\u003EString\u003C\u002Fspan\u003E\u003E();\nmap.\u003Cspan class=\"hljs-built_in\"\u003Eput\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E\"Aa\"\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E\"haha\"\u003C\u002Fspan\u003E);\nmap.\u003Cspan class=\"hljs-built_in\"\u003Eput\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E\"BB\"\u003C\u002Fspan\u003E,\u003Cspan class=\"hljs-string\"\u003E\"heihei\"\u003C\u002Fspan\u003E);\nSystem.out.\u003Cspan class=\"hljs-built_in\"\u003Eprintln\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E\"Aa\"\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-built_in\"\u003EhashCode\u003C\u002Fspan\u003E()); \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F2112\u003C\u002Fspan\u003E\nSystem.out.\u003Cspan class=\"hljs-built_in\"\u003Eprintln\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E\"BB\"\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-built_in\"\u003EhashCode\u003C\u002Fspan\u003E()); \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F2112\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F这里的Aa和BB为String型，String类重写了hashCode方法(根据ascil码和特定的算法来计算，虽然很巧妙但也难以避免不对对象hashCode相同的情况)，Aa和BB的hashCode值相同，相同的HashCode的hash值相同 \u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F根据源码就算key不相同 但key.hashCode()相同 则会返回相同的hash，导致hash冲突\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-type\"\u003Estatic\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Efinal\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-type\"\u003Eint\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ehash\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(Object key)\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E{\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F取关键key的hash值\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-type\"\u003Eint\u003C\u002Fspan\u003E h;\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E (key == null) ? \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E : (h = key.\u003Cspan class=\"hljs-built_in\"\u003EhashCode\u003C\u002Fspan\u003E()) ^ (h \u003E\u003E\u003E \u003Cspan class=\"hljs-number\"\u003E16\u003C\u002Fspan\u003E);\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F任何小于2的16次方的数 右移16位都为0 2的16次方\u003E\u003E\u003E16刚好为1 任何一个数和0按位异或都为这个数本身(1和0为1 0和0为0)，所以这个hash()函数对于null的hash值 仅在hashcode大于2的16次方才会调整值,这边16设计的很巧妙，因为int刚好是32位的取中间位数\u003C\u002Fspan\u003E\n}\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3 data-id=\"heading-16\"\u003E2.7 二叉查找树和红黑树\u003C\u002Fh3\u003E\u003Cp\u003E红黑树是一种自平衡二叉查找树。是一种数据结构，又称二叉b树，（→_→ 2b树？），红黑树本质上也是二叉查找树。所以先理解下二叉查找树。\u003C\u002Fp\u003E\u003Ch4 data-id=\"heading-17\"\u003E2.7.1二叉查找树\u003C\u002Fh4\u003E\u003Cpre\u003E\u003Ccode lang=\"bash\" class=\"hljs copyable\"\u003E二叉查找树，又称有序二叉树，已排序二叉树\n它的三大特点如下\n1.左子树上所有结点的值均小于或等于它的根结点的值。\n2.右子树上所有结点的值均大于或等于它的根结点的值。\n3.左、右子树也分别为二叉排序树。\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E\u003Cimg alt=\"img_15bc610b523331178a92ad63dcfac5f8.png\" src=\"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fgold-user-assets\u002F2019\u002F9\u002F26\u002F16d6cc9bf1be2e12~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp\" loading=\"lazy\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E二叉树.png\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Ch4 data-id=\"heading-18\"\u003E2.7.2 红黑树(RBTree)\u003C\u002Fh4\u003E\u003Cpre\u003E\u003Ccode lang=\"scss\" class=\"hljs language-scss copyable\"\u003E由于二叉查找树可能存在难以平衡呈线性的缺陷，所以出现的红黑树的概念。顾名思义，红黑树是只有红色和黑色节点的二叉树。\n它的\u003Cspan class=\"hljs-number\"\u003E5\u003C\u002Fspan\u003E大性质如下。\n\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E.节点是红色或黑色。\n\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E.根节点是黑色。\n\u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E.每个叶子节点都是黑色的空节点（NIL节点）。\n\u003Cspan class=\"hljs-number\"\u003E4\u003C\u002Fspan\u003E 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)\n\u003Cspan class=\"hljs-number\"\u003E5\u003C\u002Fspan\u003E.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E简单来说红黑树是一种自平衡二叉查找树，相比于普通的二叉查找树，它的数据结构更为复杂，但是在复杂的情况也能通过自平衡(变色，左右旋转)保持良好的性能。\u003C\u002Fp\u003E\u003Cp\u003E关于红黑树，很形象的一组漫画，查看\u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Fgo%2FarticleRenderRedirect%3Furl%3Dhttps%253A%252F%252Fmp.weixin.qq.com%252Fs%253F__biz%253DMzIxMjE5MTE1Nw%253D%253D%2526amp%253Bmid%253D2653191832%2526amp%253Bidx%253D1%2526amp%253Bsn%253D12017161025495c6914b5ab9397baa59%2526amp%253Bchksm%253D8c990c42bbee8554ba02eb83d839123bd3bead6ffc736111456ea77367a3df75750cf88016e0%2526amp%253Bscene%253D21%2523wechat_redirect\" target=\"_blank\" title=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzIxMjE5MTE1Nw%3D%3D%26amp%3Bmid%3D2653191832%26amp%3Bidx%3D1%26amp%3Bsn%3D12017161025495c6914b5ab9397baa59%26amp%3Bchksm%3D8c990c42bbee8554ba02eb83d839123bd3bead6ffc736111456ea77367a3df75750cf88016e0%26amp%3Bscene%3D21%23wechat_redirect\" ref=\"nofollow noopener noreferrer\"\u003E这里\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003E在线模拟红黑树增删的地址\u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Fgo%2FarticleRenderRedirect%3Furl%3Dhttps%253A%252F%252Fwww.cs.usfca.edu%252F%257Egalles%252Fvisualization%252FRedBlack.html\" target=\"_blank\" title=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fwww.cs.usfca.edu%2F%7Egalles%2Fvisualization%2FRedBlack.html\" ref=\"nofollow noopener noreferrer\"\u003E地址1\u003C\u002Fa\u003E、 \u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Fgo%2FarticleRenderRedirect%3Furl%3Dhttps%253A%252F%252Fsandbox.runjs.cn%252Fshow%252F2nngvn8w\" target=\"_blank\" title=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fsandbox.runjs.cn%2Fshow%2F2nngvn8w\" ref=\"nofollow noopener noreferrer\"\u003E地址2\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E红黑树的时间复杂度为【吐槽下简书这边如果用数学公式太蛋疼了】：\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003EO(logn)\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003E\u003C\u002Fp\u003E\u003Cdiv\u003E\u003Cdiv\u003E它的高度为:[logN,logN+1]（理论上，极端的情况下可以出现RBTree的高度达到2\u003C\u002Fdiv\u003ElogN，但实际上很难遇到）。\u003C\u002Fdiv\u003E*\u003Cp\u003E\u003C\u002Fp\u003E\u003Cp\u003E此外，由于它的设计任何不平衡将在三次旋转内解决。\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode lang=\"scss\" class=\"hljs language-scss copyable\"\u003E红黑树和avl树(最早的自平衡二叉树)的比较：\navl更加平衡，查询速率稍强于红黑树，但是插入和删除红黑树完爆avl树，可能由于hashMap的增删也挺频繁的，所以综合考虑而选择红黑树。\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cb\u003E总结：红黑树是种可以通过变色旋转的自平衡二叉查找树，对于hashMap来说，使用红黑树的好处在于，当有多个元素hash相同在同一数组下标的时候，使用红黑树在查找这些hash冲突的元素更快，它的时间复杂度从遍历链表O(n)降到O(logN)。\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Ch3 data-id=\"heading-19\"\u003E2.8 复杂度\u003C\u002Fh3\u003E\u003Cp\u003E算法复杂度分时间复杂度和空间复杂度。\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode lang=\"bash\" class=\"hljs copyable\"\u003E时间复杂度：执行算法所需要的计算工作量\n空间复杂度：执行算法所需要内存空间大小\n时间和空间都是计算机资源的体现，算法的复杂性体现在运行该算法时计算机所需资源的大小。\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cb\u003E这里重点讲下时间复杂度\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode lang=\"scss\" class=\"hljs language-scss copyable\"\u003E(\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E)时间频度\n用\u003Cspan class=\"hljs-built_in\"\u003ET\u003C\u002Fspan\u003E(n)表示\n一个算法执行所消耗的时间，理论上不能算出来而是通过运行测试得知，但不可能也没必要对每个算法都做上机测试，只需知道哪个算法花费时间多哪个花费少即可。在算法中一个算法花费的时间和这个算法执行的次数成正比。\n在一个算法中，语句执行次数称为时间频度(或称为语句频度)，记做为\u003Cspan class=\"hljs-built_in\"\u003ET\u003C\u002Fspan\u003E(n)，这里的n代表问题的规模。暂且不考虑这个T是啥，把它理解为一个函数。\n(\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E)时间复杂度 \n用Ｏ(f(n))表示\n当n变化时，时间频度\u003Cspan class=\"hljs-built_in\"\u003ET\u003C\u002Fspan\u003E(n)也会不断变化，但是它是个不确定的函数，我们想知道它呈现的规律是什么样的。这个时候引入了时间复杂度的概念。\n前面说\u003Cspan class=\"hljs-built_in\"\u003ET\u003C\u002Fspan\u003E(n)是个不确定的函数，它代表算法中基本操作重复执行的次数是问题规模n的某个函数。\n假设有某个辅助函数\u003Cspan class=\"hljs-built_in\"\u003Ef\u003C\u002Fspan\u003E(n),当n趋近∞，\u003Cspan class=\"hljs-built_in\"\u003ET\u003C\u002Fspan\u003E(n)\u002F\u003Cspan class=\"hljs-built_in\"\u003Ef\u003C\u002Fspan\u003E(n)的极限值不为\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E切位常数，那么可以认为\u003Cspan class=\"hljs-built_in\"\u003Ef\u003C\u002Fspan\u003E(n)和\u003Cspan class=\"hljs-built_in\"\u003ET\u003C\u002Fspan\u003E(n)为同一数量级的函数，记做为\u003Cspan class=\"hljs-built_in\"\u003ET\u003C\u002Fspan\u003E(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。\n\n\u003Cspan class=\"hljs-built_in\"\u003Ef\u003C\u002Fspan\u003E(n)虽然没有规定但一般都尽可能取简单的函数\n例如 \u003Cspan class=\"hljs-built_in\"\u003EO\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003En²+n +\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E) = O (\u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003En²+n+\u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E) = O (\u003Cspan class=\"hljs-number\"\u003E7\u003C\u002Fspan\u003En² + n) = O ( n² ) 省去了系数,只保留最高阶项。\n时间频度不同时，时间复杂度有可能相同，例如\u003Cspan class=\"hljs-built_in\"\u003ET\u003C\u002Fspan\u003E(n)=n²+\u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003En+\u003Cspan class=\"hljs-number\"\u003E4\u003C\u002Fspan\u003E与\u003Cspan class=\"hljs-built_in\"\u003ET\u003C\u002Fspan\u003E(n)=\u003Cspan class=\"hljs-number\"\u003E4\u003C\u002Fspan\u003En²+\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003En+\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E它们的频度不同，但时间复杂度相同，都为\u003Cspan class=\"hljs-built_in\"\u003EO\u003C\u002Fspan\u003E(n²)。\n\n总结两者关系:时间复杂度就是对时间频度函数的一层包装，它的特点(大O表示法)为\n①省去系数为\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E处理②保留最高项\n如果把T(n)当做为一棵树，那么O(f(n))只关心其主干部分。\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cb\u003E常见算法的时间复杂度从小到大依次为\u003C\u002Fb\u003E\u003Cbr\u003E\u003C\u002Fp\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E\u003Cimg alt=\"img_8f75b001aae9edc9b86bb1e9fc7c7f6d.png\" src=\"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fgold-user-assets\u002F2019\u002F9\u002F26\u002F16d6cc9bed0cf8cc~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp\" loading=\"lazy\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E复杂度比较\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode lang=\"bash\" class=\"hljs copyable\"\u003E求解算法的时间复杂度具体步骤为：\n①找出算法中执行次数最多的基本语句，一般是最内层的循环体。\n②计算基本语句的数量级\n③将基本语句执行次数的数量级放入大O记号中\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cb\u003E举几个例子\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003EO(1),又称常数阶，一般来说算法中没有循环体，执行次数为常数那么时间复杂度就为O(1)，例如\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode lang=\"ini\" class=\"hljs language-ini copyable\"\u003Eint \u003Cspan class=\"hljs-attr\"\u003Esum\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E,n = \u003Cspan class=\"hljs-number\"\u003E100\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-comment\"\u003E; \u002F\u002F执行一次  \u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-attr\"\u003Esum\u003C\u002Fspan\u003E = (\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E+n)*n\u002F\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-comment\"\u003E; \u002F\u002F执行一次  \u003C\u002Fspan\u003E\nSystem.out.println (sum)\u003Cspan class=\"hljs-comment\"\u003E; \u002F\u002F执行一次 \u003C\u002Fspan\u003E\n\u002F\u002F上面的算法运行次数为f(n)=3,那么根据大O表示法，该算法的时间复杂度为O(1)\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch5 data-id=\"heading-20\"\u003E\u003C\u002Fh5\u003E\u003Cp\u003E\u003Cb\u003E为什么O(logN)，对数阶不用底数\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E如红黑树的查找复杂为O(logN)\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E这里面有个可能存在的疑问，有时候时间复杂度都用包含O(logN)这样的描述 但是没有明确说明n的底数是多少，通常底数为2来计算\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E这种描述其实也是合理的，算法中log级别的时间复杂度都是由于使用了分治思想,这个底数直接由分治的复杂度决定。当n趋近于无穷大，两个大小比较也只是一个常数，所以这种时候O(logN)统一代表对数复杂度。\u003Cbr\u003E\\lim_{n\\rightarrow+\\infty} Ο(\\log_x{n})\u002FΟ(\\log_y{n}) = C\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E其它简单举例\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Ctable\u003E\u003Cthead\u003E\u003Ctr\u003E\u003Cth\u003E描述\u003C\u002Fth\u003E\u003Cth\u003E增长数量级\u003C\u002Fth\u003E\u003Cth\u003E典型代码\u003C\u002Fth\u003E\u003Cth\u003E说明\u003C\u002Fth\u003E\u003C\u002Ftr\u003E\u003C\u002Fthead\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E常数阶\u003C\u002Ftd\u003E\u003Ctd\u003E1\u003C\u002Ftd\u003E\u003Ctd\u003Ea = b + c\u003C\u002Ftd\u003E\u003Ctd\u003E普通简单算法操作\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E对数阶\u003C\u002Ftd\u003E\u003Ctd\u003ElogN\u003C\u002Ftd\u003E\u003Ctd\u003E二叉树中的二分法\u003C\u002Ftd\u003E\u003Ctd\u003E二分策略\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E线性级别\u003C\u002Ftd\u003E\u003Ctd\u003EN\u003C\u002Ftd\u003E\u003Ctd\u003Efor(int i = 0;i &#x3C; 10; i++) {...}\u003C\u002Ftd\u003E\u003Ctd\u003E普通单层循环算法\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E平方级别\u003C\u002Ftd\u003E\u003Ctd\u003EN²\u003C\u002Ftd\u003E\u003Ctd\u003Efor(int i = 0;i &#x3C; 10; i++) {for(int j = 0; j &#x3C; 10) {...}}\u003C\u002Ftd\u003E\u003Ctd\u003E双层循环，例如冒泡排序\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E指数级别\u003C\u002Ftd\u003E\u003Ctd\u003E2的n次方\u003C\u002Ftd\u003E\u003Ctd\u003E一个背包大小一定时，找出不大于背包所有物品组合，假设有3个物品，a，b，c，可能的组合有8种。(a,b,c,ab,ac,bc,abc+空(背包太小一个都容纳不下))\u003C\u002Ftd\u003E\u003Ctd\u003E穷举查找(背包问题\u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Fgo%2FarticleRenderRedirect%3Furl%3Dhttps%253A%252F%252Fwww.cnblogs.com%252Ftinaluo%252Fp%252F5264190.html\" target=\"_blank\" title=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fwww.cnblogs.com%2Ftinaluo%2Fp%2F5264190.html\" ref=\"nofollow noopener noreferrer\"\u003Ewww.cnblogs.com\u002Ftinaluo\u002Fp\u002F5…\u003C\u002Fa\u003E)\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Ch1 data-id=\"heading-21\"\u003E3. HashMap的内部实现(基于jdk1.8)\u003C\u002Fh1\u003E\u003Cblockquote\u003E\u003Cp\u003E刚开始看hashMap源码的时候，感觉思路很乱不知道写的啥东西，所以还是得从它的【数据结构】开始入手。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E\u003Cimg alt=\"img_550edf98975a3d557599d6792129fba5.jpe\" src=\"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fgold-user-assets\u002F2019\u002F9\u002F26\u002F16d6cc9bef779b0b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp\" loading=\"lazy\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cpre\u003E\u003Ccode lang=\"ini\" class=\"hljs language-ini copyable\"\u003E不同于一般类的数据结构，从结构来讲 \u003Cspan class=\"hljs-attr\"\u003EHashMap\u003C\u002Fspan\u003E = 数组 + 链表 + 红黑树(\u003Cspan class=\"hljs-number\"\u003E1.8\u003C\u002Fspan\u003E开始加入，大程度的优化了HashMap的性能)\narrayList  数组\nlinkedList 双向链表 查询效率慢，需通过遍历，新增或删除快，比如说删除一个元素 知道那个元素的上下引用 并改变关联上下元素的引用指向即可。\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3 data-id=\"heading-22\"\u003E3.1 数组和链表\u003C\u002Fh3\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E\u003Cimg alt=\"img_fdee83a22ddec90d5d4b5779804d0cd8.png\" src=\"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fgold-user-assets\u002F2019\u002F9\u002F26\u002F16d6cc9beec7d8de~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp\" loading=\"lazy\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E数组和链表.png\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Ch3 data-id=\"heading-23\"\u003E3.2 HashMap数据结构(数组+链表+红黑树)\u003C\u002Fh3\u003E\u003Cblockquote\u003E\u003Cp\u003E在jdk8以前，如果发生频繁碰撞的话，查找时间复杂度是O(1) + O(n) (先找在数组的位置再找链表)，n如果比较大则严重影响了查找性能，而到了jdk8引入红黑树,O(1) + O(logN)。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E\u003Cimg alt=\"img_97ec833243a8d841f179b1fd3d54c982.png\" src=\"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fgold-user-assets\u002F2019\u002F9\u002F26\u002F16d6cc9bf47291f9~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp\" loading=\"lazy\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003Ehashmap.png\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Ch2 data-id=\"heading-24\"\u003E大致思路\u003C\u002Fh2\u003E\u003Cpre\u003E\u003Ccode lang=\"arduino\" class=\"hljs language-arduino copyable\"\u003E①数组的优点是查询快，链表的优点是增删快，红黑树查询性能较好，hashMap的存储方式结合了它们的优点，那么hashMap的存储单元又可以在数组里，又可以在某个数组下的链表里。还有可能在红黑树当中。\n②我们已经知道HashMap是键值对的存在，且可以为各种类型，那么它又是以键值对的方式存在，它的最小存储单位是以Node节点为存储单位。\n这个Node结构大概有Key，Value，记录所在数组索引，以及记录链表指针的东西。\n大概结构如下\n\u003Cspan class=\"hljs-type\"\u003Estatic\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title class_\"\u003ENode\u003C\u002Fspan\u003E&#x3C;K,V\u003E implements Map.Entry&#x3C;K,V\u003E {\n  \u003Cspan class=\"hljs-keyword\"\u003Efinal\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-type\"\u003Eint\u003C\u002Fspan\u003E hash;\n  \u003Cspan class=\"hljs-keyword\"\u003Efinal\u003C\u002Fspan\u003E K key;\n  V value;\n  Node&#x3C;K,V\u003E next;\n  ...\n}\n\n③新来的Node节点怎么放?\nHashMap利用hashcode来确定存放的位置，但是又有个疑问，假设map对象key为\u003Cspan class=\"hljs-type\"\u003EString\u003C\u002Fspan\u003E型\nHashMap&#x3C;\u003Cspan class=\"hljs-type\"\u003EString\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-type\"\u003EString\u003C\u002Fspan\u003E\u003E map = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EHashMap\u003C\u002Fspan\u003E&#x3C;\u003Cspan class=\"hljs-type\"\u003EString\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-type\"\u003EString\u003C\u002Fspan\u003E\u003E();\nmap.\u003Cspan class=\"hljs-built_in\"\u003Eput\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E\"1\"\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E\"first\"\u003C\u002Fspan\u003E);\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F这个时候看put方法 \u003C\u002Fspan\u003E\nput方法的大致思路为\n①对key做hash运算，通过hash值计算index下标位置\n②如果没冲突直接放在桶上\n③如果冲突了，以链表的形式存在桶里面，达到一定条件链表变为红黑树\n④如果节点已经存在，则替换旧的\u003Cspan class=\"hljs-built_in\"\u003Evalue\u003C\u002Fspan\u003E(保证唯一性)\n⑤如果桶的个数超过了 加载因子乘当前容量，则做resize操作\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F可以注意到有个hash函数\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Epublic\u003C\u002Fspan\u003E V \u003Cspan class=\"hljs-title\"\u003Eput\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(K key, V value)\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E{\n   \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EputVal\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-built_in\"\u003Ehash\u003C\u002Fspan\u003E(key), key, value, \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E);\n}\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002Fhash函数 \u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-type\"\u003Estatic\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Efinal\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-type\"\u003Eint\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ehash\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(Object key)\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E{\n   \u003Cspan class=\"hljs-type\"\u003Eint\u003C\u002Fspan\u003E h;\n   \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E (key == null) ? \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E : (h = key.\u003Cspan class=\"hljs-built_in\"\u003EhashCode\u003C\u002Fspan\u003E()) ^ (h \u003E\u003E\u003E \u003Cspan class=\"hljs-number\"\u003E16\u003C\u002Fspan\u003E);\n}\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F上述代码String类型的1的Hashcode为49超过了HashMap的初始长度16，这个时候\"1\"这个key放在哪。这里\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F通过巧妙的设计存放在合适的位置 4.3.3做分析\u003C\u002Fspan\u003E\np = tab[i = (n - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E) &#x26; hash]，\n\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F这里的p为Node&#x3C;K,V\u003E对象，n为当前哈希桶数组长度，进行与运算后，因为这是第一个插入的元素，无需扩容长度为16,那么49 &#x26; 15 = 1，说明在的第二个位置。\u003C\u002Fspan\u003E\n\n④新节点插入后什么时候开始扩容\n接下来不断的插入的元素 经过hash函数和计算索引位置后，都可以根据它的散列性插入到不同的\u003Cspan class=\"hljs-number\"\u003E16\u003C\u002Fspan\u003E个位置，\n当元素个数达到\u003Cspan class=\"hljs-number\"\u003E16\u003C\u002Fspan\u003E * \u003Cspan class=\"hljs-number\"\u003E0.75\u003C\u002Fspan\u003E 即\u003Cspan class=\"hljs-number\"\u003E12\u003C\u002Fspan\u003E时，继续插入新的时候，开始扩容。\n【这里注意一下并不是说占满\u003Cspan class=\"hljs-number\"\u003E12\u003C\u002Fspan\u003E个位置才开始扩容，而是\u003Cspan class=\"hljs-number\"\u003E12\u003C\u002Fspan\u003E个节点，根据散列性分布\u003Cspan class=\"hljs-number\"\u003E12\u003C\u002Fspan\u003E个节点，占..\u003Cspan class=\"hljs-number\"\u003E.5\u003C\u002Fspan\u003E，\u003Cspan class=\"hljs-number\"\u003E6\u003C\u002Fspan\u003E，\u003Cspan class=\"hljs-number\"\u003E7\u003C\u002Fspan\u003E，\u003Cspan class=\"hljs-number\"\u003E8.\u003C\u002Fspan\u003E..个位置都有可能,比如说key为Integer类型，假如key为Integer类型，有五个节点key分别为\u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E，\u003Cspan class=\"hljs-number\"\u003E19\u003C\u002Fspan\u003E，\u003Cspan class=\"hljs-number\"\u003E12\u003C\u002Fspan\u003E，\u003Cspan class=\"hljs-number\"\u003E28\u003C\u002Fspan\u003E，\u003Cspan class=\"hljs-number\"\u003E44\u003C\u002Fspan\u003E这个时候\u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E，\u003Cspan class=\"hljs-number\"\u003E19\u003C\u002Fspan\u003E在同一个位置，\u003Cspan class=\"hljs-number\"\u003E12\u003C\u002Fspan\u003E，\u003Cspan class=\"hljs-number\"\u003E28\u003C\u002Fspan\u003E，\u003Cspan class=\"hljs-number\"\u003E44\u003C\u002Fspan\u003E在同一个位置，这个时候\u003Cspan class=\"hljs-number\"\u003E5\u003C\u002Fspan\u003E个节点就占了两个位置】\n\n\n⑤\u003Cspan class=\"hljs-built_in\"\u003Eresize\u003C\u002Fspan\u003E()方法进行扩容操作。\n\u003Cspan class=\"hljs-number\"\u003E1.\u003C\u002Fspan\u003E先判断节点数组是否为空，并取它的容量(节点个数)，创建新数组，大小时新的capacity\n如果不为空：\n如果容量超过最大值不做扩容，否则位运算一位做容量乘\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E处理，\n如果为空：\n桶数组容量为默认容量\u003Cspan class=\"hljs-number\"\u003E16\u003C\u002Fspan\u003E，即有默认放\u003Cspan class=\"hljs-number\"\u003E16\u003C\u002Fspan\u003E个桶，阈值默认为默认容量乘默认加载因子 \u003Cspan class=\"hljs-number\"\u003E12\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-number\"\u003E2.\u003C\u002Fspan\u003E将旧数组的元素放到新数组中，重新做映射\n如果旧的数组不为空，则遍历桶数组，并将键值对映射到新的桶数组中[树节点和链表节点做不同操作]\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch1 data-id=\"heading-25\"\u003E4.源码分析\u003C\u002Fh1\u003E\u003Ch3 data-id=\"heading-26\"\u003E4.1 基本存储单位Node节点\u003C\u002Fh3\u003E\u003Cpre\u003E\u003Ccode lang=\"typescript\" class=\"hljs language-typescript copyable\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Estatic\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title class_\"\u003ENode\u003C\u002Fspan\u003E&#x3C;K,V\u003E \u003Cspan class=\"hljs-keyword\"\u003Eimplements\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title class_\"\u003EMap\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-property\"\u003EEntry\u003C\u002Fspan\u003E&#x3C;K,V\u003E { \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F实现Entry接口 存储的是键值对的映射\u003C\u002Fspan\u003E\n    final int hash; \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002Fhash值，用于记录数组所在位置\u003C\u002Fspan\u003E\n    final K key; \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F用于匹配\u003C\u002Fspan\u003E\n    V value; \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F值\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-title class_\"\u003ENode\u003C\u002Fspan\u003E&#x3C;K,V\u003E next; \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F用于记录单链表下一节点 用于解决hash冲突(即hash值一样该存在哪里的问题)\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-title class_\"\u003ENode\u003C\u002Fspan\u003E(int hash, K key, V value, \u003Cspan class=\"hljs-title class_\"\u003ENode\u003C\u002Fspan\u003E&#x3C;K,V\u003E next) {\n        \u003Cspan class=\"hljs-variable language_\"\u003Ethis\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-property\"\u003Ehash\u003C\u002Fspan\u003E = hash;\n        \u003Cspan class=\"hljs-variable language_\"\u003Ethis\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-property\"\u003Ekey\u003C\u002Fspan\u003E = key;\n        \u003Cspan class=\"hljs-variable language_\"\u003Ethis\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-property\"\u003Evalue\u003C\u002Fspan\u003E = value;\n        \u003Cspan class=\"hljs-variable language_\"\u003Ethis\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-property\"\u003Enext\u003C\u002Fspan\u003E = next;\n    }\n    \u003Cspan class=\"hljs-keyword\"\u003Epublic\u003C\u002Fspan\u003E final K \u003Cspan class=\"hljs-title function_\"\u003EgetKey\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E)        { \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E key; }\n    \u003Cspan class=\"hljs-keyword\"\u003Epublic\u003C\u002Fspan\u003E final V \u003Cspan class=\"hljs-title function_\"\u003EgetValue\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E)      { \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E value; }\n    \u003Cspan class=\"hljs-keyword\"\u003Epublic\u003C\u002Fspan\u003E final \u003Cspan class=\"hljs-title class_\"\u003EString\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title function_\"\u003EtoString\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) { \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E key + \u003Cspan class=\"hljs-string\"\u003E\"=\"\u003C\u002Fspan\u003E + value; }\n    \u003Cspan class=\"hljs-keyword\"\u003Epublic\u003C\u002Fspan\u003E final int \u003Cspan class=\"hljs-title function_\"\u003EhashCode\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) {\n        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title class_\"\u003EObjects\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-title function_\"\u003EhashCode\u003C\u002Fspan\u003E(key) ^ \u003Cspan class=\"hljs-title class_\"\u003EObjects\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-title function_\"\u003EhashCode\u003C\u002Fspan\u003E(value);\n    }\n    \u003Cspan class=\"hljs-keyword\"\u003Epublic\u003C\u002Fspan\u003E final V \u003Cspan class=\"hljs-title function_\"\u003EsetValue\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003EV newValue\u003C\u002Fspan\u003E) {\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F赋值\u003C\u002Fspan\u003E\n        V oldValue = value;\n        value = newValue;\n        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E oldValue;\n    }\n    \u003Cspan class=\"hljs-keyword\"\u003Epublic\u003C\u002Fspan\u003E final \u003Cspan class=\"hljs-built_in\"\u003Eboolean\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title function_\"\u003Eequals\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003Cspan class=\"hljs-built_in\"\u003EObject\u003C\u002Fspan\u003E o\u003C\u002Fspan\u003E) {\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (o == \u003Cspan class=\"hljs-variable language_\"\u003Ethis\u003C\u002Fspan\u003E)\n            \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (o \u003Cspan class=\"hljs-keyword\"\u003Einstanceof\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title class_\"\u003EMap\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-property\"\u003EEntry\u003C\u002Fspan\u003E) {\n            \u003Cspan class=\"hljs-title class_\"\u003EMap\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-property\"\u003EEntry\u003C\u002Fspan\u003E&#x3C;?,?\u003E e = (\u003Cspan class=\"hljs-title class_\"\u003EMap\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-property\"\u003EEntry\u003C\u002Fspan\u003E&#x3C;?,?\u003E)o;\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-title class_\"\u003EObjects\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-title function_\"\u003Eequals\u003C\u002Fspan\u003E(key, e.\u003Cspan class=\"hljs-title function_\"\u003EgetKey\u003C\u002Fspan\u003E()) &#x26;&#x26;\n                \u003Cspan class=\"hljs-title class_\"\u003EObjects\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-title function_\"\u003Eequals\u003C\u002Fspan\u003E(value, e.\u003Cspan class=\"hljs-title function_\"\u003EgetValue\u003C\u002Fspan\u003E()))\n                \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n        }\n        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n    }\n}\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3 data-id=\"heading-27\"\u003E4.2 HashMap中的几个重要实现：hash函数，put、get、resize\u003C\u002Fh3\u003E\u003Cpre\u003E\u003Ccode lang=\"typescript\" class=\"hljs language-typescript copyable\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002Fput\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Epublic\u003C\u002Fspan\u003E V \u003Cspan class=\"hljs-title function_\"\u003Eput\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003EK key, V value\u003C\u002Fspan\u003E) {\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title function_\"\u003EputVal\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-title function_\"\u003Ehash\u003C\u002Fspan\u003E(key), key, value, \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E);\n}\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode lang=\"ini\" class=\"hljs language-ini copyable\"\u003Efinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    \u002F\u002F哈希表数组节点 \n    Node&#x3C;K,V\u003E\u003Cspan class=\"hljs-section\"\u003E[]\u003C\u002Fspan\u003E tab\u003Cspan class=\"hljs-comment\"\u003E; Node&#x3C;K,V\u003E p; int n, i;\u003C\u002Fspan\u003E\n    \u002F\u002F如果为空 调用resize以默认大小16扩容 \n    if ((\u003Cspan class=\"hljs-attr\"\u003Etab\u003C\u002Fspan\u003E = table) == null || (n = tab.length) == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E)\n        \u003Cspan class=\"hljs-attr\"\u003En\u003C\u002Fspan\u003E = (tab = resize()).length\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n    \u002F\u002F通过(n - 1) &#x26; hash计算存放索引位置 此处设计很巧妙\n    if ((\u003Cspan class=\"hljs-attr\"\u003Ep\u003C\u002Fspan\u003E = tab[i = (n - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E) &#x26; hash]) == null)\n      \u002F\u002F如果tab\u003Cspan class=\"hljs-section\"\u003E[i]\u003C\u002Fspan\u003E为空 该下标下没有节点 则直接新建一个Node放在该位置 \n        tab\u003Cspan class=\"hljs-section\"\u003E[i]\u003C\u002Fspan\u003E = newNode(hash, key, value, null)\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n    else {\n        \u002F\u002F下标上有节点 说明有hash冲突\n        Node&#x3C;K,V\u003E e\u003Cspan class=\"hljs-comment\"\u003E; K k;\u003C\u002Fspan\u003E\n        \u002F\u002F如果插入的新节点key已经存在，那么直接覆盖整个节点\n        if (\u003Cspan class=\"hljs-attr\"\u003Ep.hash\u003C\u002Fspan\u003E == hash &#x26;&#x26;\n            ((\u003Cspan class=\"hljs-attr\"\u003Ek\u003C\u002Fspan\u003E = p.key) == key || (key != null &#x26;&#x26; key.equals(k))))\n            \u003Cspan class=\"hljs-attr\"\u003Ee\u003C\u002Fspan\u003E = p\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n        \u002F\u002F如果为红黑树节点\n        else if (p instanceof TreeNode)\n            \u002F\u002F调用红黑树插入键值对的putTreeVal方法\n            \u003Cspan class=\"hljs-attr\"\u003Ee\u003C\u002Fspan\u003E = ((TreeNode&#x3C;K,V\u003E)p).putTreeVal(this, tab, hash, key, value)\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n        else {\n            \u002F\u002F不管tab\u003Cspan class=\"hljs-section\"\u003E[index]\u003C\u002Fspan\u003E是否为空，p节点已经为 tab\u003Cspan class=\"hljs-section\"\u003E[index]\u003C\u002Fspan\u003E上\n            \u002F\u002F如果有冲突 且不为红黑树节点 那么此时遍历链表节点 binCount计算链表长度\n            for (int \u003Cspan class=\"hljs-attr\"\u003EbinCount\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-comment\"\u003E; ; ++binCount) {\u003C\u002Fspan\u003E\n                if ((\u003Cspan class=\"hljs-attr\"\u003Ee\u003C\u002Fspan\u003E = p.next) == null) {\n                    \u003Cspan class=\"hljs-attr\"\u003Ep.next\u003C\u002Fspan\u003E = newNode(hash, key, value, null)\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n                   \u002F\u002F链表长度大于等于7，调用treeifyBin对链表进行树化\n                    if (binCount \u003E= TREEIFY_THRESHOLD - 1) \u002F\u002F -1 for 1st\n                        treeifyBin(tab, hash)\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n                    break\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n                }\n                \u002F\u002F遍历链表时发现重复 覆盖并跳出循环\n                if (\u003Cspan class=\"hljs-attr\"\u003Ee.hash\u003C\u002Fspan\u003E == hash &#x26;&#x26;\n                    ((\u003Cspan class=\"hljs-attr\"\u003Ek\u003C\u002Fspan\u003E = e.key) == key || (key != null &#x26;&#x26; key.equals(k))))\n                    break\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n                \u003Cspan class=\"hljs-attr\"\u003Ep\u003C\u002Fspan\u003E = e\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n            }\n        }\n        if (e != null) { \u002F\u002F existing mapping for key\n            V \u003Cspan class=\"hljs-attr\"\u003EoldValue\u003C\u002Fspan\u003E = e.value\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n            if (!onlyIfAbsent || \u003Cspan class=\"hljs-attr\"\u003EoldValue\u003C\u002Fspan\u003E == null)\n                \u003Cspan class=\"hljs-attr\"\u003Ee.value\u003C\u002Fspan\u003E = value\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n            afterNodeAccess(e)\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n            return oldValue\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n        }\n    }\n    ++modCount\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n    \u002F\u002F插入成功后 再根据实际判断是否到到阈值 比如说现在容量16(桶的个数16) 正在插第13个元素时 到达则扩容 \n    if (++size \u003E threshold)\n        resize()\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n    afterNodeInsertion(evict)\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n    return null\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n}\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3 data-id=\"heading-28\"\u003Eget方法\u003C\u002Fh3\u003E\u003Cpre\u003E\u003Ccode lang=\"ini\" class=\"hljs language-ini copyable\"\u003Epublic V get(Object key) {\n    Node&#x3C;K,V\u003E e\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n    return (\u003Cspan class=\"hljs-attr\"\u003Ee\u003C\u002Fspan\u003E = getNode(hash(key), key)) == null ? null : e.value\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n}\n\nfinal Node&#x3C;K,V\u003E getNode(int hash, Object key) {\n    Node&#x3C;K,V\u003E\u003Cspan class=\"hljs-section\"\u003E[]\u003C\u002Fspan\u003E tab\u003Cspan class=\"hljs-comment\"\u003E; Node&#x3C;K,V\u003E first, e; int n; K k;\u003C\u002Fspan\u003E\n    \u002F\u002F先定位键值对在所在桶的位置\n    if ((\u003Cspan class=\"hljs-attr\"\u003Etab\u003C\u002Fspan\u003E = table) != null &#x26;&#x26; (n = tab.length) \u003E \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E &#x26;&#x26;\n        (\u003Cspan class=\"hljs-attr\"\u003Efirst\u003C\u002Fspan\u003E = tab[(n - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E) &#x26; hash]) != null) {\n        if (\u003Cspan class=\"hljs-attr\"\u003Efirst.hash\u003C\u002Fspan\u003E == hash &#x26;&#x26; \u002F\u002F always check first node \n            ((\u003Cspan class=\"hljs-attr\"\u003Ek\u003C\u002Fspan\u003E = first.key) == key || (key != null &#x26;&#x26; key.equals(k))))\n            return first\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n        if ((\u003Cspan class=\"hljs-attr\"\u003Ee\u003C\u002Fspan\u003E = first.next) != null) {\n            if (first instanceof TreeNode)\n                \u002F\u002F如果是红黑树节点 通过红黑树查找方法查找\n                return ((TreeNode&#x3C;K,V\u003E)first).getTreeNode(hash, key)\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n            do {\n                \u002F\u002F对链表查找\n                if (\u003Cspan class=\"hljs-attr\"\u003Ee.hash\u003C\u002Fspan\u003E == hash &#x26;&#x26;\n                    ((\u003Cspan class=\"hljs-attr\"\u003Ek\u003C\u002Fspan\u003E = e.key) == key || (key != null &#x26;&#x26; key.equals(k))))\n                    return e\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n            } while ((\u003Cspan class=\"hljs-attr\"\u003Ee\u003C\u002Fspan\u003E = e.next) != null)\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n        }\n    }\n    return null\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n}\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3 data-id=\"heading-29\"\u003E4.4.5 resize()\u003C\u002Fh3\u003E\u003Cp\u003E扩容就是重新定义容量，在hashmap中，如果不断的put元素，而hashMap对象中的数组无法装得下更多对象时，对象就需要进行扩容，扩大数组长度。这边注意的是：\u003C\u002Fp\u003E\u003Cp\u003E\u003C\u002Fp\u003E\u003Cdiv\u003E\u003Cdiv\u003E①假如初始大小为默认值16，什么时候扩容，我们可以知道阈值是16\u003C\u002Fdiv\u003E0.75即12，这个12是指hashMap的size(全局变量，每次put+1.remove-1)，put后为大于12即13时开始执行resize方法扩容。\u003C\u002Fdiv\u003E*\u003Cp\u003E\u003C\u002Fp\u003E\u003Cp\u003E②\u003Cb\u003E在java中数组是不能够自动扩容的，是采用一个新的大容量数组代替原有的小数组，就好比用一个小桶装水，如果想用一个桶装更多的水，就换一个大桶再把原来小桶的水装过去。\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E③扩容后，普通链表上的节点包括红黑树都得重新映射。\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003E对于hashmap来说\u003Cbr\u003E什么时候换大桶：达到阈值的时候\u003Cbr\u003E换多大的桶：原有小桶的两倍大小\u003Cbr\u003E但桶的大小也是有限的，对于hashMap，最大的桶能容纳包含2^30个数，大于的话就不再扩容，就随里面碰撞了。(实际上也很难用到这么大的容量)\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cpre\u003E\u003Ccode lang=\"ini\" class=\"hljs language-ini copyable\"\u003Efinal Node&#x3C;K,V\u003E\u003Cspan class=\"hljs-section\"\u003E[]\u003C\u002Fspan\u003E resize() {\n    \u002F\u002Ftable为全局变量transient Node&#x3C;K,V\u003E\u003Cspan class=\"hljs-section\"\u003E[]\u003C\u002Fspan\u003E table\u003Cspan class=\"hljs-comment\"\u003E; 赋值给oldTab\u003C\u002Fspan\u003E\n    Node&#x3C;K,V\u003E\u003Cspan class=\"hljs-section\"\u003E[]\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003EoldTab\u003C\u002Fspan\u003E = table\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n    int \u003Cspan class=\"hljs-attr\"\u003EoldCap\u003C\u002Fspan\u003E = (oldTab == null) ? \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E : oldTab.length\u003Cspan class=\"hljs-comment\"\u003E;\u002F\u002F旧表数组个数\u003C\u002Fspan\u003E\n    int \u003Cspan class=\"hljs-attr\"\u003EoldThr\u003C\u002Fspan\u003E = threshold\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n    int newCap, \u003Cspan class=\"hljs-attr\"\u003EnewThr\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n    if (oldCap \u003E 0) { \u002F\u002F如果旧容量大于0    \n        \u002F\u002F超过最大值就不扩容了，随它碰撞去吧 -。-\n        if (oldCap \u003E= MAXIMUM_CAPACITY) {\n            \u003Cspan class=\"hljs-attr\"\u003Ethreshold\u003C\u002Fspan\u003E = Integer.MAX_VALUE\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n            return oldTab\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n        }\n        \u002F\u002F×2还没超过最大值，新数组就扩容为原来两倍 阈值也做×2处理\n        else if ((\u003Cspan class=\"hljs-attr\"\u003EnewCap\u003C\u002Fspan\u003E = oldCap &#x3C;&#x3C; \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E) &#x3C; MAXIMUM_CAPACITY &#x26;&#x26;\n                 oldCap \u003E= DEFAULT_INITIAL_CAPACITY)\n            \u003Cspan class=\"hljs-attr\"\u003EnewThr\u003C\u002Fspan\u003E = oldThr &#x3C;&#x3C; \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-comment\"\u003E; \u002F\u002F double threshold \u003C\u002Fspan\u003E\n    }\n    \u002F\u002F如果原来的阈值 \u003E 0且旧容量为0，则将新容量设为原来的阈值，初始化有参给threshold赋值会有此情况\n    else if (oldThr \u003E 0) \n        \u003Cspan class=\"hljs-attr\"\u003EnewCap\u003C\u002Fspan\u003E = oldThr\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n    else { \u002F\u002F zero initial threshold signifies using defaults\n        \u002F\u002F默认初始化无参构造的情况 \n        \u003Cspan class=\"hljs-attr\"\u003EnewCap\u003C\u002Fspan\u003E = DEFAULT_INITIAL_CAPACITY\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-attr\"\u003EnewThr\u003C\u002Fspan\u003E = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY)\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n    }\n    \u002F\u002F如果\n    if (\u003Cspan class=\"hljs-attr\"\u003EnewThr\u003C\u002Fspan\u003E == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E) {\n        float \u003Cspan class=\"hljs-attr\"\u003Eft\u003C\u002Fspan\u003E = (float)newCap * loadFactor\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-attr\"\u003EnewThr\u003C\u002Fspan\u003E = (newCap &#x3C; MAXIMUM_CAPACITY &#x26;&#x26; ft &#x3C; (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE)\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n    }\n    \u003Cspan class=\"hljs-attr\"\u003Ethreshold\u003C\u002Fspan\u003E = newThr\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) \u002F\u002F屏蔽无关紧要的警告\n        Node&#x3C;K,V\u003E\u003Cspan class=\"hljs-section\"\u003E[]\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003EnewTab\u003C\u002Fspan\u003E = (Node&#x3C;K,V\u003E[])new Node[newCap]\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-attr\"\u003Etable\u003C\u002Fspan\u003E = newTab\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n    \u002F\u002F如果旧数组不为空 \n    if (oldTab != null) {\n        \u002F\u002F遍历数组\n        for (int \u003Cspan class=\"hljs-attr\"\u003Ej\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-comment\"\u003E; j &#x3C; oldCap; ++j) {\u003C\u002Fspan\u003E\n            Node&#x3C;K,V\u003E e\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n            \u002F\u002F数组中的节点不为空\n            if ((\u003Cspan class=\"hljs-attr\"\u003Ee\u003C\u002Fspan\u003E = oldTab[j]) != null) {\n                oldTab\u003Cspan class=\"hljs-section\"\u003E[j]\u003C\u002Fspan\u003E = null\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n                \u002F\u002F如果该桶只有一个节点(说明下面没有链表，或者说只有一个链表节点)\n                if (\u003Cspan class=\"hljs-attr\"\u003Ee.next\u003C\u002Fspan\u003E == null)\n                    \u002F\u002Fe.hash &#x26; (newCap - 1)确定元素存放位置\n                    newTab\u003Cspan class=\"hljs-section\"\u003E[e.hash &#x26; (newCap - 1)]\u003C\u002Fspan\u003E = e\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n                else if (e instanceof TreeNode)\n                    \u002F\u002F红黑树节点\n                    ((TreeNode&#x3C;K,V\u003E)e).split(this, newTab, j, oldCap)\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n                else { \n                    \u002F\u002F链表节点且当前链表节点不止1个\n                    Node&#x3C;K,V\u003E \u003Cspan class=\"hljs-attr\"\u003EloHead\u003C\u002Fspan\u003E = null, loTail = null\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n                    Node&#x3C;K,V\u003E \u003Cspan class=\"hljs-attr\"\u003EhiHead\u003C\u002Fspan\u003E = null, hiTail = null\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n                    Node&#x3C;K,V\u003E next\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n                    do {\n                        \u003Cspan class=\"hljs-attr\"\u003Enext\u003C\u002Fspan\u003E = e.next\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n                        \u002F\u002F根据e.hash &#x26; oldCap 判断节点存放位置\n                        \u002F\u002F如果为0 扩容还在原来位置 如果为1 新的位置为 旧的index + oldCap 下面如何扩容有做介绍\n                        if ((e.hash &#x26; oldCap) == 0) {\n                            if (\u003Cspan class=\"hljs-attr\"\u003EloTail\u003C\u002Fspan\u003E == null)\n                                \u003Cspan class=\"hljs-attr\"\u003EloHead\u003C\u002Fspan\u003E = e\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n                            else\n                                \u003Cspan class=\"hljs-attr\"\u003EloTail.next\u003C\u002Fspan\u003E = e\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n                            \u003Cspan class=\"hljs-attr\"\u003EloTail\u003C\u002Fspan\u003E = e\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n                        }\n                        else {\n                            if (\u003Cspan class=\"hljs-attr\"\u003EhiTail\u003C\u002Fspan\u003E == null)\n                                \u003Cspan class=\"hljs-attr\"\u003EhiHead\u003C\u002Fspan\u003E = e\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n                            else\n                                \u003Cspan class=\"hljs-attr\"\u003EhiTail.next\u003C\u002Fspan\u003E = e\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n                            \u003Cspan class=\"hljs-attr\"\u003EhiTail\u003C\u002Fspan\u003E = e\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n                        }\n                    } while ((\u003Cspan class=\"hljs-attr\"\u003Ee\u003C\u002Fspan\u003E = next) != null)\u003Cspan class=\"hljs-comment\"\u003E;\u002F\u002F旧链表迁移到新链表\u003C\u002Fspan\u003E\n                    if (loTail != null) {\n                        \u003Cspan class=\"hljs-attr\"\u003EloTail.next\u003C\u002Fspan\u003E = null\u003Cspan class=\"hljs-comment\"\u003E;\u002F\u002F将链表的尾节点的next设置为空\u003C\u002Fspan\u003E\n                        newTab\u003Cspan class=\"hljs-section\"\u003E[j]\u003C\u002Fspan\u003E = loHead\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n                    }\n                    if (hiTail != null) {\n                        \u003Cspan class=\"hljs-attr\"\u003EhiTail.next\u003C\u002Fspan\u003E = null\u003Cspan class=\"hljs-comment\"\u003E;\u002F\u002F 将链表的尾节点 的next 设置为空\u003C\u002Fspan\u003E\n                        newTab\u003Cspan class=\"hljs-section\"\u003E[j + oldCap]\u003C\u002Fspan\u003E = hiHead\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n                    }\n                }\n            }\n        }\n    }\n    return newTab\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n}\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3 data-id=\"heading-30\"\u003E4.3 HashMap经典代码 p = tab[i = (n - 1) &#x26; hash])\u003C\u002Fh3\u003E\u003Cpre\u003E\u003Ccode lang=\"css\" class=\"hljs language-css copyable\"\u003E\u003Cspan class=\"hljs-selector-tag\"\u003Ep\u003C\u002Fspan\u003E = tab\u003Cspan class=\"hljs-selector-attr\"\u003E[i = (n - 1) &#x26; hash]\u003C\u002Fspan\u003E)\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E当hashCode小于65536，散列是很规律的，基本上索引的位置就是\u003C\u002Fp\u003E\u003Cp\u003E因为小于这个数右移16为都为0，且和占位符都为0的值异或后的hashcode就是自身的值。\u003C\u002Fp\u003E\u003Cp\u003E这个值比较特殊\u003C\u002Fp\u003E\u003Cp\u003E转换为二进制：00000000000000010000000000000000，右移16的话00000000000000000000000000000001并不全为0\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode lang=\"java\" class=\"hljs language-java copyable\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Estatic\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Efinal\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-type\"\u003Eint\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title function_\"\u003Ehash\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(Object key)\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-type\"\u003Eint\u003C\u002Fspan\u003E h;\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E (key == \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E) ? \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E : (h = key.hashCode()) ^ (h \u003E\u003E\u003E \u003Cspan class=\"hljs-number\"\u003E16\u003C\u002Fspan\u003E);\n}\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Ekey的hashcode为65536\u003C\u002Fp\u003E\u003Cp\u003E转为二进制：h=key.hashCode() 00000000000000010000000000000000\u003C\u002Fp\u003E\u003Cp\u003E跟右移16位的再做异或操作 00000000000000000000000000000001\u003C\u002Fp\u003E\u003Cp\u003Ehash = h ^(h\u003E\u003E\u003E16) 00000000000000010000000000000001\u003C\u002Fp\u003E\u003Cp\u003E​\u003C\u002Fp\u003E\u003Cp\u003E计算hash 00000000000000010000000000000001\u003C\u002Fp\u003E\u003Cp\u003E​ 00000000000000000000000000001111\u003C\u002Fp\u003E\u003Cp\u003E结果 1\u003C\u002Fp\u003E\u003Cp\u003E但是65536 % 16 = 0\u003C\u002Fp\u003E\u003Cp\u003Ekey的hashcode为17 异或相同为0 不同为假\u003C\u002Fp\u003E\u003Cp\u003E转为二进制：h=key.hashCode() 00000000000000000000000000010001\u003C\u002Fp\u003E\u003Cp\u003E跟右移16位的再做异或操作 00000000000000000000000000000000\u003C\u002Fp\u003E\u003Cp\u003Ehash = h ^(h\u003E\u003E16) 00000000000000000000000000010001\u003C\u002Fp\u003E\u003Cp\u003E计算hash 00000000000000000000000000010001\u003C\u002Fp\u003E\u003Cp\u003E​ 00000000000000000000000000001111\u003C\u002Fp\u003E\u003Cp\u003E​ 00000000000000000000000000000001\u003C\u002Fp\u003E\u003Cp\u003E做个小测试，假设这个时候桶的个数为16，代码如下\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode lang=\"less\" class=\"hljs language-less copyable\"\u003E\u003Cspan class=\"hljs-selector-tag\"\u003Efor\u003C\u002Fspan\u003E (int key = \u003Cspan class=\"hljs-number\"\u003E65533\u003C\u002Fspan\u003E; key &#x3C; \u003Cspan class=\"hljs-number\"\u003E65543\u003C\u002Fspan\u003E; key++) { \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F从65536开始变得有点\"特别\"\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-selector-tag\"\u003ESystem\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-selector-class\"\u003E.out\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-selector-class\"\u003E.println\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E\"key为：\"\u003C\u002Fspan\u003E + key +  \u003Cspan class=\"hljs-string\"\u003E\"，索引位置：\"\u003C\u002Fspan\u003E + ((key ^ (key \u003E\u003E\u003E \u003Cspan class=\"hljs-number\"\u003E16\u003C\u002Fspan\u003E)) &#x26; \u003Cspan class=\"hljs-number\"\u003E15\u003C\u002Fspan\u003E));\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F假设初始容量为16 测试没扩容时这些数的索引位置\u003C\u002Fspan\u003E\n}\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F输出结果为，可以发现从65536开始不为0而是1，有点特殊，然后相邻两个索引位置呈1,3的增长，具体可画图尝试\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-selector-tag\"\u003Ei\u003C\u002Fspan\u003E为：\u003Cspan class=\"hljs-number\"\u003E65533\u003C\u002Fspan\u003E，输出\u003Cspan class=\"hljs-number\"\u003E13\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-selector-tag\"\u003Ei\u003C\u002Fspan\u003E为：\u003Cspan class=\"hljs-number\"\u003E65534\u003C\u002Fspan\u003E，输出\u003Cspan class=\"hljs-number\"\u003E14\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-selector-tag\"\u003Ei\u003C\u002Fspan\u003E为：\u003Cspan class=\"hljs-number\"\u003E65535\u003C\u002Fspan\u003E，输出\u003Cspan class=\"hljs-number\"\u003E15\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-selector-tag\"\u003Ei\u003C\u002Fspan\u003E为：\u003Cspan class=\"hljs-number\"\u003E65536\u003C\u002Fspan\u003E，输出\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-selector-tag\"\u003Ei\u003C\u002Fspan\u003E为：\u003Cspan class=\"hljs-number\"\u003E65537\u003C\u002Fspan\u003E，输出\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-selector-tag\"\u003Ei\u003C\u002Fspan\u003E为：\u003Cspan class=\"hljs-number\"\u003E65538\u003C\u002Fspan\u003E，输出\u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-selector-tag\"\u003Ei\u003C\u002Fspan\u003E为：\u003Cspan class=\"hljs-number\"\u003E65539\u003C\u002Fspan\u003E，输出\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-selector-tag\"\u003Ei\u003C\u002Fspan\u003E为：\u003Cspan class=\"hljs-number\"\u003E65540\u003C\u002Fspan\u003E，输出\u003Cspan class=\"hljs-number\"\u003E5\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-selector-tag\"\u003Ei\u003C\u002Fspan\u003E为：\u003Cspan class=\"hljs-number\"\u003E65541\u003C\u002Fspan\u003E，输出\u003Cspan class=\"hljs-number\"\u003E4\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-selector-tag\"\u003Ei\u003C\u002Fspan\u003E为：\u003Cspan class=\"hljs-number\"\u003E65542\u003C\u002Fspan\u003E，输出\u003Cspan class=\"hljs-number\"\u003E7\u003C\u002Fspan\u003E\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E这段代码主要是计算索引位置的，HashMap 底层数组的长度总是 2 的 n 次方\u003C\u002Fp\u003E\u003Cp\u003E当 length 总是 2 的倍数时，h&#x26; (length-1)，将是一个非常巧妙的设计：\u003C\u002Fp\u003E\u003Ctable\u003E\u003Cthead\u003E\u003Ctr\u003E\u003Cth\u003Ehash值\u003C\u002Fth\u003E\u003Cth\u003Elength(假设长度为16)\u003C\u002Fth\u003E\u003Cth\u003Eh &#x26; length - 1\u003C\u002Fth\u003E\u003C\u002Ftr\u003E\u003C\u002Fthead\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E5\u003C\u002Ftd\u003E\u003Ctd\u003E16\u003C\u002Ftd\u003E\u003Ctd\u003E5\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E6\u003C\u002Ftd\u003E\u003Ctd\u003E16\u003C\u002Ftd\u003E\u003Ctd\u003E6\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E15\u003C\u002Ftd\u003E\u003Ctd\u003E16\u003C\u002Ftd\u003E\u003Ctd\u003E15\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E16\u003C\u002Ftd\u003E\u003Ctd\u003E16\u003C\u002Ftd\u003E\u003Ctd\u003E0\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003Ctr\u003E\u003Ctd\u003E17\u003C\u002Ftd\u003E\u003Ctd\u003E16\u003C\u002Ftd\u003E\u003Ctd\u003E1\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\u003Cp\u003E\u003Cb\u003E可以看到计算得到的索引值总是位于 table 数组的索引之内。并且通常分布的比较均匀\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Ch3 data-id=\"heading-31\"\u003E4.4 树形化treeifyBin()\u003C\u002Fh3\u003E\u003Cp\u003E在jdk8以前，如果发生频繁碰撞的话，查找时间复杂度是O(1) + O(n) (先找在数组的位置再找链表)，n如果比较大则严重影响了查找性能，而到了jdk8引入红黑树,O(1) + O(logN)。\u003C\u002Fp\u003E\u003Cp\u003Ejdk1.8中，如果一个桶中元素个数超过TREEIFY_THRESHOLD(8)时，就用红黑树替换链表以提升速度(主要是查找)\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode lang=\"ini\" class=\"hljs language-ini copyable\"\u003E\u002F\u002F将桶内所有链表节点换成红黑树节点\nfinal void treeifyBin(Node&#x3C;K,V\u003E\u003Cspan class=\"hljs-section\"\u003E[]\u003C\u002Fspan\u003E tab, int hash) {\n    int n, index\u003Cspan class=\"hljs-comment\"\u003E; Node&#x3C;K,V\u003E e;\u003C\u002Fspan\u003E\n    \u002F\u002F如果当前哈希表为空 或者哈希表中元素 MIN_TREEIFY_CAPACITY默认为64，对于这个值可以认为，如果节点数组长度小于64，就没必要去进行结构转换，而是通过resize()操作，这样原先一个链表的元素可能会进行重新分配。\n    if (\u003Cspan class=\"hljs-attr\"\u003Etab\u003C\u002Fspan\u003E == null || (n = tab.length) &#x3C; MIN_TREEIFY_CAPACITY)\n        resize()\u003Cspan class=\"hljs-comment\"\u003E; \u002F\u002F扩容\u003C\u002Fspan\u003E\n    \u002F\u002F大于等于64 就树化 链表上的普通节点变成树节点\n    else if ((\u003Cspan class=\"hljs-attr\"\u003Ee\u003C\u002Fspan\u003E = tab[index = (n - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E) &#x26; hash]) != null) {      \n        TreeNode&#x3C;K,V\u003E \u003Cspan class=\"hljs-attr\"\u003Ehd\u003C\u002Fspan\u003E = null, tl = null\u003Cspan class=\"hljs-comment\"\u003E; \u002F\u002F定义首、尾节点\u003C\u002Fspan\u003E\n        do {\n            TreeNode&#x3C;K,V\u003E \u003Cspan class=\"hljs-attr\"\u003Ep\u003C\u002Fspan\u003E = replacementTreeNode(e, null)\u003Cspan class=\"hljs-comment\"\u003E; \u002F\u002F普通节点 -\u003E 树节点\u003C\u002Fspan\u003E\n            if (\u003Cspan class=\"hljs-attr\"\u003Etl\u003C\u002Fspan\u003E == null) \u002F\u002F如果尾节点为空 说明还没有根节点\n                \u003Cspan class=\"hljs-attr\"\u003Ehd\u003C\u002Fspan\u003E = p\u003Cspan class=\"hljs-comment\"\u003E; \u002F\u002F首节点(根节点) 指向当前节点\u003C\u002Fspan\u003E\n            else { \u002F\u002F尾节点不为空 \n                \u003Cspan class=\"hljs-attr\"\u003Ep.prev\u003C\u002Fspan\u003E = tl\u003Cspan class=\"hljs-comment\"\u003E; \u002F\u002F当前树节点前一个节点指向尾节点\u003C\u002Fspan\u003E\n                \u003Cspan class=\"hljs-attr\"\u003Etl.next\u003C\u002Fspan\u003E = p\u003Cspan class=\"hljs-comment\"\u003E; \u002F\u002F尾节点后一个节点 指向当前节点\u003C\u002Fspan\u003E\n            }\n            \u003Cspan class=\"hljs-attr\"\u003Etl\u003C\u002Fspan\u003E = p\u003Cspan class=\"hljs-comment\"\u003E; \u003C\u002Fspan\u003E\n        } while ((\u003Cspan class=\"hljs-attr\"\u003Ee\u003C\u002Fspan\u003E = e.next) != null)\u003Cspan class=\"hljs-comment\"\u003E; \u002F\u002F继续遍历链表\u003C\u002Fspan\u003E\n      \n        \u002F\u002F这个时候只是把Node对象变成TreeNode对象，把单向链表变成双向链表\n        if ((tab\u003Cspan class=\"hljs-section\"\u003E[index]\u003C\u002Fspan\u003E = hd) != null)\n            hd.treeify(tab)\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n    }\n}\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch1 data-id=\"heading-32\"\u003E5.思考\u003C\u002Fh1\u003E\u003Ch3 data-id=\"heading-33\"\u003E1.HashMap和HashTable的区别是什么\u003C\u002Fh3\u003E\u003Cp\u003EHashMap和Hashtable都实现了Map接口\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003EHashMap功能上几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。\u003Cbr\u003EHashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的\u003Cbr\u003E由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。\u003Cbr\u003EHashMap不能保证随着时间的推移Map中的元素次序是不变的。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003E由于性能问题，以及HashTable处理Hash冲突比HashMap逊色很多，现在HashTable已经很少使用了。但由于线程安全以及以前的项目还在使用，SUN依然还保留着它并没有加Deprecated过时注解。\u003C\u002Fp\u003E\u003Cp\u003E摘自hashtable源码\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003EIf a thread-safe implementation is not needed, it is recommended to use HashMap in place of Hashtable. If a thread-safe highly-concurrent implementation is desired, then it is recommended to use java.util.concurrent.ConcurrentHashMap in place of Hashtable.\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003E简单来说就是不需要线程安全，那么使用HashMap，如果需要线程安全，那么使用ConcurrentHashMap。\u003C\u002Fp\u003E\u003Ch3 data-id=\"heading-34\"\u003E2.HashMap为什么线程不安全，如果想要线程安全怎么做\u003C\u002Fh3\u003E\u003Cp\u003E因为hashmap为了性能，它的put，resize等操作都不是同步的，假设两个线程同一时间做put操作,可能最后计算的size并不正确，值得一提的是jdk1.8以前多线程put甚至会导致闭环死循环，1.8开始不会有这个问题但依然存在线程安全问题。\u003C\u002Fp\u003E\u003Cp\u003Ejdk8前的闭环死循环。\u003C\u002Fp\u003E\u003Cp\u003E这种问题在单线程下不存在，但在多线程下可能引起死循环导致cpu占用过高。\u003C\u002Fp\u003E\u003Cp\u003E如果hash冲突大，同一链表下下有多个节点容易出现这种问题。具体参考\u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Fgo%2FarticleRenderRedirect%3Furl%3Dhttps%253A%252F%252Fwww.jianshu.com%252Fp%252F1e9cf0ac07f4\" target=\"_blank\" title=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fwww.jianshu.com%2Fp%2F1e9cf0ac07f4\" ref=\"nofollow noopener noreferrer\"\u003E老生常谈，HashMap的死循环\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode lang=\"scss\" class=\"hljs language-scss copyable\"\u003E若想要线程安全\n\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E、使用ConcurrentHashMap。(线程安全的hashMap)\n\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E、使用Collections\u003Cspan class=\"hljs-selector-class\"\u003E.synchronizedMap\u003C\u002Fspan\u003E(Mao&#x3C;K,V\u003E m)方法把HashMap变成一个线程安全的Map。\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3 data-id=\"heading-35\"\u003E3.HashMap是怎么解决Hash冲突的\u003C\u002Fh3\u003E\u003Cpre\u003E\u003Ccode lang=\"scss\" class=\"hljs language-scss copyable\"\u003E在实际应用中，无论怎么构造哈希函数，冲突也难以完全避免。\nHashMap根据链地址法(拉链法)来解决冲突,jdk8中如果链表长度大于\u003Cspan class=\"hljs-number\"\u003E8\u003C\u002Fspan\u003E且节点数组长度大于\u003Cspan class=\"hljs-number\"\u003E64\u003C\u002Fspan\u003E的时候，就把链表下所有节点转为红黑树，位于数组上的节点为根节点，来维护hash冲突的元素，链表中冲突的元素可以通过key的\u003Cspan class=\"hljs-built_in\"\u003Eequals\u003C\u002Fspan\u003E()方法来确定。\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3 data-id=\"heading-36\"\u003E4.HashMap是怎么扩容的\u003C\u002Fh3\u003E\u003Cp\u003E先写个例子测试hashMap有没有在扩容。\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode lang=\"arduino\" class=\"hljs language-arduino copyable\"\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Epublic\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-type\"\u003Estatic\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-type\"\u003Evoid\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Emain\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(\u003Cspan class=\"hljs-type\"\u003EString\u003C\u002Fspan\u003E[] args)\u003C\u002Fspan\u003E throws NoSuchMethodException, InvocationTargetException, IllegalAccessException \u003C\u002Fspan\u003E{\n    HashMap&#x3C;Integer,\u003Cspan class=\"hljs-type\"\u003EString\u003C\u002Fspan\u003E\u003E o = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E HashMap&#x3C;\u003E(\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E);\n    System.out.\u003Cspan class=\"hljs-built_in\"\u003Eprintln\u003C\u002Fspan\u003E(o.\u003Cspan class=\"hljs-built_in\"\u003Esize\u003C\u002Fspan\u003E()); \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F0 size为元素个数\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F扩容条件是 如果没有定义初始容量 默认扩容至16 如果没有 根据put的情况扩容\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002Fput的过程中 如果插入一个元素过后的size \u003E 阈值(加载因子 * 最近容量)\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F**\n     * 代码体现 put后执行\n     *   if (++size \u003E threshold)\n     *         resize();\n     *\u002F\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F有定义容量的话会采用大于这个数的最小二次幂 第一次初始化为1 则输出为2 4 5 11  111 11\u003C\u002Fspan\u003E\n    HashMap&#x3C;Integer,\u003Cspan class=\"hljs-type\"\u003EString\u003C\u002Fspan\u003E\u003E map = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E HashMap&#x3C;\u003E(\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E);\n    map.\u003Cspan class=\"hljs-built_in\"\u003Eput\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E\"一\"\u003C\u002Fspan\u003E);\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F由于方法由final修饰 利用反射机制获取容量值\u003C\u002Fspan\u003E\n    Class&#x3C;?\u003E mapType = map.\u003Cspan class=\"hljs-built_in\"\u003EgetClass\u003C\u002Fspan\u003E();\n    Method capacity = mapType.\u003Cspan class=\"hljs-built_in\"\u003EgetDeclaredMethod\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E\"capacity\"\u003C\u002Fspan\u003E);\n    capacity.\u003Cspan class=\"hljs-built_in\"\u003EsetAccessible\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E); \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F由于capacity方法由final修饰 暴力获取\u003C\u002Fspan\u003E\n    System.out.\u003Cspan class=\"hljs-built_in\"\u003Eprintln\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E\"capacity : \"\u003C\u002Fspan\u003E + capacity.\u003Cspan class=\"hljs-built_in\"\u003Einvoke\u003C\u002Fspan\u003E(map)); \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002Fcapacity : 2\u003C\u002Fspan\u003E\n \n    map.\u003Cspan class=\"hljs-built_in\"\u003Eput\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E\"二\"\u003C\u002Fspan\u003E);\n    capacity = mapType.\u003Cspan class=\"hljs-built_in\"\u003EgetDeclaredMethod\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E\"capacity\"\u003C\u002Fspan\u003E);\n    capacity.\u003Cspan class=\"hljs-built_in\"\u003EsetAccessible\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E);\n    System.out.\u003Cspan class=\"hljs-built_in\"\u003Eprintln\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E\"capacity : \"\u003C\u002Fspan\u003E + capacity.\u003Cspan class=\"hljs-built_in\"\u003Einvoke\u003C\u002Fspan\u003E(map)); \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002Fcapacity : 4 当前容量为2 插入该元素后size为 2 \u003E 2 * 3\u002F4 开始扩容\u003C\u002Fspan\u003E\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F当前容量为4 此时已有2个 3 = 4 * 3\u002F4 不进行扩容\u003C\u002Fspan\u003E\n    map.\u003Cspan class=\"hljs-built_in\"\u003Eput\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E\"三\"\u003C\u002Fspan\u003E);\n    capacity = mapType.\u003Cspan class=\"hljs-built_in\"\u003EgetDeclaredMethod\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E\"capacity\"\u003C\u002Fspan\u003E);\n    capacity.\u003Cspan class=\"hljs-built_in\"\u003EsetAccessible\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E);\n    System.out.\u003Cspan class=\"hljs-built_in\"\u003Eprintln\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E\"capacity : \"\u003C\u002Fspan\u003E + capacity.\u003Cspan class=\"hljs-built_in\"\u003Einvoke\u003C\u002Fspan\u003E(map)); \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002Fcapacity : 4 当前容量为2 插入该元素后size为 3 = 4 * 3\u002F4 不扩容\u003C\u002Fspan\u003E\n\n    map.\u003Cspan class=\"hljs-built_in\"\u003Eput\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-number\"\u003E4\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E\"四\"\u003C\u002Fspan\u003E);\n    capacity = mapType.\u003Cspan class=\"hljs-built_in\"\u003EgetDeclaredMethod\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E\"capacity\"\u003C\u002Fspan\u003E);\n    capacity.\u003Cspan class=\"hljs-built_in\"\u003EsetAccessible\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E);\n    System.out.\u003Cspan class=\"hljs-built_in\"\u003Eprintln\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E\"capacity : \"\u003C\u002Fspan\u003E + capacity.\u003Cspan class=\"hljs-built_in\"\u003Einvoke\u003C\u002Fspan\u003E(map));\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002Fcapacity : 8  当前容量为4 此时已有4个 4 \u003E 4 * 3\u002F4 开始扩容\u003C\u002Fspan\u003E\n}\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E上面的例子可以看出put后，hashmap确实有进行扩容，hashMap的扩容机制与其它的集合边长不太一样，它是通过当前hash桶个数乘2进行扩容\u003C\u002Fp\u003E\u003Cp\u003EhashMap主要是通过resize()方法扩容\u003C\u002Fp\u003E\u003Cp\u003E假设oldTable的key的hash为15，7，4，5，8，1，hashMap为初始容量为8的数组桶，存储位置如下\u003C\u002Fp\u003E\u003Ctable\u003E\u003Cthead\u003E\u003Ctr\u003E\u003Cth\u003Eindex\u003C\u002Fth\u003E\u003Cth\u003E0\u003C\u002Fth\u003E\u003Cth\u003E1\u003C\u002Fth\u003E\u003Cth\u003E2\u003C\u002Fth\u003E\u003Cth\u003E3\u003C\u002Fth\u003E\u003Cth\u003E4\u003C\u002Fth\u003E\u003Cth\u003E5\u003C\u002Fth\u003E\u003Cth\u003E6\u003C\u002Fth\u003E\u003Cth\u003E7\u003C\u002Fth\u003E\u003C\u002Ftr\u003E\u003C\u002Fthead\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003Ehash\u003C\u002Ftd\u003E\u003Ctd\u003E8\u003C\u002Ftd\u003E\u003Ctd\u003E1\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E4\u003C\u002Ftd\u003E\u003Ctd\u003E5\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E7，15\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\u003Cp\u003E当put一个新元素 假设为9，且加载因子使用默认的0.75，在内存空间中新的存储位置如下\u003C\u002Fp\u003E\u003Ctable\u003E\u003Cthead\u003E\u003Ctr\u003E\u003Cth\u003Eindex\u003C\u002Fth\u003E\u003Cth\u003E0\u003C\u002Fth\u003E\u003Cth\u003E1\u003C\u002Fth\u003E\u003Cth\u003E2\u003C\u002Fth\u003E\u003Cth\u003E3\u003C\u002Fth\u003E\u003Cth\u003E4\u003C\u002Fth\u003E\u003Cth\u003E5\u003C\u002Fth\u003E\u003Cth\u003E6\u003C\u002Fth\u003E\u003Cth\u003E7\u003C\u002Fth\u003E\u003Cth\u003E8\u003C\u002Fth\u003E\u003Cth\u003E9\u003C\u002Fth\u003E\u003Cth\u003E10\u003C\u002Fth\u003E\u003Cth\u003E11\u003C\u002Fth\u003E\u003Cth\u003E12\u003C\u002Fth\u003E\u003Cth\u003E13\u003C\u002Fth\u003E\u003Cth\u003E14\u003C\u002Fth\u003E\u003Cth\u003E15\u003C\u002Fth\u003E\u003C\u002Ftr\u003E\u003C\u002Fthead\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003Ehash\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E1\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E4\u003C\u002Ftd\u003E\u003Ctd\u003E5\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E7\u003C\u002Ftd\u003E\u003Ctd\u003E8\u003C\u002Ftd\u003E\u003Ctd\u003E9\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E\u003C\u002Ftd\u003E\u003Ctd\u003E15\u003C\u002Ftd\u003E\u003C\u002Ftr\u003E\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\u003Cp\u003E可以看到扩容之后8跑到了第9个位置，15跑到了第16个位置，旧的8，1，4，5在各自的链表上只有一个节点\u003C\u002Fp\u003E\u003Cp\u003E根据 \u003Cb\u003Ee.hash &#x26; (newCap - 1)\u003C\u002Fb\u003E 相当于 与上15后，都为自己本身所以位置保持不变\u003C\u002Fp\u003E\u003Cp\u003E但是链表上不止有一个节点的情况，比如说上面的7，15存放的位置\u003C\u002Fp\u003E\u003Cp\u003E这个时候是先根据 \u003Cb\u003Ee.hash &#x26; oldCap\u003C\u002Fb\u003E判断元素在数组的位置是否需要移动\u003C\u002Fp\u003E\u003Cp\u003E比如说 7 &#x26; 8 = 0111 &#x26; 1000 = 0 ; 15 &#x26; 8 = 1111 &#x26; 1000 = 1，规律是比较高位的第一个 比如说15为高位，第一个为1，如果高位为1那么与后结果也为1\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E当e.hash &#x26; oldCap == 0时\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E链表上节点位置保持不变\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E当e.hash &#x26; oldCap == 1时\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E链表上节点的位置为原位置的index + oldCap 比如说15，新的索引位置为7+8为15\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003E值得一提的是，jdk1.8的resize()方法相比与之前做了点优化，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但JDK1.8不会倒置，jdk8通过e.hash &#x26; oldCap，通过0和1的值均匀把之前的冲突的节点分散到新的bucket了，这样做更为高效。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003E代码见【4.4.5 resize()方法】\u003C\u002Fp\u003E\u003Ch3 data-id=\"heading-37\"\u003E5.loadFactor加载因子为何为0.75f\u003C\u002Fh3\u003E\u003Cblockquote\u003E\u003Cp\u003E加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之越小。\u003Cbr\u003E简单来说就是如果加载因子太小，空间利用率低，且太容易扩容对性能不太友好，设置太高，不及时扩容容易导致冲突几率大，将提高了查询成本。所以0.75是很合适的值，经过试验，在理想情况下,使用随机哈希码,节点出现的频率在hash桶中遵循泊松分布【在频率附近发生概率高，向两边对称下降。】\u003Cbr\u003E详细见 \u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Fgo%2FarticleRenderRedirect%3Furl%3Dhttps%253A%252F%252Fwww.cnblogs.com%252FDarrenChan%252Fp%252F8854859.html\" target=\"_blank\" title=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fwww.cnblogs.com%2FDarrenChan%2Fp%2F8854859.html\" ref=\"nofollow noopener noreferrer\"\u003E为什么HashMap中默认加载因子为0.75\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Ch3 data-id=\"heading-38\"\u003E6.hashMap中一般使用什么类型的元素作为key，为什么？\u003C\u002Fh3\u003E\u003Cblockquote\u003E\u003Cp\u003E常用String，Integer这样的key\u003Cbr\u003E主要原因为\u003Cbr\u003E这些类是Immutable(不可变的)，String和基本类型的包装类规范的重写了hashCode()和equals()方法。作为不可变类天生是线程安全的，而且可以很好的优化比如可以缓存hash值，避免重复计算等等，如果采用可变的对象类型，可能出现put进去就无法查询到的情况。\u003Cbr\u003E如果想用自定义的类型作为键，那么需要遵守equals()和hashCode()方法的定义规则且不可变，对象插入到map后就不会再改变。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Fgo%2FarticleRenderRedirect%3Furl%3Dhttp%253A%252F%252Fwww.cnblogs.com%252F0201zcr%252Fp%252F4810813.html\" target=\"_blank\" title=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=http%3A%2F%2Fwww.cnblogs.com%2F0201zcr%2Fp%2F4810813.html\" ref=\"nofollow noopener noreferrer\"\u003EHashMap的key可以是可变对象吗？\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Ch3 data-id=\"heading-39\"\u003E7.源码中为什么要用transient修饰桶数组table\u003C\u002Fh3\u003E\u003Cpre\u003E\u003Ccode lang=\"css\" class=\"hljs language-css copyable\"\u003Etransient Node&#x3C;K,V\u003E\u003Cspan class=\"hljs-selector-attr\"\u003E[]\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-selector-tag\"\u003Etable\u003C\u002Fspan\u003E;\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E在java中，被transient关键字修饰的变量不会被默认的序列化机制序列化。\u003C\u002Fp\u003E\u003Cp\u003EhashMap实现了Serializable接口，通过实现\u003Ccode\u003EreadObject\u002FwriteObject\u003C\u002Fcode\u003E两个方法自定义了序列化的内容，size不用多说了，一般涉及到大小可以直接计算的就没必要再序列化。\u003C\u002Fp\u003E\u003Cp\u003E为什么不序列化table？原因有下\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003E1.table大多数情况是无法存满的。比如说桶数组容量是16，只put了一个元素，这会造成序列化未使用的部分。造成浪费。\u003C\u002Fp\u003E\u003Cp\u003E2.同一个键值对在不同jvm下，所处桶的位置可能是不同的，在不同的jvm下反序列化可能发生错误。(hashmap的get\u002Fput\u002Fremove等方法刚开始都是通过hash找到键所在的桶位置，就是数组下标，但如果键没有重写hashCode方法，就会调用Object的hashCode方法，而Object的hashcode方法是navtive(本地方法)的，这里的hashcode是对对象内存地址的映射得出的int结果，具体怎么计算不得而知，但是在不同jvm下，可能有不同的hashcode实现，这样产生的hash也不一样)。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Ch3 data-id=\"heading-40\"\u003E8.HashMap的key如果为null，怎么查找值\u003C\u002Fh3\u003E\u003Cp\u003E我们知道hashMap只允许一个为null的key，如果key为null，因为key为null，那么hash为0，那么p = tab[i = (n - 1) &#x26; hash 也一定为0，所以是从数组上第一个位置的链表下查找。\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode lang=\"java\" class=\"hljs language-java copyable\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Estatic\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Efinal\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-type\"\u003Eint\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title function_\"\u003Ehash\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(Object key)\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-type\"\u003Eint\u003C\u002Fspan\u003E h;\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E (key == \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E) ? \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E : (h = key.hashCode()) ^ (h \u003E\u003E\u003E \u003Cspan class=\"hljs-number\"\u003E16\u003C\u002Fspan\u003E);\n}\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch1 data-id=\"heading-41\"\u003E6.使用建议\u003C\u002Fh1\u003E\u003Cp\u003E1.默认情况下HashMap的容量是16，但是，如果用户通过构造函数指定了一个数字作为容量，那么Hash会选择大于该数字的第一个2的幂作为容量。(1-\u003E2、7-\u003E8、9-\u003E16)\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003E在初始化HashMap的时候，应该尽量指定其大小。尤其是当你已知map中存放的元素个数时。（《阿里巴巴Java开发规约》）\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003E这边可以看下hashMap的4个构造方法，一般采用3，但如果已经知道个数，建议用2(加载因子0.75很合适不建议改动)\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode lang=\"csharp\" class=\"hljs language-csharp copyable\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F1 自定义传初始容量和加载因子\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Epublic\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EHashMap\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003Cspan class=\"hljs-built_in\"\u003Eint\u003C\u002Fspan\u003E initialCapacity, \u003Cspan class=\"hljs-built_in\"\u003Efloat\u003C\u002Fspan\u003E loadFactor\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (initialCapacity &#x3C; \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E)\n        \u003Cspan class=\"hljs-keyword\"\u003Ethrow\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E IllegalArgumentException(\u003Cspan class=\"hljs-string\"\u003E\"Illegal initial capacity: \"\u003C\u002Fspan\u003E +\n                                           initialCapacity);\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (initialCapacity \u003E MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (loadFactor &#x3C;= \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E || Float.isNaN(loadFactor))\n        \u003Cspan class=\"hljs-keyword\"\u003Ethrow\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E IllegalArgumentException(\u003Cspan class=\"hljs-string\"\u003E\"Illegal load factor: \"\u003C\u002Fspan\u003E +\n                                           loadFactor);\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.loadFactor = loadFactor;\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.threshold = tableSizeFor(initialCapacity);\n}\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F2 自定义初始大小 调1构造方法，加载因子使用默认大小\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Epublic\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EHashMap\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003Cspan class=\"hljs-built_in\"\u003Eint\u003C\u002Fspan\u003E initialCapacity\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E {\n        \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E(initialCapacity, DEFAULT_LOAD_FACTOR);\n}\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F3 最常用的无参构造方法\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Epublic\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EHashMap\u003C\u002Fspan\u003E()\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.loadFactor = DEFAULT_LOAD_FACTOR; \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F all other fields defaulted\u003C\u002Fspan\u003E\n}\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F4 将别的map对象映射到自身存储，很少用\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Epublic\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EHashMap\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003EMap&#x3C;? extends K, ? extends V\u003E m\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.loadFactor = DEFAULT_LOAD_FACTOR;\n    putMapEntries(m, \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E);\n}\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E这边讲解一下tableSizeFor方法。简述一下该方法的作用：\u003C\u002Fp\u003E\u003Cp\u003E如果自定义容量大小时(调1或2的构造方法)，传入一个初始容量大小，\u003Cb\u003E大于输入参数且最近的2的整数次幂的数\u003C\u002Fb\u003E。比如10，则返回16，75返回128\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003E不这么做的缺点\u003C\u002Fp\u003E\u003Cp\u003E假设HashMap需要放置1024个元素，由于没有设置初始容量大小，随着元素不断增加，容量7次被迫扩大。而resize过程需要重建hash表，这会严重影响性能。\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cpre\u003E\u003Ccode lang=\"arduino\" class=\"hljs language-arduino copyable\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F**\n * Returns a power of two size for the given target capacity.\n *\u002F\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-type\"\u003Estatic\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Efinal\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-type\"\u003Eint\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EtableSizeFor\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(\u003Cspan class=\"hljs-type\"\u003Eint\u003C\u002Fspan\u003E cap)\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002Fcap-1的目的是因为如果cap是2的幂数不做-1操作的话 那么最后执行完右移操作的话，返回的值将会是原有值得两倍。如果n为0的话，即cap=1，经过后面几次操作返回的为0，最后返回的capacity仍然为1(最后有加1的操作)\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-type\"\u003Eint\u003C\u002Fspan\u003E n = cap - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E;\n    n |= n \u003E\u003E\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E;\n    n |= n \u003E\u003E\u003E \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E;\n    n |= n \u003E\u003E\u003E \u003Cspan class=\"hljs-number\"\u003E4\u003C\u002Fspan\u003E;\n    n |= n \u003E\u003E\u003E \u003Cspan class=\"hljs-number\"\u003E8\u003C\u002Fspan\u003E;\n    n |= n \u003E\u003E\u003E \u003Cspan class=\"hljs-number\"\u003E16\u003C\u002Fspan\u003E;\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E (n &#x3C; \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E) ? \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E : (n \u003E= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E;\n}\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cb\u003E解释一下这段代码\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E在java中，|=的作用是比较两个对象是否相等\u003C\u002Fp\u003E\u003Cp\u003Ea|=b的意思就是把a和b按位或然后赋值给a\u003C\u002Fp\u003E\u003Cp\u003E以10为例整体流程大致如下\u003C\u002Fp\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E\u003Cimg alt=\"img_eadde165ab656c39debed0afc9a20492.png\" src=\"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fgold-user-assets\u002F2019\u002F9\u002F26\u002F16d6cc9bf3b23a1b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp\" loading=\"lazy\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv\u003E算法流程\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E简单来说，这种运算最后会导致1占满了它自己所占位，比如说250，它的二进制为\u003C\u002Fp\u003E\u003Cp\u003E11111010，经过上面的或运算之后，最终将变为11111111，这种情况在加上1，就是大于这个数的最小二次幂。\u003C\u002Fp\u003E\u003Ch1 data-id=\"heading-42\"\u003E7.总结\u003C\u002Fh1\u003E\u003Cp\u003EHashMap的设计与实现十分的巧妙。jdk8更是有很多提升，还没写这篇博客对于HashMap的理解仅仅只在表面。阅读源码后才发现里面还有不少的学问，由于本人水平有限，虽然花了很多时间写了很多但还有很多细节并不了解，比如说红黑树的代码实现细节，也有可能有几个地方描述错误或者不到位，如果文章有误请指正，以便于我及时修改和学习。\u003C\u002Fp\u003E\u003Ch1 data-id=\"heading-43\"\u003E8.参考链接\u003C\u002Fh1\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Fgo%2FarticleRenderRedirect%3Furl%3Dhttp%253A%252F%252Fwww.coolblog.xyz%252F2018%252F01%252F18%252FHashMap-%2525E6%2525BA%252590%2525E7%2525A0%252581%2525E8%2525AF%2525A6%2525E7%2525BB%252586%2525E5%252588%252586%2525E6%25259E%252590-JDK1-8%252F\" target=\"_blank\" title=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=http%3A%2F%2Fwww.coolblog.xyz%2F2018%2F01%2F18%2FHashMap-%25E6%25BA%2590%25E7%25A0%2581%25E8%25AF%25A6%25E7%25BB%2586%25E5%2588%2586%25E6%259E%2590-JDK1-8%2F\" ref=\"nofollow noopener noreferrer\"\u003EHashMap 源码详细分析(JDK1.8)\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Fgo%2FarticleRenderRedirect%3Furl%3Dhttps%253A%252F%252Fwww.cnblogs.com%252Fwoniu4%252Fp%252F8301099.html\" target=\"_blank\" title=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fwww.cnblogs.com%2Fwoniu4%2Fp%2F8301099.html\" ref=\"nofollow noopener noreferrer\"\u003EHashMap resize方法的理解（一)\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Fgo%2FarticleRenderRedirect%3Fspm%3Da2c4e.11153940.0.0.5bf05442WOllqe%26url%3Dhttps%253A%252F%252Fwww.zhihu.com%252Fquestion%252F20733617\" target=\"_blank\" title=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?spm=a2c4e.11153940.0.0.5bf05442WOllqe&#x26;url=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F20733617\" ref=\"nofollow noopener noreferrer\"\u003EJDK 源码中 HashMap 的 hash 方法原理是什么\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Fgo%2FarticleRenderRedirect%3Furl%3Dhttps%253A%252F%252Fwww.cnblogs.com%252Fdongguacai%252Fp%252F5599100.html\" target=\"_blank\" title=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fwww.cnblogs.com%2Fdongguacai%2Fp%2F5599100.html\" ref=\"nofollow noopener noreferrer\"\u003EhashMap死循环问题\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Fgo%2FarticleRenderRedirect%3Furl%3Dhttps%253A%252F%252Fblog.csdn.net%252FLovePluto%252Farticle%252Fdetails%252F79712473\" target=\"_blank\" title=\"https:\u002F\u002Fyq.aliyun.com\u002Fgo\u002FarticleRenderRedirect?url=https%3A%2F%2Fblog.csdn.net%2FLovePluto%2Farticle%2Fdetails%2F79712473\" ref=\"nofollow noopener noreferrer\"\u003E浅谈jdk8为何线程不安全\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fyq.aliyun.com%2Farticles%2F651050\" target=\"_blank\" title=\"https:\u002F\u002Fyq.aliyun.com\u002Farticles\u002F651050\" ref=\"nofollow noopener noreferrer\"\u003Eyq.aliyun.com\u002Farticles\u002F65…\u003C\u002Fa\u003E\u003Cbr\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Cbr\u003E\u003C\u002Fp\u003E",showSidebar:a,actionType:{FETCH:"view\u002Fcolumn\u002FFETCH",FETCH_CACHED_HTML:"view\u002Fcolumn\u002FFETCH_CACHED_HTML",FETCH_ADDITIONAL:"view\u002Fcolumn\u002FFETCH_ADDITIONAL",FETCH_SIDEBAR_ADENTRY:"view\u002Fcolumn\u002FFETCH_SIDEBAR_ADENTRY",FETCH_AUTHOR_EXTRA:"view\u002Fcolumn\u002FFETCH_AUTHOR_EXTRA",RESET:"view\u002Fcolumn\u002FRESET"},recommendedArticleList:{list:[],cursor:f,loading:a,skeleton:a,hasMore:a,articleId:e,actionType:{UPDATE_STATE:"view\u002Fcolumn\u002Frecommend-List\u002FUPDATE_STATE",FETCH_MORE:"view\u002Fcolumn\u002Frecommend-List\u002FFETCH_MORE",FETCH:"view\u002Fcolumn\u002Frecommend-List\u002FFETCH",RESET:"view\u002Fcolumn\u002Frecommend-List\u002FRESET"}}},collection:{collection:{author:{}},actionType:{FETCH:"@\u002Fview\u002Fcollection\u002FFETCH",REFRESH:"@\u002Fview\u002Fcollection\u002FREFRESH",RESET:"@\u002Fview\u002Fcollection\u002FRESET"},list:{pageSize:h,page:g,total:d,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:b,canNext:b,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002Fcollection\u002Flist\u002FUPDATE",FETCH:"@\u002Fview\u002Fcollection\u002Flist\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002Fcollection\u002Flist\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002Fcollection\u002Flist\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fcollection\u002Flist\u002FRESET"},id:e,sort:m}},gettingStarted:{category:{},actionType:{UPDATE_STATE:"@\u002Fview\u002FgettingStarted\u002FUPDATE_STATE",FOLLOW:"@\u002Fview\u002FgettingStarted\u002FFOLLOW",RESET:"@\u002Fview\u002FgettingStarted\u002FRESET",UPDATE_CATEGORY:"@\u002Fview\u002FgettingStarted\u002FUPDATE_CATEGORY"}},pin:{pin:{user:{},imageUrlList:[]},pinList:[],actionType:{FETCH:"@\u002Fview\u002Fpin\u002FFETCH",RESET:"@\u002Fview\u002Fpin\u002FRESET"},sidebar:{list:[],after:e,loading:a,isRecommend:a,hasNextPage:b,actionType:{UPDATE_STATE:"@\u002Fview\u002Fpin\u002Fsidebar\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fpin\u002Fsidebar\u002FFETCH_MORE",FETCH:"@\u002Fview\u002Fpin\u002Fsidebar\u002FFETCH",RESET:"@\u002Fview\u002Fpin\u002Fsidebar\u002FRESET"}},commentList:{pageSize:h,page:g,total:d,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:b,canNext:b,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002Fpin\u002FcommentList\u002FUPDATE",FETCH:"@\u002Fview\u002Fpin\u002FcommentList\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002Fpin\u002FcommentList\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002Fpin\u002FcommentList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fpin\u002FcommentList\u002FRESET"},pinId:c},subCommentList:{pageSize:h,page:g,total:d,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:b,canNext:b,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002Fpin\u002FsubCommentList\u002FUPDATE",FETCH:"@\u002Fview\u002Fpin\u002FsubCommentList\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002Fpin\u002FsubCommentList\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002Fpin\u002FsubCommentList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fpin\u002FsubCommentList\u002FRESET"},commentId:c}},topic:{topic:e,followedTopicList:[],actionType:{FETCH:"@\u002Fview\u002Ftopic\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Ftopic\u002FUPDATE_STATE",RESET:"@\u002Fview\u002Ftopic\u002FRESET"},allTopicList:{pageSize:x,page:d,total:d,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:b,canNext:b,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002Ftopic\u002FallTopicList\u002FUPDATE",FETCH:"@\u002Fview\u002Ftopic\u002FallTopicList\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002Ftopic\u002FallTopicList\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002Ftopic\u002FallTopicList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Ftopic\u002FallTopicList\u002FRESET"},sortType:l},pinlist:{pageSize:h,page:g,total:d,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:b,canNext:b,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002Ftopic\u002FpinList\u002FUPDATE",FETCH:"@\u002Fview\u002Ftopic\u002FpinList\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002Ftopic\u002FpinList\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002Ftopic\u002FpinList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Ftopic\u002FpinList\u002FRESET"},sortType:t},sidebar:{actionType:{RESET:"@\u002Fview\u002Ftopic\u002Fsidebar\u002FRESET",UPDATE_STATE:"@\u002Fview\u002Ftopic\u002Fsidebar\u002FUPDATE_STATE"},attender:{pageSize:h,page:g,total:d,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:b,canNext:b,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002Ftopic\u002Fsidebar\u002Fattender\u002FUPDATE",FETCH:"@\u002Fview\u002Ftopic\u002Fsidebar\u002Fattender\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002Ftopic\u002Fsidebar\u002Fattender\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002Ftopic\u002Fsidebar\u002Fattender\u002FFETCH_MORE",RESET:"@\u002Fview\u002Ftopic\u002Fsidebar\u002Fattender\u002FRESET"},topicId:c}},followedList:{pageSize:x,page:d,total:d,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:b,canNext:b,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002Ftopic\u002FfollowedList\u002FUPDATE",FETCH:"@\u002Fview\u002Ftopic\u002FfollowedList\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002Ftopic\u002FfollowedList\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002Ftopic\u002FfollowedList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Ftopic\u002FfollowedList\u002FRESET"},after:d}},recommendationIndex:{actionType:{FETCH_USER:"@\u002Fview\u002Frecommendation\u002FFETCH_USER",FETCH_MORE:"@\u002Fview\u002Frecommendation\u002FFETCH_MORE",RESET:"@\u002Fview\u002Frecommendation\u002FRESET",FETCH:"@\u002Fview\u002Frecommendation\u002FFETCH"},cursor:e,hasMore:e,userList:[],loading:a,skeleton:b,category:k,categoryNavList:[],serverRenderUserList:a},event:{event:{},loading:a,user:{},actionType:{FETCH:"view\u002Fevent\u002FFETCH",RESET:"view\u002Fevent\u002FRESET"}},academyIndex:{academy:{},bannerList:[],qualitiedList:[],latestList:[],offlineList:[],loading:a,user:{},actionType:{FETCH:"view\u002Facademy\u002FFETCH",RESET:"view\u002Facademy\u002FRESET"}},coursesIndex:{loading:a,list:[],sort:"online",actionType:{FETCH:"view\u002Fcourses\u002FFETCH",RESET:"view\u002Fcourses\u002FRESET",FETCH_MORE:"view\u002Fcourses\u002FFETCH_MORE"}},team:{team:{},loading:b,actionType:{FETCH:"@\u002Fview\u002Fteam\u002FFETCH",RESET:"@\u002Fview\u002Fteam\u002FRESET",UPDATE:"@\u002Fview\u002Fteam\u002FUPDATE",FOLLOW:"@\u002Fview\u002Fteam\u002FFOLLOW"},detailList:{actionType:{RESET:"@\u002Fview\u002Fteam\u002FdetailList\u002FRESET"},posts:{list:[],hasMore:a,skeleton:a,loading:a,sort:m,actionType:{FETCH:"@\u002Fview\u002Fteam\u002FdetailList\u002Fposts\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fteam\u002FdetailList\u002Fposts\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fteam\u002FdetailList\u002Fposts\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fteam\u002FdetailList\u002Fposts\u002FRESET"}},pins:{list:[],hasMore:a,loading:a,skeleton:b,actionType:{FETCH:"@\u002Fview\u002Fteam\u002FdetailList\u002Fpins\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fteam\u002FdetailList\u002Fpins\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fteam\u002FdetailList\u002Fpins\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fteam\u002FdetailList\u002Fpins\u002FRESET"}},hire:{list:[],hasMore:a,cursor:f,loading:a,skeleton:b,actionType:{FETCH:"@\u002Fview\u002Fteam\u002FdetailList\u002Fhire\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fteam\u002FdetailList\u002Fhire\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fteam\u002FdetailList\u002Fhire\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fteam\u002FdetailList\u002Fhire\u002FRESET"}}}},couponList:{list:{"0":u,"1":u,"2":u}},payment:{selectedDiscount:{},bookletDetail:{},coupons:{availables:[],unavailables:[]}}},component:{indexAside:{bannerList:[],userList:[],actionType:{FETCH_BANNER:"@\u002Fcomponent\u002Faside\u002FFETCH_BANNER",FETCH_USER:"@\u002Fcomponent\u002Faside\u002FFETCH_USER",CLOSE_BANNER:"@\u002Fcomponent\u002Faside\u002FCLOSE_BANNER"}}},ore:{oreCount:d},avatarMenuInfo:{},common:{theme:"light"},env:{ua:"Mozilla\u002F5.0 (Windows NT 10.0; Win64; x64) AppleWebKit\u002F537.36 (KHTML, like Gecko) Chrome\u002F107.0.0.0 Safari\u002F537.36"},auth:{user:c,clientId:e,token:e},tag:{subscribedTagList:[]},entry:{isLikeLoading:a},collection:{},comment:{},bookComment:{},repoComment:{},category:{list:[]},user:{subscribedTagList:[]},notification:{unreadCount:{user:d,system:d,total:d}},follow:{subscribedTagList:[]},error:{location:c,errorView:c,statusCode:200},abTest:{info:{}},suspensionPanel:{needSuspension:b},pinComment:{},pin:{deleteDialogVisible:a,reportDialogVisible:a,targetPin:c,isOnFocus:a},topic:{visible:a},activity:{"2020":{},offer:{is_show:d,start_time:d},voteData:{err_no:d,err_msg:"success",data:{face:{title:e,activity_id:"2023",start_time:1657814400,end_time:1667232000,status:n,image:"https:\u002F\u002Fp9-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F9850073320c24201ae2317af2acbc3af~tplv-k3u1fbpfcp-zoom-1.image",close_image:"https:\u002F\u002Fp3-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F882fc263e36347ffbf6d598de520870e~tplv-k3u1fbpfcp-image.image",url:"https:\u002F\u002Fjuejin.org\u002FLUCCut",is_show:d},top:{title:o,activity_id:p,start_time:q,end_time:r,status:g,image:"https:\u002F\u002Fp1-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Fac22d16bd96248f48b9f63ab747a1e04~tplv-k3u1fbpfcp-zoom-1.image",close_image:"https:\u002F\u002Fp1-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F4e7fb9a08a1d4f13889588806b35d2ba~tplv-k3u1fbpfcp-zoom-1.image?",url:"https:\u002F\u002Fjuejin.cn\u002Fchallenge\u002F1?utm_source=app_nav",is_show:g},web_top:{title:o,activity_id:p,start_time:q,end_time:r,status:g,image:j,close_image:j,url:"https:\u002F\u002Fjuejin.cn\u002Fchallenge\u002F1?utm_source=web_nav",is_show:g},plugin_top:{title:o,activity_id:p,start_time:q,end_time:r,status:g,image:j,close_image:j,url:"https:\u002F\u002Fjuejin.cn\u002Fchallenge\u002F1?utm_source=extension_nav",is_show:g},search_top:{title:"我的2021年度报告",activity_id:y,start_time:z,end_time:1642348799,status:n,image:A,close_image:B,url:"https:\u002F\u002Fjuejin.cn\u002Freport2021\u002Fmobile?utm_campaign=report_2021&utm_medium=app_search&share_title=2021%E6%8E%98%E5%8F%8B%E5%B9%B4%E5%BA%A6%E6%8A%A5%E5%91%8A&share_desc=%E8%A7%A3%E9%94%81%E5%B9%B4%E5%BA%A6%E6%8A%A5%E5%91%8A%EF%BC%8C%E9%A2%86%E5%8F%96%E4%B8%93%E5%B1%9E%E5%BE%BD%E7%AB%A0&share_image=https%3A%2F%2Fp9-juejin.byteimg.com%2Ftos-cn-i-k3u1fbpfcp%2F26a9012785e643a6a520ed63b513c57e~tplv-k3u1fbpfcp-image.image",is_show:d},web_search:{title:"字节内部课会员免费学",activity_id:y,start_time:z,end_time:1664121599,status:n,image:A,close_image:B,url:"https:\u002F\u002Fjuejin.cn\u002Fpost\u002F7143435263472041998?utm_source=search&utm_medium=OM&utm_campaign=vip_activity_kxj",is_show:d},jcode_top:{title:o,activity_id:p,start_time:q,end_time:r,status:g,image:j,close_image:j,url:"https:\u002F\u002Fjuejin.cn\u002Fchallenge\u002F1?utm_source=code_nav",is_show:g},offer:{title:e,activity_id:"2020",start_time:1617638400,end_time:1618934400,status:n,image:"https:\u002F\u002Fp9-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F2879410508de459c91ae8b7509ca75f8~tplv-k3u1fbpfcp-zoom-1.image",close_image:"https:\u002F\u002Fp9-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Fa38d640009e14c87a7d29cd95dee27dd~tplv-k3u1fbpfcp-zoom-1.image",url:"https:\u002F\u002Fjuejin-activity.bytedance.net\u002Frank",is_show:d}}}},header:{leadStep:d,isPopupZlink:a},tcc:{tccConfig:c},route:{name:"column",path:v,hash:e,query:{},params:{id:w},fullPath:v,meta:{},from:{name:c,path:C,hash:e,query:{},params:{},fullPath:C,meta:{}}}},serverRendered:b,routePath:v,config:{API_HOST:"api.juejin.cn",CAPTCHA_HOST:"verify.snssdk.com",PLATFORM_APPID:{wechat:1277,weibo:1276,github:1045,wechatApp:1070},http:{}},globalRefs:{}}}(false,true,null,0,"","0",1,20,"topic","https:\u002F\u002Fp6-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F759e2aa805c0461b840e0f0f09ed05fa~tplv-k3u1fbpfcp-zoom-1.image?","recommended","hot","newest",2,"1024 码上掘金编程挑战赛","2022",1666540800,1669823999,"following","popular",{},"\u002Fpost\u002F6844903953566531597","6844903953566531597",100,"2021",1641780000,"https:\u002F\u002Fp3-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Fa06289e83d9640c4b8504d2626cfbbee~tplv-k3u1fbpfcp-image.image","https:\u002F\u002Fp9-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Fe5199830276c4a85bc7c8cb8edecd54d~tplv-k3u1fbpfcp-image.image","\u002F"));</script><script src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/64b4d43.js" defer></script><script src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/d6e38f1.js" defer></script><script src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/85733d1.js" defer></script><script src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/8ecf414.js" defer></script><script src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/e66b202.js" defer></script><script src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/9fca362.js" defer></script><script src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/9332c9f.js" defer></script>
  </body>
</html>
